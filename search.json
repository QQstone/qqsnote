[{"title":"AI辅助编程C++","url":"/qqsnote/2023/08/31/AI-Aided-Coding-CPP/","content":"\nQMetaObject::activate(this, &amp;staticMetaObject, 20, nullptr) 这是QT程序中一条发射信号的指令，对不对\n\n是的，QMetaObject::activate() 是一个用于在 Qt 程序中发射信号的函数。它接受一组参数，其中包括发送信号的对象指针、该对象的元对象（通过静态成员变量 staticMetaObject 访问）、信号的索引以及传递给槽函数的参数。这个函数会查找与指定信号索引相关联的元对象，并调用相关的槽函数。如果信号和槽函数的参数不匹配，或者没有连接到任何槽函数，那么不会执行任何操作。通过调用 QMetaObject::activate() 函数，可以手动触发信号的发送。这在某些情况下很有用，例如在需要自定义信号传输时，或者在使用多线程编程时需要跨线程触发信号。请注意，在正常情况下，应该使用 emit 关键字来发射信号，而不是直接调用 QMetaObject::activate() 函数。emit 关键字可以更简洁地实现信号的发射，并且由于其内部实现了相应的机制，因此通常更可靠和安全。\n","categories":["人工智能"],"tags":["AI","C++"]},{"title":"AI science","url":"/qqsnote/2023/08/31/AI/","content":"提示工程\nLangGraph专注于构建具有记忆和上下文的多步对话智能代理，支持循环数据流处理，解决了传统聊天系统无法获取实时信息的问题。其设计哲学强调动态工作流管理，适合需要复杂决策链的应用（如多轮交互客服）。LangChain作为基础框架，提供模块化组件（如模型封装、提示模板、向量数据库集成），快速搭建 LLM 应用原型。但缺乏对长期对话状态的支持，需结合其他工具增强功能。LangSmith是DevOps 平台，专注于 LLM 应用的调试、测试和部署监控。支持追踪链路执行、分析性能瓶颈，适合生产环境优化。\nMCP全称：模型上下文协议 ，Model Context Protocol，由Claude的母公司Anthropic推出的开源协议，旨在实现大型语言模型（LLM）与外部数据源和工具的集成，提供安全双向的连接。MCP通过统一的接口标准化了应用程序向LLM提供上下文的方式。\nMCP的核心定位是为大型语言模型（LLM）与外部数据源、工具之间提供统一接口，实现标准化连接。其设计理念类似于“AI领域的USB-C接口”，通过协议标准化，打破数据孤岛，避免为每个数据源单独开发定制化连接器，从而降低开发成本和安全风险。\n核心功能作为 AI 大模型的标准化工具箱，允许大模型通过标准化协议与外部工具（如浏览器、文件系统、数据库、代码仓库等）自动化交互，无需手动复制粘贴信息。\nMCP Server：作为 AI 与外部工具的中间层，专精于一类工作（如读写浏览器、操作 Git 仓库等），本质是运行在本地（Node.js/Python 程序）或服务器的程序。\n交互方式：大模型通过操作系统的标准输入通道（stdio）调用 MCP Server，消息格式为特定 JSON 结构，MCP Server 通过代码或 API 访问外部工具完成任务。\nMCP 与 Function Call 的区别优势：整合了各家大模型不同的 Function Call 标准，形成统一协议，支持几乎所有大模型接入（如 Claude、Deepseek 等）。\nMCP：是 Anthropic 提出的标准化通信协议，类比为 “AI 领域的 HTTP 协议” 或 “通用插座”“USB-C 标准”。它规定了上下文与请求的结构化传递方式，要求通信格式符合 JSON-RPC 2.0 标准，用于统一 LLM 与外部数据源、工具之间的交互规范，解决数据孤岛问题。\nFunction Call：是某些大模型（如 OpenAI 的 GPT-4）提供的特有接口特性，类似 “品牌专属充电协议”。它以特定格式让 LLM 产出函数调用请求，由宿主执行对应操作并返回结果。\nCline 是一款集成在 Visual Studio Code（以下简称 VS Code）中的开源 AI 编程助手\n"},{"title":"APNG","url":"/qqsnote/2024/07/24/APNG/","content":"APNG, 全称是“Animated Portable Network Graphics”, 是PNG的位图动画扩展，可以实现png格式的动态图片效果。\nReact 支持React18 react-app.d.ts中缺少对*.apng模块的定义，因为不能直接导入为组件，但可以将格式改为PNG，虽然直接用浏览器打开不会显示动画，但在React中却正常显示import TipAnimation from &quot;..&#x2F;..&#x2F;images&#x2F;tip.apng&quot; &#x2F;&#x2F;Cannot find module definationimport TipAnimation from &quot;..&#x2F;..&#x2F;images&#x2F;tip.png&quot;&lt;img src&#x3D;&#123;TipAnimation&#125; alt&#x3D;&quot;tip_animation&quot; &#x2F;&gt;\n","categories":["前端技术"],"tags":["React"]},{"title":"AI-LiveStreamer","url":"/qqsnote/2025/11/30/AI-LiveStreamer/","content":"数字人Dota AI基于Dota2 GSI\ndota2 helper\n购买域名GoDaddy\n","tags":["AI"]},{"title":"AZ900","url":"/qqsnote/2020/07/17/AZ900/","content":"订阅  付费边界 访问管理策略的边界影响成本的因素：资源类型 服务 位置pricing carculator 产品定价计算器和总拥有成本计算器降低成本：\n\n执行成本分析\n使用Azure顾问监视使用情况\n使用支出限制\n使用Azure预订 提前付款产品\n选择低成本地点和地区\n使用标签标识成本所有者cost manage工具改进应用程序SLA 承诺的性能目标 如某级别月累计停机时间不超过xxx\n\n云计算概览\n\n自称：经济高效、可缩放、具有弹性、始终保持最新状态、可靠且安全\n\n\n资本支出 (Capital Expenditure, CapEx)实体基础设施投入费用, 如服务器、存储、网络、备份、灾后重建、技术人员\n运营支出 (Operational Expenditure, OpEx) 服务/产品使用费用 \n\n\nissue: 测试从Azure Serveice 到 remote DB server的network connections背景：老板要将正在开发的项目放到公网可以访问的服务器上以用来演示，迁移数据库到云端是费事且有额外成本的。\n\n日前的实践找到了控制台的解决方法 创建App Service后其管理面板上Development Tools--SSH，其进入后是linux终端，路径在wwwroot下，常用网络连接工具见&#123;% post-link LinuxTools Linux命令行工具 %&#125; curl命令可用\nbenefitThe public cloud is a shared entity whereby multiple corporations each use a portion of the resources in the cloud. It is the benefit of using a public cloud service for the servers over an on-premises network\n混合云（Hybrid Cloud）公有云的缺点：使用公有云可能无法满足特定的安全要求；公有云可能无法满足政府政策、行业标准或法律要求；不拥有硬件或服务，也无法按照你的意愿管理它们；可能很难满足独特的业务需求，例如必须维护旧版应用程序\n私有云服务和公有云服务的结合，即要架设开放的商用应用，又对部分资源存在硬件或自主管理方面的要求，宜选择私有云例题：Suppose you have two types of applications: legacy applications that require specialized mainframe hardware and newer applications that can run on commodity hardware. Which cloud deployment model would be best for you?A. Public cloudB. Private cloudC. Hybrid cloud\n保留预置的(on-premise)服务器，并且扩展需求，宜选择混合云，即保留原服务器以消除迁移成本，且用公有平台（或其他资源）进行方便的扩展\n例题：You have an on-premises network that contains 100 servers.You need to recommend a solution that provides additional resources to your users. The solution must minimize capital and operational expenditure costs.A. a complete migration to the public cloudB. an additional data centerC. a private cloudD. a hybrid cloud  \n极具争议的一道判断题：An organization that hosts its infrastructure in a private cloud can decommission its data center.答案是False. 希望不要在考场上遇到这么坑爹的表述，题干问如果organization在私有云上架设自己的设施，那他自己数据中心是不可或缺的还是可以decommission（拆除），其想表达的是如果你用公有云或者混合云，就没有必要自己经营数据中心了。\nIaaS PaaS SaaSInfrastructure as a service (IaaS) is an instant computing infrastructure, provisioned and managed over the internet. It’s one of the four types of cloud services, along with software as a service (SaaS), platform as a service (PaaS), and serverless.IaaS 通常用于以下场景：迁移工作负载；测试和开发；存储、备份和恢复。Caution！ 虚拟机是IaaS\n例题：Your company plans to migrate all its data and resources to Azure.The company’s migration plan states that only platform as a service (PaaS) solutions must be used in Azure.You need to deploy an Azure environment that supports the planned migration.Solution: You create an Azure App Service and Azure SQL databases.\nA: Correct. Azure SQL databases 也属于 PaaS，区别于在虚拟机中安装的SQL Server（IaaS）\n例题：Your company plans to migrate all its data and resources to Azure.The company’s migration plan states that only Platform as a Service (PaaS) solutions must be used in Azure.You need to deploy an Azure environment that meets the company migration plan.Solution: You create an Azure App Service and Azure Storage accounts. \nA: False. Azure Storage accounts is IaaS\nCosmos DB is PaaS\n区域、中心Q:Deploying an app can be done directly to what level of physical granularity(尺度)? A:Region\nYou need to ensure that the services running on the virtual machines are available if a  single data center fails.Solution: You deploy the virtual machines to two or more regions.or You deploy the virtual machines to two or more availability zones\n区域间数据传输根据带宽收费\n\nAzure availability zone can be used to protect access to Azure services from an Azure data center failure\n\n计价例题：If you create two Azure virtual machines that use the B2S size, each virtual machine will always generate the same monthly costs.（False）\nTwo virtual machines using the same size could have different disk configurations. Therefore, the monthlycosts could be different.\n“pay-as-you-go”When planning to migrate a public website to Azure, you must plan to pay monthly usage costs. .\n“elasticity”弹性计算, 系统监控工具控制，无需中断操作即可使分配的资源量与实际所需资源量相匹配。通过云灵活性，公司可避免就未用容量或闲置资源付费，且不必担心投入资金购买或维护额外的资源和设备。\n订阅\nAn Azure AD tenant can have multiple subscriptions but an Azure subscription can only be associated with one Azure AD tenant.见将 Azure 订阅关联或添加到 Azure Active Directory 租户\n\n\n资源组\nA resource can interact with resources in other resource groups\nDeleting the resource group will remove the resource group as well as all the resources in that resource group. \nResources from multiple different regions can be placed in a resource group.\n\n资源组中的所有资源应该具有相同的生命周期。 一起部署、更新和删除这些资源。 \n每个资源只能存在于一个资源组中。可以将资源从一个资源组移到另一个组\n资源组中的资源可以位于与资源组不同的区域。 \n\n\n锁定资源以防止意外：CanNotDelete和ReadOnly, 资源可以存在多个删除锁，自动继承上层锁。\nAzure virtual machines should you use from the Azure portal to view service failure notifications that canaffect the availability of VM1(your virtual machine)?\n例题：You need to view a list of planned maintenance events that can affect the availability of an Azure subscription.\nOn the Help and Support blade, there is a Service Health option. If you click Service Health, a new blade opens. The Service Health blade contains the Planned Maintenance link which opens a blade where you can view a list of planned maintenance events that can affect the availability of an Azure subscription.\nAzure服务An integrated solution for the deployment of code - Azure DevOpsA tool that provides guidance and recommendation to improve an Azure environment - zure AdvisorA simplified tool to build intelligent Artificial Intelligence (AI) applications - Azure Cognitive servicesMonitors web applications - Azure Application Insights\n规模集（scale set）如用于创建并管理一组负载均衡的 VM，根据需求或定义的计划自动增减 VM 实例的数目，为应用程序提供搞可用性\nDevTest Lab开发测试实验室，利用基架/模板快速创建环境\n存储账户\nData that is copied to Azure Storage account is maintained automatically in at least three copies.\n\n存储账户的数据冗余选项有4个 每种都以不同的措施复制三次 见存储帐户概述\nCloud shellCloud shell就是页面上那个命令行工具，从中可以运行PowerShell命令或Bash命令\n另install azure cli then it can be used in Command Prompt or Windows PowerShell \n例题：An Azure administrator plans to run a PowerShell script that creates Azure resources. You need to recommend which computer configuration to use to run the script.Solution: Run the script from a computer that runs Linux and has the Azure CLI tools installed.Does this meet the goal?\nanswer：A PowerShell script is a file that contains PowerShell cmdlets and code. A PowerShell script needs to be run in PowerShell.PowerShell can now be installed on Linux. However, the question states that the computer has Azure CLI tools, not PowerShell installed. Therefore, this solution does not meet the goal.\nPowerShell已经是跨平台应用,可以装在linux，azure cli是command line interface可以认为是命令集合，依托于windows cmd或powershell。上面的题目想说powershell脚本运行基于powershell应用而不是azure cli package，私以为题目很无聊。官方教程的练习：What do you need to install on your machine to let you execute Azure CLI commands locally?A.The Azure cloud shell  B.The Azure CLI and Azure PowerShell  C.Only the Azure CLI\n\nTrue or false: The Azure CLI can be installed on Linux, macOS, and Windows, and the CLI commands you use are the same in all platforms.A.True  B.False\nWhich parameter can you add to most CLI commands to get concise, formatted output?A.list  B.table  C.group\n\nanswer is C A B\nAzure命令行没有ping，而使用tcpping\nData Lake例题：You plan to store 20 TB of data in Azure. The data will be accessed infrequently and visualized by using Microsoft Power BI.You need to recommend a storage solution for the data.A. Azure Data LakeB. Azure Cosmos DBC. Azure SQL Data WarehouseD. Azure SQL DatabaseE. Azure Database for PostgreSQL \nanswer is AC，Azure Data Lake\n网络 Local Network Gateway 创建从azure到本地网关的连接 \nYou have an Azure environment that contains 10 virtual networks and 100 virtual machines.You need to limit the amount of inbound traffic to all the Azure virtual networks.What should you create?A. one application security group (ASG)B. 10 virtual network gatewaysC. 10 Azure ExpressRoute circuitsD. one Azure firewall \nanswer is D\nAdvanced2020.9.26勉强通过 准备AZ-303 + AZ-304 即成为Azure Solutions Architect Expert\n\nIt certainly wouldn’t hurt you to have your Microsoft Azure Administrator in the bag before attempting to take down this colossal certification and its dual architecture-focused exams. ————《Which Azure certification is right for me?》\n\n即建议通过AZ-104获得Azure Administrator Associate认证，难度只有两星，费用是115刀\n知乎：Azure 框架设计师认证考试2020大更改\n\n原AZ-103将被新的AZ-104替代，原AZ-300将被新的AZ-303替代，原AZ-301将被新的AZ-304替代AZ-103的考试侧重点分配如下\n\n管理 Azure 订阅和资源 (15-20%)实施和管理存储 (15-20%)部署和管理虚拟机 (VM) (15-20%)配置和管理虚拟网络 (30-35%)管理身份 (15-20%)\n在新的AZ-104中，这些权重将会有一些修改。\n订阅Subscription和身份认证Identity将会合并成单独的身份认证Identity新增考点监控和备份（Monitor and Backup）新增主题： 网络程序和容器（Web apps and containers）\nTwo ways to prepare 见页面下方官方文档\nAZ-300的考试权重分配如下\n\n部署和配置基础设施 (25-30%)\n实现工作负载和安全 (20-25%)\n创建和部署 App (5-10%)\n实现认证和安全数据（5-10%）\n开发云和 Azure 存储 (20-25%)\n\n在新的AZ-303中，这些权重将会有一些修改。\n\n考试中有50%的部分是关于部署和配置（Deploy and Configure）\n去掉了对认证和安全数据的要求\n去掉了对云开发：消息和自动扩展的要求\n新增部署数据平台的要求，包括SQL DB和Cosmos DB\n新增监控的要求 Monitoring\n\nTwo ways to prepare 见页面下方官方文档\nAZ-301的考试权重分配如下\n\n确定工作量要求 (10-15%)\n设计身份和安全性 (20-25%)\n设计数据平台解决方案 (15-20%)\n设计业务连续性策略(15-20%)\n部署、迁移和集成设计（10-15%）\n设计基础设施策略（15-20%）\n\n在新的AZ-304中，这些权重将会有一些修改。\n\n去掉获取信息和要求的部分\n去掉设计认证管理的部分\n去掉危险预防策略的部分\n去掉数据文档流的部分\n去掉数据保护策略的部分\n去掉数据监控策略的部分\n去掉存储策略的部分\n添加设计程序框架\n\nTwo ways to prepare 见页面下方官方文档\n","categories":["云平台"],"tags":["Azure"]},{"title":"ASP和SPA","url":"/qqsnote/2020/08/31/ASPandSPA/","content":"课外：关于传统web app和SPA的选择\n将单页面应用植入到ASP.Net\n方式一：项目模板和spa中间件：% 安装spa template packdotnet new -i Microsoft.DotNet.Web.Spa.ProjectTemplates% 使用模板创建项目 dotnet new --listdotnet new angular -n MyDotnetNgProject\nangular is short for template”ASP.NET Core with Angular”, -n 指定项目名称，键入dotnet new —help查看选项参数说明。项目大致结构│   appsettings.json│   MyDotNetNgProject.csproj│   Program.cs│   Startup.cs├───ClientApp│   │   angular.json│   │   package.json│   │   tsconfig.json│   │   tslint.json│   ├───e2e│   │   └───src│   └───src│       ├───app│       │   ├───counter│       │   ├───fetch-data│       │   ├───home│       │   └───nav-menu│       ├───assets│       └───environments├───Controllers├───obj├───Pages├───Properties│       launchSettings.json└───wwwroot整个前端项目以ClientApp目录为根目录，在ASP的Startup.Configure中调用spa中间件,如下app.UseSpa(spa &#x3D;&gt; &#123;    &#x2F;&#x2F; To learn more about options for serving an Angular SPA from ASP.NET Core,    &#x2F;&#x2F; see https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;864501    spa.Options.SourcePath &#x3D; &quot;ClientApp&quot;;    if (env.IsDevelopment())    &#123;        spa.UseAngularCliServer(npmScript: &quot;start&quot;);    &#125;&#125;);\n方式二：前端发布到wwwroot，使用静态文件和默认页Startup.cspublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123;    app.UseDefaultFiles();    app.UseStaticFiles();    app.UseRouting();    app.UseEndpoints(endpoints &#x3D;&gt;    &#123;        endpoints.MapControllerRoute(            name: &quot;default&quot;,            pattern: &quot;&#123;controller&#x3D;Home&#125;&#x2F;&#123;action&#x3D;Index&#125;&#x2F;&#123;id?&#125;&quot;);    &#125;);&#125;UseDefaultFiles的搜索规则是default.htmdefault.htmlindex.htmindex.html另外可以使用DefaultFilesOptions添加自定义默认页，详见 ASP.NET Core 中的静态文件\nTrouble Shooting\nIssue: The Angular CLI process did not start listening for requests within the timeout period of 0 seconds.\n\n当前的angular模板是基于Angular 8.2.12(记于2020.8.28)，在迁移ng9，ng10项目时出现上述问题。\n见issue#16961\n较深入的分析issue#18062\nworkaround: edit start script&quot;start&quot;: &quot;echo start &amp;&amp; ng serve  --host 0.0.0.0&quot;,\n\n路由问题\n\n拓展ASP.NET Core 上的单页面应用的身份验证简介dotnet new angular -o AspNgIndividualAuthProj -au IndividualCaution! 模板生成同时提供认证授权功能的应用，具体是使用一个叫IdentityServer的框架，IdentityServer封装了提供重定向endpint，生成JWT令牌，校验令牌等功能。 通常情况下，后台服务应对接独立的SSO，下面的大部分内容对此的可参考性很有限\nMSAL + Angular + .Net Core + AD B2CMicrosoft Authentication Library(微软身份认证库MSAL)\n微软栗子真多—&gt; Azure-Samplenpm i msal @azure&#x2F;msal-angular -save-dev引入MSAL模块 @app.module...import &#123; Configuration &#125; from &#39;msal&#39;;import &#123;  MsalModule,  MsalInterceptor,  MSAL_CONFIG,  MSAL_CONFIG_ANGULAR,  MsalService,  MsalAngularConfiguration&#125; from &#39;@azure&#x2F;msal-angular&#39;;import &#123; msalConfig, msalAngularConfig &#125; from &#39;.&#x2F;app-config&#39;;import &#123; AppRoutingModule &#125; from &#39;.&#x2F;app-routing.module&#39;;import &#123; ProfileComponent &#125; from &#39;.&#x2F;profile&#x2F;profile.component&#39;;function MSALConfigFactory(): Configuration &#123;  return msalConfig;&#125;function MSALAngularConfigFactory(): MsalAngularConfiguration &#123;  return msalAngularConfig;&#125;@NgModule(&#123;  declarations: [    AppComponent,    HomeComponent,    ProfileComponent,  ],  imports: [    ...    MsalModule  ],  providers: [    &#123;      provide: HTTP_INTERCEPTORS,      useClass: MsalInterceptor,      multi: true    &#125;,    &#123;      provide: MSAL_CONFIG,      useFactory: MSALConfigFactory    &#125;,    &#123;      provide: MSAL_CONFIG_ANGULAR,      useFactory: MSALAngularConfigFactory    &#125;,    MsalService  ],  bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;另 使用oidc-client的栗子参考oidc-client\n关于.csproj参考：理解 C# 项目 csproj 文件格式的本质和编译流程\n\nPropertyGroup, 声明编译过程中用到的变量，如一些路径，所谓的group，为了增强可读性，而将一组变量放在一个PropertyGroup中，其他的再放一个PropertyGroup&lt;PropertyGroup&gt;  ...  &lt;SpaRoot&gt;ClientApp\\&lt;&#x2F;SpaRoot&gt;&lt;&#x2F;PropertyGroup&gt;\nItemGroup, 顾名思义，存放集合的项，一个group中各项属性名相同，可以认为是类型为XX(即属性名)的一个集合，下例是第三方的package，另外也可以放其他模块所需的任意内容，用相应的属性标识出&lt;ItemGroup&gt;  &lt;PackageReference Include&#x3D;&quot;EntityFrameworkCore.SqlServer.HierarchyId&quot; Version&#x3D;&quot;1.1.1&quot; &#x2F;&gt;  &lt;PackageReference Include&#x3D;&quot;Microsoft.AspNetCore.Mvc.NewtonsoftJson&quot; Version&#x3D;&quot;3.1.2&quot; &#x2F;&gt;  &lt;PackageReference Include&#x3D;&quot;Microsoft.AspNetCore.SpaServices.Extensions&quot; Version&#x3D;&quot;3.1.7&quot; &#x2F;&gt;  &lt;PackageReference Include&#x3D;&quot;Microsoft.EntityFrameworkCore.SqlServer&quot; Version&#x3D;&quot;3.1.7&quot; &#x2F;&gt;&lt;&#x2F;ItemGroup&gt;\nTarget  &lt;Target Name&#x3D;&quot;DebugEnsureNodeEnv&quot; BeforeTargets&#x3D;&quot;Build&quot; Condition&#x3D;&quot; &#39;$(Configuration)&#39; &#x3D;&#x3D; &#39;Debug&#39; And !Exists(&#39;$(SpaRoot)node_modules&#39;) &quot;&gt;  &lt;!-- Ensure Node.js is installed --&gt;  &lt;Exec Command&#x3D;&quot;node --version&quot; ContinueOnError&#x3D;&quot;true&quot;&gt;    &lt;Output TaskParameter&#x3D;&quot;ExitCode&quot; PropertyName&#x3D;&quot;ErrorCode&quot; &#x2F;&gt;  &lt;&#x2F;Exec&gt;  &lt;Error Condition&#x3D;&quot;&#39;$(ErrorCode)&#39; !&#x3D; &#39;0&#39;&quot; Text&#x3D;&quot;Node.js is required to build and run this project. To continue, please install Node.js from https:&#x2F;&#x2F;nodejs.org&#x2F;, and then restart your command prompt or IDE.&quot; &#x2F;&gt;  &lt;Message Importance&#x3D;&quot;high&quot; Text&#x3D;&quot;Restoring dependencies using &#39;npm&#39;. This may take several minutes...&quot; &#x2F;&gt;  &lt;Exec WorkingDirectory&#x3D;&quot;$(SpaRoot)&quot; Command&#x3D;&quot;npm install&quot; &#x2F;&gt;&lt;&#x2F;Target&gt;&lt;Target Name&#x3D;&quot;PublishRunWebpack&quot; AfterTargets&#x3D;&quot;ComputeFilesToPublish&quot;&gt;  &lt;!-- As part of publishing, ensure the JS resources are freshly built in production mode --&gt;  &lt;Exec WorkingDirectory&#x3D;&quot;$(SpaRoot)&quot; Command&#x3D;&quot;npm install&quot; &#x2F;&gt;  &lt;Exec WorkingDirectory&#x3D;&quot;$(SpaRoot)&quot; Command&#x3D;&quot;npm run build -- --prod&quot; &#x2F;&gt;  &lt;Exec WorkingDirectory&#x3D;&quot;$(SpaRoot)&quot; Command&#x3D;&quot;npm run build:ssr -- --prod&quot; Condition&#x3D;&quot; &#39;$(BuildServerSideRenderer)&#39; &#x3D;&#x3D; &#39;true&#39; &quot; &#x2F;&gt;  &lt;!-- Include the newly-built files in the publish output --&gt;  &lt;ItemGroup&gt;    &lt;DistFiles Include&#x3D;&quot;$(SpaRoot)dist\\**; $(SpaRoot)dist-server\\**&quot; &#x2F;&gt;    &lt;DistFiles Include&#x3D;&quot;$(SpaRoot)node_modules\\**&quot; Condition&#x3D;&quot;&#39;$(BuildServerSideRenderer)&#39; &#x3D;&#x3D; &#39;true&#39;&quot; &#x2F;&gt;    &lt;ResolvedFileToPublish Include&#x3D;&quot;@(DistFiles-&gt;&#39;%(FullPath)&#39;)&quot; Exclude&#x3D;&quot;@(ResolvedFileToPublish)&quot;&gt;      &lt;RelativePath&gt;%(DistFiles.Identity)&lt;&#x2F;RelativePath&gt;      &lt;CopyToPublishDirectory&gt;PreserveNewest&lt;&#x2F;CopyToPublishDirectory&gt;      &lt;ExcludeFromSingleFile&gt;true&lt;&#x2F;ExcludeFromSingleFile&gt;    &lt;&#x2F;ResolvedFileToPublish&gt;  &lt;&#x2F;ItemGroup&gt;&lt;&#x2F;Target&gt;\n上例是ASP.NET Core with Angular模板项目使用的build target，两种编译环境，而且其中还有条件语句，有点厉害\n\n","categories":["后端技术"],"tags":["Angular",".Net"]},{"title":"AliyunIOT","url":"/qqsnote/2019/12/31/AliyunIOT/","content":"","categories":["云平台"],"tags":["物联网"]},{"title":"Android","url":"/qqsnote/2024/01/13/Android/","content":"Android是一个基于Linux内核的开源操作系统, 由谷歌开发.它被广泛用于各种设备, 包括智能手机, 平板电脑, 电视和智能手表.\n目前, 安卓是世界上移动设备使用最多的操作系统\nKotlin是由JetBrains开发的一种编程语言. 由谷歌推荐, 无论你是不是安卓新手, 都应该把 Kotlin 作为首选 见Android 的 Kotlin 优先方法\nKotlin Doc\nJetpack Compose\n","categories":["前端技术"],"tags":["Android"]},{"title":"Angular-Carousel","url":"/qqsnote/2021/01/07/Angular-Carousel/","content":"import &#123; Component, ContentChild, Input, TemplateRef &#125; from &quot;@angular&#x2F;core&quot;;@Component(&#123;    selector:&#39;app-partner-carousel&#39;,    template:&#96;    &lt;div class&#x3D;&quot;carousel&quot;&gt;    &lt;div class&#x3D;&quot;btn-pre&quot; (click)&#x3D;&quot;carouselMove(&#39;LEFT&#39;)&quot; [hidden]&#x3D;&quot;carouselIndex&#x3D;&#x3D;&#x3D;0&quot;&gt;&lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;slick-window&quot;&gt;        &lt;div class&#x3D;&quot;slick-container&quot; *ngIf&#x3D;&quot;data.length&gt;0&quot; [ngStyle]&#x3D;&quot;carouselAnimotion&quot;&gt;          &lt;span *ngFor&#x3D;&quot;let dataItem of data&quot;&gt;            &lt;ng-container            *ngIf&#x3D;&quot;dataItemTemplateRef&quot;            [ngTemplateOutlet]&#x3D;&quot;dataItemTemplateRef&quot;            [ngTemplateOutletContext]&#x3D;&quot;&#123;$implicit:dataItem&#125;&quot;&gt;&lt;&#x2F;ng-container&gt;          &lt;&#x2F;span&gt;        &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &lt;div class&#x3D;&quot;btn-next&quot; (click)&#x3D;&quot;carouselMove(&#39;RIGHT&#39;)&quot; [hidden]&#x3D;&quot;carouselIndex&gt;&#x3D;data.length-3&quot;&gt;&lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;    &#96;,    styles:[&#96;.carousel&#123;display:flex&#125;&#96;,    &#96;.slick-window &#123;      position: relative;      width: 690px;      overflow: hidden;      transform: translateZ(0);    &#125;&#96;,    &#96;.slick-container&#123;      transform: translate3d(0px, 0px, 0px);      transition: 0.6s ease-in-out;      &#x2F;&#x2F; width: 1500px;      position: relative;      line-height: inherit;      margin-right: 45px;      overflow-y: hidden;    &#125;&#96;,    &#96;.slick-container&gt;span&#123;display:inline-block&#125;&#96;,    &#96;.btn-pre, .btn-next &#123;      &#x2F;&#x2F; width: 15px;      cursor: pointer;   &#125;&#96;,   &#96;.btn-pre::before, .btn-next::before &#123;      content: &#39;&#39;;      width: 0;      height: 0;      position: absolute;      top: 16px;      border-top: 22px solid transparent;      border-bottom: 22px solid transparent;   &#125;&#96;,   &#96;.btn-pre::before &#123;      border-right: 15px solid #ccc;      border-left: 0px solid transparent;      left: -15px;   &#125;&#96;,   &#96;.btn-next::before &#123;      border-right: 0px solid transparent;      border-left: 15px solid #ccc;   &#125;&#96;]&#125;)export class PartnerCarouselComponent&#123;  readonly slickWidth &#x3D; 230;  carouselAnimotion:any &#x3D; &#123;&#125;;  private _data:Array&lt;any&gt; &#x3D; [];  @Input()     set data(value:Array&lt;any&gt;)&#123;      this.carouselAnimotion.width &#x3D; &#96;$&#123;this.slickWidth * value.length&#125;px&#96;;      this._data &#x3D; value;    &#125;    get data()&#123;      return this._data;    &#125;    @ContentChild(&#39;dataItem&#39;, &#123;static:false&#125;) dataItemTemplateRef:TemplateRef&lt;any&gt;;    carouselIndex:number &#x3D; 0;    constructor()&#123;&#125;    carouselMove(orient: string) &#123;        let distance &#x3D; 0;        if (orient &#x3D;&#x3D;&#x3D; &#39;LEFT&#39;) &#123;          this.carouselIndex &#x3D; this.carouselIndex &gt; 3 ? this.carouselIndex -&#x3D; 3 : 0        &#125;        if (orient &#x3D;&#x3D;&#x3D; &#39;RIGHT&#39;) &#123;          this.carouselIndex &#x3D; this.carouselIndex &lt; this._data.length - 5 ? this.carouselIndex +&#x3D; 3 : this._data.length - 3;        &#125;        distance &#x3D; this.slickWidth * this.carouselIndex;        this.carouselAnimotion.transform &#x3D; &#96;translate3d(-$&#123;distance&#125;px, 0px, 0px)&#96;;    &#125;&#125;\n滑动原理position: relative和transform: translateZ(0)将‘窗口’定位，其子元素是宽度超过屏幕宽度的所有滑块的集合，这个超长的‘胶片’用translate3d控制移动，使其某一格可以暴露在窗口中移动的动画效果为 transition: 0.6s ease-in-out\n循环体套用父元素模板子组件(Carousel)中，为每个item套用其宿主定义的template，这里用到了NgContainer和TemplateRef，NgContainer使组件可以内嵌视图模板，内嵌的内容（ng-template）用ViewChild读取，此处声明为dataItemTemplateRef，使用NgTemplateOutlet指令将dataItemTemplateRef插入到ng-content位置，同时可以用ngTemplateOutletContext指令为内嵌视图附加一个上下文对象，显然就是为传递循环体的item打造的。使用#id指定要插入到ng-container的template官方示例:&lt;ng-container *ngTemplateOutlet&#x3D;&quot;greet&quot;&gt;&lt;&#x2F;ng-container&gt;&lt;hr&gt;&lt;ng-container *ngTemplateOutlet&#x3D;&quot;eng; context: myContext&quot;&gt;&lt;&#x2F;ng-container&gt;&lt;hr&gt;&lt;ng-container *ngTemplateOutlet&#x3D;&quot;svk; context: myContext&quot;&gt;&lt;&#x2F;ng-container&gt;&lt;hr&gt;&lt;ng-template #greet&gt;&lt;span&gt;Hello&lt;&#x2F;span&gt;&lt;&#x2F;ng-template&gt;&lt;ng-template #eng let-name&gt;&lt;span&gt;Hello &#123;&#123;name&#125;&#125;!&lt;&#x2F;span&gt;&lt;&#x2F;ng-template&gt;&lt;ng-template #svk let-person&#x3D;&quot;localSk&quot;&gt;&lt;span&gt;Ahoj &#123;&#123;person&#125;&#125;!&lt;&#x2F;span&gt;&lt;&#x2F;ng-template&gt;其中 myContext = {$implicit: ‘World’, localSk: ‘Svet’};模板中用let-绑定上下文, $implicit(implicit 隐式的)指默认值，也就是例如let-keyXX=”parameterXX”的语法在缺省=”parameterXX”的表达下的值\n响应式解决方案npm install @angular/sdk注意该package大版本跟随Angular版本Angular CDK Layoutconstructor(private breakpointObserver: BreakpointObserver) &#123;    this.breakpointObserver.observe([Breakpoints.XSmall, Breakpoints.Small]).subscribe(result &#x3D;&gt; &#123;      if (result.matches) &#123;        &#x2F;&#x2F; max-width: 959px        this.windowWidth &#x3D; &#123; width: &#96;$&#123;this.slickWidth&#125;px&#96; &#125;;        this.interval &#x3D; 1;      &#125; else &#123;        this.windowWidth &#x3D; &#123; width: &#96;$&#123;this.slickWidth * 3&#125;px&#96; &#125;;        this.interval &#x3D; 3;      &#125;    &#125;);&#125;\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular-SPECS","url":"/qqsnote/2020/12/14/Angular-SPECS/","content":"封装一个http的provider，参考ionic3+angular4 HttpClient封装优化\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular-Tips","url":"/qqsnote/2020/12/14/Angular-Tips/","content":"ngFor loop with async pipe参数订阅可观察对象的值，从而保持最新，当数据更新时，循环渲染的视图会随之更新，见StackOverflow:*ngFor loop with async pipe?完整栗子：@Component(&#123;  selector: &#39;users-list&#39;,  template: &#96;      &lt;ul&gt;        &lt;li *ngFor&#x3D;&quot;let user of users$ | async&quot;&gt;          &#123;&#123; user.username &#125;&#125;         &lt;&#x2F;li&gt;      &lt;&#x2F;ul&gt;  &#96;&#125;)export class UsersListComponent &#123;  users$;  constructor(private http: Http) &#123;  &#125;  ngOnInit() &#123;    this.users$ &#x3D; this.http        .get(&#39;&#x2F;api&#x2F;users&#39;)        .map(res &#x3D;&gt; res.json());  &#125;&#125;如果需要基于返回值的其他参数，有*ngFor&#x3D;&quot;let user of users$ | async as users; index as i&quot;这里的users就是Array类型了类似的ngIf也可以用异步管道,形如*ngIf=”user$ | async as user”，显然这里的user$应为Observable\\\nngIf else&lt;div *ngIf&#x3D;&quot;isLoggedIn(); else notLoggedIn&quot;&gt;    Hi, &#123;%raw%&#125;&#123;&#123; user.name &#125;&#125;!&#123;%endraw%&#125;&lt;&#x2F;div&gt;&lt;ng-template #notLoggedIn&gt;    You&#39;re not logged in.&lt;&#x2F;ng-template&gt;\n事件‘委托’需求是文件上传，往往隐藏input type=”file”而放一个好看的入口。事件可以直接在HTML的native element上触发，在jQuery中$(&quot;#fileInput&quot;).click();原生jsdocument.getElementById(&quot;fileInput&quot;).click();Angular可以使用viewChild获取元素@ViewChild(&#39;fileInput&#39;) fileInput:ElementRef;constructor(private renderer:Renderer) &#123;&#125;showImageBrowseDlg() &#123;  let event &#x3D; new MouseEvent(&#39;click&#39;, &#123;bubbles: true&#125;);  this.renderer.invokeElementMethod(      this.fileInput.nativeElement, &#39;dispatchEvent&#39;, [event]);&#125;MDN:dispatchEvent通过dom结构定位元素&lt;div style&#x3D;&quot;width: 128px; height: 128px; background-color: #fafafa;  border: 1px dashed #d9d9d9;  border-radius: 2px;cursor: pointer;display: flex;justify-content: center;align-items: center;&quot;  (click)&#x3D;&quot;showImageBrowseDlg($event)&quot;&gt; +   &lt;input type&#x3D;&quot;file&quot; style&#x3D;&quot;display: none;&quot; (change)&#x3D;&quot;handleUpload($event)&quot;&gt;&lt;&#x2F;div&gt;showImageBrowseDlg(event)&#123;  if(event.target.children[0])&#123;      const fileinput:HTMLElement &#x3D; event.target.children[0] as HTMLElement;      fileinput.click();      event.stopPropagation();  &#125;&#125;\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular工作空间配置","url":"/qqsnote/2020/12/17/Angular-WorkspaceConfig/","content":"工作区配置文件就是angular.json\n关于当前Project&quot;MyApp&quot;: &#123;    &quot;root&quot;: &quot;&quot;,    &quot;sourceRoot&quot;: &quot;src&quot;,    &quot;projectType&quot;: &quot;application&quot;,    &quot;prefix&quot;: &quot;app&quot;,    &quot;schematics&quot;: &#123;    &quot;@schematics&#x2F;angular:component&quot;: &#123;&#125;&#125;,\n编译/测试等工具关于build targetarchitect/build 节会为 ng build 命令的选项配置默认值。它具有下列顶层属性:builder,option,configurations.另外对应ng serve,ng test,ng lint命令，有architect/serve|test|lint命令\n\nbuilder就是个编译器名字，默认是@angular-devkit/build-angular:browser，(ng test的是karma，ng lint的是tslint)\noptions提供构建时的选项及默认值，私以为这些option可以认为是builder工具链所需参数，因而在test和lint中也各有不同&quot;options&quot;: &#123;    &quot;aot&quot;: true,    &quot;progress&quot;: false,    &quot;extractCss&quot;: true,    &quot;outputPath&quot;: &quot;dist&quot;,    &quot;index&quot;: &quot;src&#x2F;index.html&quot;,    &quot;main&quot;: &quot;src&#x2F;main.ts&quot;,    &quot;polyfills&quot;: &quot;src&#x2F;polyfills.ts&quot;,    &quot;tsConfig&quot;: &quot;src&#x2F;tsconfig.app.json&quot;,    &quot;assets&quot;: [        &quot;src&#x2F;favicon.ico&quot;,        &quot;src&#x2F;assets&quot;,        &#123;        &quot;glob&quot;: &quot;**&#x2F;*&quot;,        &quot;input&quot;: &quot;.&#x2F;node_modules&#x2F;@ant-design&#x2F;icons-angular&#x2F;src&#x2F;inline-svg&#x2F;&quot;,        &quot;output&quot;: &quot;&#x2F;assets&#x2F;&quot;        &#125;    ],    &quot;styles&quot;: [        &quot;src&#x2F;theme.less&quot;,        &quot;src&#x2F;styles.scss&quot;    ],    &quot;scripts&quot;: []&#125;\nconfigurations 脚手架生成项目会添加一个production的配置在这里，对编译进行部分优化以及打包限制，ng build 带—prod参数(注意—xxx是命令参数)使用该production配置，可以仿照production写其他(如 stage)配置，使用时形如 ng build —configuration stage另配置可以加载复数个，后者的项会覆盖前者：ng build —configuraion staging,fr“configurations”: {  “production”: {  &quot;fileReplacements&quot;: [\n  &#123;\n      &quot;replace&quot;: &quot;src/environments/environment.ts&quot;,\n      &quot;with&quot;: &quot;src/environments/environment.prod.ts&quot;\n  &#125;\n  ],\n  &quot;optimization&quot;: true,\n  &quot;outputHashing&quot;: &quot;all&quot;,\n  &quot;sourceMap&quot;: false,\n  &quot;extractCss&quot;: true,\n  &quot;namedChunks&quot;: false,\n  &quot;aot&quot;: true,\n  &quot;extractLicenses&quot;: true,\n  &quot;vendorChunk&quot;: false,\n  &quot;buildOptimizer&quot;: true,\n  &quot;budgets&quot;: [\n  &#123;\n      &quot;type&quot;: &quot;initial&quot;,\n      &quot;maximumWarning&quot;: &quot;2mb&quot;,\n      &quot;maximumError&quot;: &quot;5mb&quot;\n  &#125;,\n  &#123;\n      &quot;type&quot;: &quot;anyComponentStyle&quot;,\n      &quot;maximumWarning&quot;: &quot;6kb&quot;,\n      &quot;maximumError&quot;: &quot;10kb&quot;\n  &#125;\n  ]\n  }}```样式预处理选项Angular Doc:Styles and scripts configuration\n\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular 多语言","url":"/qqsnote/2020/05/11/Angular-i18n/","content":"国际化和本地化\nInternationalization is the process of designing and preparing your app to be usable in different languages. Localization is the process of translating your internationalized app into specific languages for particular locales.\n\n国际化是将应用程序设计以及预备，使之支持不同的语言的过程。 本地化是一个把国际化的应用根据区域配置翻译成特定语言的过程。\n国际化设计是实现“多语言切换”的前提，angular框架的国际化基础是i18n模块\n框架本地化（Localization）为应用配置“地区”，这个地区成为查找相应的本地化数据的依据。ng add @angular&#x2F;localize异常：\n\nUncaught Error: It looks like your application or one of its dependencies is using i18n.Angular 9 introduced a global `$localize()` function that needs to be loaded.Please run `ng add @angular/localize` from the Angular CLI.(For non-CLI projects, add `import ‘@angular/localize/init’;` to your `polyfills.ts` file.\n\n如上所述，需要添加 import ‘@angular/localize/init’ 到 polyfills.ts\n模板翻译\n在组件模板中标记需要翻译的静态文本信息。\n &lt;h1 i18n&gt;Hello QQs&lt;&#x2F;h1&gt;&lt;h1 i18n&#x3D;&quot;say hello|translate hello&quot;&gt;Hello QQs&lt;&#x2F;h1&gt;\n 在组件上添加i18n属性，标记该文本待翻译，另外可附上“&lt;意图&gt;|&lt;描述&gt;”，注意这些文字并不作为翻译条目的标识符，只是增强代码的可读性 i18n提取工具会为这些标记的单元生成一个随机的id，这个才是标识符，该id可自定义如下\n &lt;h1 i18n&#x3D;&quot;@@introductionHeader&quot;&gt;Hello QQs&lt;&#x2F;h1&gt;\n 非文本内容标签（待翻译文本是组件属性，而非内容）的标记\n &lt;img [src]&#x3D;&quot;logo&quot; i18n-title title&#x3D;&quot;Angular logo&quot; &#x2F;&gt;\n 单复数问题\n &lt;span i18n&gt;Updated &#123;minutes, plural, &#x3D;0 &#123;just now&#125; &#x3D;1 &#123;one minute ago&#125; other &#123;&#123;&#123;minutes&#125;&#125; minutes ago&#125;&#125;&lt;&#x2F;span&gt;&lt;!-- 期望： --&gt;&lt;!-- 当minutes&#x3D;0时，翻译文本“Updated just now” --&gt;&lt;!-- 当minutes&#x3D;1时，翻译文本“Updated one minute ago” --&gt;&lt;!-- 其他，翻译文本“Updated xx minutes ago” --&gt;\n plural /ˈplʊərəl/ 复数的 这里是复数翻译模式的关键字\n 选择问题\n &lt;span i18n&gt;The author is &#123;gender, select, male &#123;male&#125; female &#123;female&#125; other &#123;other&#125;&#125;&lt;&#x2F;span&gt;\n创建翻译文件：使用 Angular CLI 的 xi18n 命令，把标记过的文本提取到一个符合行业标准的翻译源文件中。ng xi18n --i18n-format&#x3D;xlf --output-path src&#x2F;locale --out-file translate.xlf\n 得到的是一个xml语言的标准格式文件 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;    &lt;xliff version&#x3D;&quot;1.2&quot; xmlns&#x3D;&quot;urn:oasis:names:tc:xliff:document:1.2&quot;&gt;    &lt;file source-language&#x3D;&quot;en&quot; datatype&#x3D;&quot;plaintext&quot; original&#x3D;&quot;ng2.template&quot;&gt;        &lt;body&gt;        &lt;trans-unit id&#x3D;&quot;introductionHeader&quot; datatype&#x3D;&quot;html&quot;&gt;            &lt;source&gt;Hello QQs&lt;&#x2F;source&gt;            &lt;context-group purpose&#x3D;&quot;location&quot;&gt;            &lt;context context-type&#x3D;&quot;sourcefile&quot;&gt;src&#x2F;app&#x2F;app.component.html&lt;&#x2F;context&gt;            &lt;context context-type&#x3D;&quot;linenumber&quot;&gt;353&lt;&#x2F;context&gt;            &lt;&#x2F;context-group&gt;        &lt;&#x2F;trans-unit&gt;        &lt;trans-unit id&#x3D;&quot;updatetime&quot; datatype&#x3D;&quot;html&quot;&gt;            &lt;source&gt;Updated &lt;x id&#x3D;&quot;ICU&quot; equiv-text&#x3D;&quot;&#123;minutes, plural, &#x3D;0 &#123;...&#125; &#x3D;1 &#123;...&#125; other &#123;...&#125;&#125;&quot;&#x2F;&gt;&lt;&#x2F;source&gt;            &lt;context-group purpose&#x3D;&quot;location&quot;&gt;            &lt;context context-type&#x3D;&quot;sourcefile&quot;&gt;src&#x2F;app&#x2F;app.component.html&lt;&#x2F;context&gt;            &lt;context context-type&#x3D;&quot;linenumber&quot;&gt;354&lt;&#x2F;context&gt;            &lt;&#x2F;context-group&gt;        &lt;&#x2F;trans-unit&gt;        &lt;trans-unit id&#x3D;&quot;5a134dee893586d02bffc9611056b9cadf9abfad&quot; datatype&#x3D;&quot;html&quot;&gt;            &lt;source&gt;&#123;VAR_PLURAL, plural, &#x3D;0 &#123;just now&#125; &#x3D;1 &#123;one minute ago&#125; other &#123;&lt;x id&#x3D;&quot;INTERPOLATION&quot; equiv-text&#x3D;&quot;&#123;&#123;minutes&#125;&#125;&quot;&#x2F;&gt; minutes ago&#125; &#125;&lt;&#x2F;source&gt;            &lt;context-group purpose&#x3D;&quot;location&quot;&gt;            &lt;context context-type&#x3D;&quot;sourcefile&quot;&gt;src&#x2F;app&#x2F;app.component.html&lt;&#x2F;context&gt;            &lt;context context-type&#x3D;&quot;linenumber&quot;&gt;354&lt;&#x2F;context&gt;            &lt;&#x2F;context-group&gt;        &lt;&#x2F;trans-unit&gt;        &lt;&#x2F;body&gt;    &lt;&#x2F;file&gt;    &lt;&#x2F;xliff&gt;\n编辑所生成的翻译文件：把提取出的文本翻译成目标语言。复制上面生成的翻译格式文件，填入翻译后的文本\n&lt;trans-unit id&#x3D;&quot;introductionHeader&quot; datatype&#x3D;&quot;html&quot;&gt;    &lt;source&gt;Hello QQs&lt;&#x2F;source&gt;    &lt;target&gt;你好，爸爸&lt;&#x2F;target&gt;&lt;&#x2F;trans-unit&gt;&lt;trans-unit id&#x3D;&quot;updatetime&quot; datatype&#x3D;&quot;html&quot;&gt;    &lt;source&gt;Updated &lt;x id&#x3D;&quot;ICU&quot; equiv-text&#x3D;&quot;&#123;minutes, plural, &#x3D;0 &#123;...&#125; &#x3D;1 &#123;...&#125; other &#123;...&#125;&#125;&quot;&#x2F;&gt;&lt;&#x2F;source&gt;    &lt;target&gt;&#123;VAR_PLURAL, plural, &#x3D;0 &#123;方才&#125; &#x3D;1 &#123;il y 刚片刻&#125; other &#123;il y a &lt;x id&#x3D;&quot;INTERPOLATION&quot; equiv-text&#x3D;&quot;&#123;&#123;minutes&#125;&#125;&quot;&#x2F;&gt; 分钟前&#125; &#125;&lt;&#x2F;target&gt;&lt;&#x2F;trans-unit&gt;\n\n将目标语言环境和语言翻译添加到应用程序的配置中。\na. 配置AOT编译\n警告,此处存在版本差异：Angular v9 angular.json \n&quot;projects&quot;: &#123;    ...    &quot;my-project&quot;: &#123;        ...        &quot;i18n&quot;: &#123;            &quot;sourceLocale&quot;: &quot;en-US&quot;,            &quot;locales&quot;: &#123;                &quot;fr&quot;: &quot;src&#x2F;locale&#x2F;messages.fr.xlf&quot;,                &quot;zh&quot;: &quot;src&#x2F;locale&#x2F;translate.zh-cn.xlf&quot;            &#125;        &#125;    &#125;&#125;\n调用ng build —prod —localize构建 i18n 下定义的所有语言环境。生成若干套静态资源：\ndist  └───my-project        ├───en-US        ├───fr        └───zh\n配置特定的语言环境，指定Locale_ID\n&quot;build&quot;: &#123;    &quot;configurations&quot;: &#123;        &quot;fr&quot;: &#123;             &quot;aot&quot;: true,             &quot;outputPath&quot;: &quot;dist&#x2F;my-project-fr&#x2F;&quot;,             &quot;i18nFile&quot;: &quot;src&#x2F;locale&#x2F;messages.fr.xlf&quot;,             &quot;i18nFormat&quot;: &quot;xlf&quot;,             &quot;i18nLocale&quot;: &quot;fr&quot;,             &quot;i18nMissingTranslation&quot;: &quot;error&quot; &#x2F;&#x2F;报告缺失的翻译 提醒级别为error         &#125;         ...    &#125;    ...&#125;\nAngular v8 angular.json \n...&quot;architect&quot;: &#123;    &quot;build&quot;: &#123;        &quot;builder&quot;: &quot;@angular-devkit&#x2F;build-angular:browser&quot;,        &quot;options&quot;: &#123; ... &#125;,        &quot;configurations&quot;: &#123;            &quot;fr&quot;: &#123;                &quot;aot&quot;: true,                &quot;outputPath&quot;: &quot;dist&#x2F;my-project-fr&#x2F;&quot;,                &quot;i18nFile&quot;: &quot;src&#x2F;locale&#x2F;messages.fr.xlf&quot;,                &quot;i18nFormat&quot;: &quot;xlf&quot;,                &quot;i18nLocale&quot;: &quot;fr&quot;,                &quot;i18nMissingTranslation&quot;: &quot;error&quot;,            &#125;        &#125;    &#125;,    ...    &quot;serve&quot;: &#123;        &quot;builder&quot;: &quot;@angular-devkit&#x2F;build-angular:dev-server&quot;,        &quot;options&quot;: &#123;            &quot;browserTarget&quot;: &quot;my-project:build&quot;        &#125;,        &quot;configurations&quot;: &#123;            &quot;production&quot;: &#123;                &quot;browserTarget&quot;: &quot;my-project:build:production&quot;            &#125;,            &quot;fr&quot;: &#123;                &quot;browserTarget&quot;: &quot;my-project:build:fr&quot;            &#125;        &#125;    &#125;&#125;\n可见 angular.json中，为ng build命令添加了3个用于国际化的参数i18nFile，i18nFormat，i18nLocale。另外指定outputPath用以区分不同语言版本, 这些参数也可以通过cli附加命令的配置项\nng build --prod --i18n-file src&#x2F;locale&#x2F;messages.fr.xlf --i18n-format xlf --i18n-locale fr\nng serve 命令是通过browsertarget:my-project:build使用ng build 的配置，并不直接支持上述用于国际化的参数，而以下面的方式调用\nng serve --configuration&#x3D;fr\nb. 配置JIT编译\n\n载入合适的翻译文件，作为字符串常量\n创建相应的translation provider\n使用translation provider启动app\n\nmain.ts\nimport &#123; enableProdMode, TRANSLATIONS, TRANSLATIONS_FORMAT, MissingTranslationStrategy &#125; from &#39;@angular&#x2F;core&#39;;import &#123; platformBrowserDynamic &#125; from &#39;@angular&#x2F;platform-browser-dynamic&#39;;import &#123; AppModule &#125; from &#39;.&#x2F;app&#x2F;app.module&#39;;import &#123; environment &#125; from &#39;.&#x2F;environments&#x2F;environment&#39;;if (environment.production) &#123;enableProdMode();&#125;&#x2F;&#x2F; use the require method provided by webpackdeclare const require;&#x2F;&#x2F; we use the webpack raw-loader to return the content as a stringconst translations &#x3D; require(&#39;raw-loader!.&#x2F;locale&#x2F;translate.fr.xlf&#39;).default;platformBrowserDynamic().bootstrapModule(AppModule,&#123;missingTranslation: MissingTranslationStrategy.Error,providers: [    &#123;provide: TRANSLATIONS, useValue: translations&#125;,    &#123;provide: TRANSLATIONS_FORMAT, useValue: &#39;xlf&#39;&#125;]&#125;).catch(err &#x3D;&gt; console.error(err));\napp.module.ts\n@NgModule(&#123;declarations: [    AppComponent],imports: [    BrowserModule,    AppRoutingModule],providers: [&#123; provide: LOCALE_ID, useValue: &#39;fr&#39; &#125;],bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;\n\n\n多语言切换 ngx-translate关于ngx-translate Ngx-translate文章\n","categories":["前端技术"],"tags":["Angular","多语言"]},{"title":"AngularAOTandJIT","url":"/qqsnote/2020/05/21/AngularAOTandJIT/","content":"\nng build, ng serve是JIT， ng build —aot, ng build —prod, ng serve —aot是AOT 从Angular 9开始，默认情况下，对于提前编译器，编译选项设置为true。\n\nJIT(Just in Time)由浏览器将源码编译成js执行，QQs:浏览器居然可以编译代码！AOT(Ahead of Time)先编译成可执行的js，再交给浏览器 \n\nThe Angular ahead-of-time (AOT) compiler converts Angular HTML and TypeScript code into efficient JavaScript code during the build phase, before the browser downloads and runs that code. This is the best compilation mode for production environments, with decreased load time and increased performance compared to just-in-time (JIT) compilation.AOT 编译器在浏览器下载并运行之前，将Angular HTML、 ts代码转为es5代码，是生产环境的最佳实践，相比JIT更能缩短加载时间并提高性能（aot会根据angular.json 的配置生成到/dist之类的目录） 在angular.json中配置build命令的选项，包括生成目录等\n\nwhat is aot and jit compiler in angular\nLi Mei’s Blog: Angular深入理解编译机制采取两种编译方式，注意修改angular.json architect.build.option.aot改为false，比较不使用—aot和使用时生成js的内容(见main.js, vendor.js是包含compiler等工具链的源码)，可见生成的js包含angular模板语法，只是ts编译成了es5\n另，使用source-map-explorer工具分析编译生成的js文件npx source-map-explorer dist&#x2F;main.js --no-border-checksAngular Doc: AOT工作原理YouTube: ng-confAngular编译机制（AOT、JIT）AOT和ngcngc是专用于Angular项目的tsc替代者。它内部封装了tsc，还额外增加了用于Angular的选项、输出额外的文件。配置见于tsconfig.json, tsc读取tsconfig配置文件的compilerOptions部分，ngc读取angularCompilerOptions部分。\nto be continue\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular About Test","url":"/qqsnote/2020/04/26/AngularAboutTest/","content":"lint静态代码检查(static code verify)，运行ng lint，根据项目目录下的tslint.json所配置的规则，检查诸如命名，空行，triple-equals等书写规范，在命令行输出违反规范的位置。加参数—fix可自动修复绝大多数的检查错误\nUnfortunately，tslint已于2019宣布停止维护，并迁移至typescript-eslint，见TSLint in 2019关于从TSLint到typescript-eslint，参考Migrate the repo to ESLint, 实际上只需npx tslint-to-eslint-config对于Angular，关于迁移，Angular团队提出了关于性能以及与现有工具链一致性的要求，见issue#13732, 目前有angular-eslint plugin支持10.1及以上版本，以实现从tslint到eslint的迁移##Step 1 - Add relevant dependenciesng add @angular-eslint&#x2F;schematics##Step 2 - Run the convert-tslint-to-eslint schematic on a projectng g @angular-eslint&#x2F;schematics:convert-tslint-to-eslint &#123;&#123;YOUR_PROJECT_NAME_GOES_HERE&#125;&#125;##Step 3 - Remove root TSLint configuration and use only ESLint\nKarmaKarma, 业（佛教观念，个人因果的集合）Karma是测试JavaScript代码而生的自动化测试管理工具，可监控文件的变化，自动执行测试。&quot;karma&quot;: &quot;^5.0.2&quot;,&quot;karma-chrome-launcher&quot;: &quot;~3.1.0&quot;,&quot;karma-coverage-istanbul-reporter&quot;: &quot;~2.1.0&quot;,&quot;karma-jasmine&quot;: &quot;~2.0.1&quot;,&quot;karma-jasmine-html-reporter&quot;: &quot;^1.4.2&quot;,\nJasmine （Jasminum 茉莉）Angular CLI 会下载并安装试用 Jasmine 测试框架 测试 Angular 应用X.spec.ts文件用于Jasmine做单元测试见Jasmine\n单元测试\n单元测试（英語：Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。 程序单元是应用的最小可测试部件。 在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。\n\n单元测试是为了测试代码逻辑，每个‘单元’在用例场景下是否能返回期望的结果，仅此而已栗子假设为UserService.ts设计单元测试，须知export class UserService&#123;  constructor(private commonHTTP:CommonHTTPService)&#123; &#125;  getUserByID(id:string):Observable&lt;any&gt;&#123;    return commonHTTP.get(id)  &#125;&#125;UserService.spec.tsdescribe(&#39;UserService&#39;, ()&#x3D;&gt;&#123;  it(&#39;getUserByID return stubbed value from a spy&#39;, ()&#x3D;&gt;&#123;    const commonHTTPSpy &#x3D; jasmine.createSpyObj(&#39;CommonHTTPService&#39;, [&#39;get&#39;]);    const stubValue &#x3D; &#39;stub value&#39;;    commonHTTPSpy.get.and.returnValue(stubValue);    const userService &#x3D; new UserService(commonHTTPSpy);    expect(userService.getUserByID(1)).toBe(stubValue,&#39;service returned stub value&#39;)  &#125;)&#125;);上例待测\ne2eng e2e builds and serves app, then runs end-to-end test with Protractor(端对端测试工具，protractor原意是量角器，Angular是角).\n配置使用Headless ChromeAngular.cn: 为在 Chrome 中运行 CI 测试而配置 CLIkarma.conf.jsbrowsers: [&#39;ChromeHeadlessCI&#39;],customLaunchers: &#123;  ChromeHeadlessCI: &#123;    base: &#39;ChromeHeadless&#39;,    flags: [&#39;--no-sandbox&#39;]  &#125;&#125;,e2e/protractor.conf.jsconst config &#x3D; require(&#39;.&#x2F;protractor.conf&#39;).config;config.capabilities &#x3D; &#123;  browserName: &#39;chrome&#39;,  chromeOptions: &#123;    args: [&#39;--headless&#39;, &#39;--no-sandbox&#39;]  &#125;&#125;;exports.config &#x3D; config;\ncode coverageng test --code-coverage\n或-cc输出代码覆盖率报告，其他参数见Angular Docs\n\nIssues:Uncaught NetworkError: Failed to execute ‘send’ on ‘XMLHttpRequest’: Failed to load ‘ng:///XXXComponent/%C9%B5fac.js’.\n\n使用—source-map=false避免test fail见StackOverflow:Angular tests failing with Failed to execute ‘send’ on ‘XMLHttpRequest’\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular自定义控件","url":"/qqsnote/2019/03/27/AngularCustomizeControl/","content":"ControlValueAccessor接口\n定义一个接口，该接口充当 Angular 表单 API 和 DOM 中的原生元素之间的桥梁。 实现此接口以创建与 Angular 表单集成的自定义表单控件指令, from Angular Doc\n\n删除线小注：见下文“关于原生控件”&#x2F;&#x2F; angular2&#x2F;packages&#x2F;forms&#x2F;src&#x2F;directives&#x2F;control_value_accessor.ts export interface ControlValueAccessor &#123;  writeValue(obj: any): void;  registerOnChange(fn: any): void;  registerOnTouched(fn: any): void;  setDisabledState?(isDisabled: boolean): void;&#125;\n\nwriteValue(obj: any)：该方法用于将宿主传入的新值写入自定义组件的视图或 DOM 属性。\nregisterOnChange(fn: any)：设置当控件接收到来自宿主的 change 事件后，调用的函数 一般将其对接到input控件的ngOnChange响应事件上\nregisterOnTouched(fn: any)：设置当控件接收到 touched 事件后，调用的函数\nsetDisabledState?(isDisabled: boolean)：当控件状态变成 DISABLED 或从 DISABLED 状态变化成 ENABLE 状态时，会调用该函数。该函数会根据参数值，启用或禁用指定的 DOM 元素。\n\n自定义的组件实现ControlValueAccessor接口，可以像原生表单控件一样使用ngModel绑定值stackbliz demoimport &#123;Component, OnInit, forwardRef, Input&#125; from &#39;@angular&#x2F;core&#39;;import &#123;ControlValueAccessor, FormControl, NG_VALUE_ACCESSOR&#125; from &#39;@angular&#x2F;forms&#39;;@Component(&#123;  selector: &#39;app-custom-input&#39;,  templateUrl: &#39;.&#x2F;custom-input.component.html&#39;,  styleUrls: [&#39;.&#x2F;custom-input.component.scss&#39;],  providers: [    &#123;      provide: NG_VALUE_ACCESSOR,      useExisting: forwardRef(() &#x3D;&gt; CustomInputComponent),      multi: true    &#125;  ]&#125;)export class CustomInputComponent implements ControlValueAccessor &#123;  onChange: any &#x3D; () &#x3D;&gt; &#123;&#125;  onTouch: any &#x3D; () &#x3D;&gt; &#123;&#125;  registerOnChange(fn: any): void &#123;    this.onChange &#x3D; fn;  &#125;  registerOnTouched(fn: any): void &#123;    this.onTouch &#x3D; fn;  &#125;  input: string;  writeValue(input: string) &#123;    this.input &#x3D; input;  &#125;&#125;关于原生控件不直接操作自定义组件 而在组件内逻辑赋值绑定值input 控件会响应 但是自定义组件的ngOnChange不会响应 即父组件绑定ngModel的值并不更新， 即逻辑赋值input还需要手动调用registerOnChange注入的外部响应事件，也就是上述范例代码的onChange变量\n参考ng-zorro的select控件源码发现 在实现ControlValueAccessor的自定义组件模板中原生组件是不必要的，自定义组件可以自行管理对外暴露的ngModel的值，没有必要响应原生组件的特性\nOnChange接口\nA lifecycle hook that is called when any data-bound property of a directive changes. Define an ngOnChanges() method to handle the changes.当指令的任何一个可绑定属性发生变化时调用。 定义一个 ngOnChanges() 方法来处理这些变更。\n\n实际上是自定义组件继承OnChange接口，实现ngOnChange方法，当自定义组件@Input的变量更新时，该方法响应，传入SimpleChanges类型参数，该参数是发生更新的变量的哈希表, 即@Component(&#123;selector: &#39;my-cmp&#39;, template: &#96;...&#96;&#125;)class MyComponent implements OnChanges &#123;  &#x2F;&#x2F; TODO(issue&#x2F;24571): remove &#39;!&#39;.  @Input() prop!: number;  @Input() data:any  ngOnChanges(changes: SimpleChanges) &#123;    const &#123;prop, data&#125; &#x3D; changes    &#x2F;&#x2F; prop and data is an SimpleChange boject which contains the old and the new value...  &#125;&#125;SimpleChanges是SimpleChange类型的mapexport declare class SimpleChange &#123;    previousValue: any;    currentValue: any;    firstChange: boolean;    constructor(previousValue: any, currentValue: any, firstChange: boolean);    &#x2F;**     * Check whether the new value is the first value assigned.     *&#x2F;    isFirstChange(): boolean;&#125;Caution! ngOnChange的底层逻辑是使用‘===’判断前后值的，因此引用类型的属性变化不会触发ngOnChange，workaround是将此类输入属性拆成基本值类型变量，或者在宿主更新该输入属性时赋予新的引用地址，亦或使用ngDoCheck\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular组件交互","url":"/qqsnote/2019/03/27/AngularComponentCommunicate/","content":"&lt;app-voter *ngFor&#x3D;&quot;let voter of voters&quot;      [name]&#x3D;&quot;voter&quot;      (voted)&#x3D;&quot;onVoted($event)&quot;&gt;&lt;&#x2F;app-voter&gt;\n@Input()\n@Input()可以带set、get属性\n\nimport &#123; Component, Input &#125; from &#39;@angular&#x2F;core&#39;;@Component(&#123;  selector: &#39;app-voter&#39;,  template: &#39;&lt;h3&gt;&quot;&#123;&#123;name&#125;&#125;&quot;&lt;&#x2F;h3&gt;&#39;&#125;)export class VoterComponent &#123;  private _name &#x3D; &#39;&#39;;  @Input()  set name(name: string) &#123;    this._name &#x3D; (name &amp;&amp; name.trim()) || &#39;&lt;no name set&gt;&#39;;  &#125;  get name(): string &#123; return this._name; &#125;&#125;\n在set、get时进行格式化等操作。\n\nngOnChanges()生命周期钩子是专门用来监听@Input入参的，非传入参数不会触发ngOnChanges()方法\n\n@Output()子组件发射事件@Output() voted &#x3D; new EventEmitter&lt;boolean&gt;();vote(agreed: boolean) &#123;    this.voted.emit(agreed);&#125;\n模板标记子组件&lt;h3&gt;Countdown to Liftoff (via local variable)&lt;&#x2F;h3&gt;&lt;button (click)&#x3D;&quot;timer.start()&quot;&gt;Start&lt;&#x2F;button&gt;&lt;button (click)&#x3D;&quot;timer.stop()&quot;&gt;Stop&lt;&#x2F;button&gt;&lt;div class&#x3D;&quot;seconds&quot;&gt;&#123;&#123;timer.seconds&#125;&#125;&lt;&#x2F;div&gt;&lt;app-countdown-timer #timer&gt;&lt;&#x2F;app-countdown-timer&gt;\ntimer 作为父组件的变量，标记在子组件标签中，用以代表子组件，即可使父组件获取子组件的引用，进而可以调用子组件公用方法该方法有局限性在于，父组件-子组件的连接必须全部在父组件的模板中进行。父组件本身的代码对子组件没有访问权。\n@ViewChild()@ViewChild(CountdownTimerComponent)private timerComponent: CountdownTimerComponent;\n使用@ViewChild()装饰器将CountdownTimerComponent实例注入到本组件，记为私有变量timerComponent\n\n特别注意被注入的组件只有在 Angular 显示了父组件视图之后才能访问下面的语法很关键\nngAfterViewInit() &#123;    &#x2F;&#x2F; wait a tick first to avoid one-time devMode    &#x2F;&#x2F; unidirectional-data-flow-violation error    setTimeout(() &#x3D;&gt;  this.timerComponent.init(), 0);  &#125;\n父组件要及时调用子组件方法进行初始化，须实现AfterViewInit生命周期钩子，且用定时器异步操作。否则报异常\nExpressionChangedAfterItHasBeenCheckedError\n引入第三者通信这类方法包括注入服务，借助相同父组件以及借助发布订阅可观察对象等，此处略。\n\n\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular Ivy","url":"/qqsnote/2020/02/18/AngularIvy/","content":"\nAngular 9 is available, new release switches applications to the Ivy compiler and runtime by default (Feb, 2020)\n\n模板编译\n「模版编译」的工作一般是将使用「声明式语言」描述的「模版」转化为「命令式语言」定义的逻辑代码。鉴于这里的主体是 JavaScript，可以理解为「文本」-&gt;「函数」的转换。\n\nAngular 模板编译演变v2 版本中，Angular 采用了和 Svelte 几乎相同的「编译到指令操作」策略，主要区别是对「视图操作」使用的是基于 Renderer 的抽象指令。这种编译方式确实带来了卓越的性能，但由此带来的明显不便之一是生成代码的大小，在 Trotyl Yu：如何评价 angular 2 中的 AoT？中有给出「模版编译」产物的示例，由于太过占用屏幕空间，不在此处贴出。\nv4 版本中，Angular 引入了 View Engine 的概念，建立了公共的运行时部分以减少「编译产物」的大小，而「视图定义」部分也不再使用「编译到指令函数」的策略，而是「编译到工厂函数，类似于（详细代码可以参见 【MMR-A】全新的 View Engine 模式）：function View_MyComponent() &#123;  return viewDef([    elementDef(1, &#39;div&#39;, [[&#39;id&#39;, &#39;foo&#39;]]),    elementDef(1, &#39;p&#39;, []),    textDef([&#39;Hello &#39;]),  ], (check, view) &#x3D;&gt; &#123;    var comp &#x3D; view.component;    const currVal_0 &#x3D; inlineInterpolate(&#39;Hello, &#39;, comp.name);    check(view, currVal_0);  &#125;);&#125;\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular 响应式表单","url":"/qqsnote/2020/01/19/AngularReactiveForm/","content":"注册响应式表单模块该模块定义了响应式表单涉及到的组件等类型或构造方法类定义在@angular/forms包中，会在组件中引用，那么为什么要注册模块？import &#123; ReactiveFormsModule &#125; from &#39;@angular&#x2F;forms&#39;;@NgModule(&#123;  imports: [    &#x2F;&#x2F; other imports ...    ReactiveFormsModule  ],&#125;)export class AppModule &#123; &#125;\nFormControl响应式控件类，每个实例对应页面表单中的一个控件，在template中使用formControl=”name”绑定，在FormGroup中使用formControlName=”name”绑定。edit.component.ts:name &#x3D; new FormControl(&#39;QQstone&#39;)edit.component.html&lt;input type&#x3D;&quot;text&quot; [formControl]&#x3D;&quot;name&quot;&gt;&lt;p&gt;&#123;&#123;name.value&#125;&#125;&lt;&#x2F;p&gt;\nFormGroup用于管理一组响应式控件，一个表单可以标记为一个Group，也可以分为多个Group（QQs尚为实践过）&lt;form #f&#x3D;&quot;ngForm&quot; *ngIf&#x3D;&quot;assetForm&quot; (ngSubmit)&#x3D;&quot;save()&quot; nz-form [formGroup]&#x3D;&quot;assetForm&quot;&gt;    &lt;nz-form-label nzSpan&#x3D;&quot;4&quot; nzRequired&gt;Asset Name&lt;&#x2F;nz-form-label&gt;    &lt;nz-form-control nzSpan&#x3D;&quot;8&quot;&gt;      &lt;input nz-input formControlName&#x3D;&quot;asset_name&quot; name&#x3D;&quot;name&quot; maxlength&#x3D;&quot;30&quot; placeholder&#x3D;&quot;Name&quot; required &#x2F;&gt;    &lt;&#x2F;nz-form-control&gt;    &lt;nz-form-label nzSpan&#x3D;&quot;4&quot; nzRequired&gt;Status&lt;&#x2F;nz-form-label&gt;    &lt;nz-form-control nzSpan&#x3D;&quot;8&quot;&gt;      &lt;nz-select formControlName&#x3D;&quot;status&quot; name&#x3D;&quot;status&quot; nzPlaceHolder&#x3D;&quot;Status&quot;         nzAllowClear required&gt;        &lt;nz-option *ngFor&#x3D;&quot;let item of enum.asset_status&quot; [nzLabel]&#x3D;&quot;item.text&quot; [nzValue]&#x3D;&quot;item.code&quot;&gt;        &lt;&#x2F;nz-option&gt;      &lt;&#x2F;nz-select&gt;    &lt;&#x2F;nz-form-control&gt;&lt;&#x2F;form&gt;\nFormBuilder使用FormBuilder构造FormGroup,每个组件对应一个Array，Array第一个属性是控件初始value，其后是校验器，若存在多个校验器，则该属性为Array注入 private fb: FormBuilderprofileForm &#x3D; this.fb.group(&#123;    name:[&#39;&#39;, Validators.required],    status:[&#39;30&#39;]&#125;)\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular Library","url":"/qqsnote/2019/11/11/AngularLibrary/","content":"添加库add libraryng new my-project --style lesscd my-projectng add ng-alain\nadd library 和 npm install\nng add \\ uses your package manager and installs the dependency. That dependency can have an installation script which can be used to do more job except the dependency installation. It can update your configurations, download another dependencies based on that one or create scaffold templates (with initial markup and logic).\n\n安装ng-alain库修改了angular.json文件，加入了上文提到的installation script。项目中可以调用ng-alain库命令创建页面模板ng g ng-alain:module userng g ng-alain:list list -m&#x3D;user根据ng-alain规则生成user模块，并为其添加一个list功能(自动生成组件，配置路由等)\n\nCaution! “download another dependencies” 并不会加入到 package.json(存疑))\n\n创建库","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular路由","url":"/qqsnote/2018/08/17/AngularRoute/","content":"Angular Doc: 路由在AppComponent初始化登录服务，其中有request发送到后台，报401，有HttpInterceptor拦截401，且有RoutGuard校验登录成功后的数据，该场景下HttpInterceptor先生效，因token失效而做重定向，然后RoutGuard生效，二者依据有所区别，固行为有所冲突。现workaround是避免在初始化Angular App或初始化登录模块时调用有可能被HttpInterceptor拦截的接口\n查询列表与详情页的路由跳转从指定查询条件的列表，路由到详情页，以及从详情页返回原查询结果页list componentthis.router.navigate([&#96;&#x2F;asset&#x2F;list&#x2F;detail&#x2F;$&#123;dataItem.asset_id&#125;&#96;], &#123;queryParams: this.s&#125;)detail componentqueryParam:any&#x2F;&#x2F; initthis.route.paramMap.subscribe(params &#x3D;&gt; &#123;    const id &#x3D; +params.get(&#39;id&#39;);    this.getAsssetById(id);&#125;);this.route.queryParamMap.subscribe(queryParam&#x3D;&gt;this.queryParams&#x3D;queryParam)&#x2F;&#x2F; returnthis.router.navigate([&#39;..&#x2F;&#39;], &#123;queryParams: this.queryParams&#125;);\nHash:false去掉url的＃\nuseHash:false的情况下navigateByUrl完整的url出现404，相对路由路径正常 \napache配置a2enmod rewrite\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Angular 服务端渲染","url":"/qqsnote/2020/04/26/AngularSSR/","content":"服务端渲染（Server Side Render, SSR）\n\n通过搜索引擎优化(SEO)来帮助网络爬虫。\n  根据之前写简单爬虫的经历，以模仿使用者浏览静态页面并匹配目标内容为原理的爬虫，难以识别模块化的angular页面资源，SSR方式可以让每个 URL 返回的都是一个完全渲染好的页面。\n\n迅速显示出第一个支持首次内容绘制(FCP)的页面\n  据说如果页面加载超过了三秒钟，那么 53% 的移动网站会被放弃  着陆页（landing pages），看起来就和完整的应用一样。 这些着陆页是纯 HTML，并且即使 JavaScript 被禁用了也能显示。 这些页面不会处理浏览器事件，不过它们可以用 routerLink 在这个网站中导航。\n\n提升在手机和低功耗设备上的性能\n  在执行JavaScript存在困难的设备上，可以显示出静态页面，而不是直接crush。。。大概是有机会说“抱歉，blabla”\n\n\n@nguniversal/express-engine 模板npm add @nguniversal&#x2F;express-engine --clientProject QQsNgApp\n于是原angular项目变为anguar应用与express server混合项目新增.&#x2F;server.ts.&#x2F;tsconfig.server.json.&#x2F;webpack.server.config.js.&#x2F;src&#x2F;main.server.ts.&#x2F;src&#x2F;app&#x2F;app.server.module.ts篡改angular.json:+ products.QQsNgApp.architect.serve&#x3D;&#123;...&#125;main.ts:document.addEventListener(&#39;DOMContentLoaded&#39;, () &#x3D;&gt; &#123;    bootstrap();&#125;);package.json:scripts: + &quot;compile:server&quot;: &quot;webpack --config webpack.server.config.js --progress --colors&quot;,+ &quot;serve:ssr&quot;: &quot;node dist&#x2F;server&quot;,+ &quot;build:ssr&quot;: &quot;npm run build:client-and-server-bundles &amp;&amp; npm run compile:server&quot;,+ &quot;build:client-and-server-bundles&quot;: &quot;ng build --prod &amp;&amp; ng run csd-ams-front:server:production --bundleDependencies all&quot;...服务端渲染无法调用windows对象，继而document, localstorage等对象会报undefined\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Authentication Packages","url":"/qqsnote/2020/11/04/AuthenticationPackages/","content":"oidc-client见oidc-client\nPassport.jsPassport.js是Express.js的中间件，Azure Samples中的node.js API active-directory-b2c-javascript-nodejs-webapi使用了这个包const passport &#x3D; require(&quot;passport&quot;);const BearerStrategy &#x3D; require(&#39;passport-azure-ad&#39;).BearerStrategy;const bearerStrategy &#x3D; new BearerStrategy(config,    function (token, done) &#123;        &#x2F;&#x2F; Send user info using the second argument        done(null, &#123;&#125;, token);    &#125;);const app &#x3D; express();app.use(passport.initialize());passport.use(bearerStrategy);&#x2F;&#x2F; API endpointapp.get(&quot;&#x2F;hello&quot;,    passport.authenticate(&#39;oauth-bearer&#39;, &#123;session: false&#125;),    (req, res) &#x3D;&gt; &#123;        console.log(&#39;User info: &#39;, req.user);        console.log(&#39;Validated claims: &#39;, req.authInfo);                if (&#39;scp&#39; in req.authInfo &amp;&amp; req.authInfo[&#39;scp&#39;].split(&quot; &quot;).indexOf(&quot;demo.read&quot;) &gt;&#x3D; 0) &#123;            &#x2F;&#x2F; Service relies on the name claim.              res.status(200).json(&#123;&#39;name&#39;: req.authInfo[&#39;name&#39;]&#125;);        &#125; else &#123;            console.log(&quot;Invalid Scope, 403&quot;);            res.status(403).json(&#123;&#39;error&#39;: &#39;insufficient_scope&#39;&#125;);         &#125;    &#125;);栗子中该中间件将认证失败的请求拦截住并返回401， 省略了web api授权失败时的重定向配置，私以为可以配置signin重定向，使得可以从浏览器访问api\nMSAL.netMicrosoft Authentication Library(微软身份认证库MSAL)，在ASP和SPA一文中有引用。\n\nThe Microsoft Authentication Library for JavaScript enables client-side JavaScript web applications, running in a web browser, to authenticate users using Azure AD. MSAL.js用以浏览器中运行的js web 使用Azure AD认证\n\n上述是基于msal.js的JavaScript Packages, 对于客户端应用，微软提供.net framework运行时环境的一套SDK：\nMSAL for .NET, UWP, NetCore, MAUI, Xamarin Android and iOS \n\nThe MSAL library for .NET is part of the Microsoft identity platform for developers (formerly named Azure AD) v2.0. It enables you to acquire security tokens to call protected APIs. It uses industry standard OAuth2 and OpenID Connect. The library also supports Azure AD B2C.\n\n官方文档 \n\nQuickStart 获取令牌并从桌面应用程序中调用 Microsoft Graph API \n\nMSAL 中的身份验证流支持\n\n在WPF中登录并调用Microsoft Graph 👈 看这个\n\n我们关注使用WPF客户端打开登录ADB2C认证页面的应用场景MSAL.NET使用Web浏览器\n\nMSAL.NET 是一个多框架库，它具有特定于框架的代码，可在 UI 控件中托管浏览器（例如，在 .NET Classic 中，它使用 WinForms；在 .NET 5.0+ 中，它使用 WebView2；在 Xamarin 中，它使用本机移动控件，等等）。 此控件称为 embedded Web UI。 另外，MSAL.NET 还能够启动系统 OS 浏览器。\n\nInstall-Package Microsoft.Identity.Client -Pre\nusing Microsoft.Identity.Client;...IPublicClientApplication publicClientApp &#x3D; PublicClientApplicationBuilder.Create(ClientId)        .WithRedirectUri(&quot;https:&#x2F;&#x2F;login.microsoftonline.com&#x2F;common&#x2F;oauth2&#x2F;nativeclient&quot;)        .WithAuthority(AzureCloudInstance.AzurePublic, Tenant)        .Build();\n使用自定义交互界面, 调用 WithCustomWebUi() 方法 传入自定义页面的实例，自定义页面类需要实现ICustomWebUi接口，接口定义了异步方法 AcquireAuthorizationCodeAsync，该方法参数\n\nauthorizationUri UriURI computed by MSAL.NET that will let the UI extension navigate to the STS authorization endpoint in order to sign-in the user and have them consent\n\nredirectUri Uri The redirect URI that was configured. The auth code will be appended to this redirect URI and the browser will redirect to it.\n\n\nPublic Client Application 和 Confidential Client Application: Confidential Client Application用于服务端应用，不会轻易访问到，使用client_secret标识身份；Public Client Application 运行在桌面或移动设备，保存client_secret是不安全的，因此凭借用户的credentials访问API\nuse WAMWeb 帐户管理器 (Web Account Manager) windows10提供的认证账户保存组件\n\nEnhanced security. See Token protection. 关联客户端密码和token的加密\nSupport for Windows Hello(是使用 PIN、面部识别或指纹来快速访问 Windows的入口), Conditional Access, and FIDO keys(Fast IDentity Online Keys 在线密钥对).\nIntegration with the Windows Email &amp; accounts view.Fast single sign-on.\nAbility to sign in silently with the current Windows account.\nBug fixes and enhancements shipped with Windows.\n\n","tags":["auth"]},{"title":"Angular Touble Shooting","url":"/qqsnote/2019/10/15/AngularTroubleShooting/","content":"资料见知乎·Angular资料获取不完全指南\n异步响应方法中更新数据，视图无法及时更新\n解决方法：导入ChangeDetectRefimport &#123; ChangeDetectorRef &#125; from &#39;@angular&#x2F;core&#39;;constructor(    private changeDetectorRef:ChangeDetectorRef) &#123;         &#x2F;&#x2F; user token updated!        this.userService.currentUserToken$.subscribe(res&#x3D;&gt;&#123;            if(res)&#123;            this.logged &#x3D; true;            this.email &#x3D; res[&#39;UserName&#39;].value;            this.changeDetectorRef.detectChanges()            &#125;        &#125;)    &#125;&#125;\nhttpClient的任意方法(get、post)无法发送请求所在模块未引入HttpClientModule\n\n重复声明DirectiveERROR in Type NumberInputDirective in D:&#x2F;ProjectX&#x2F;src&#x2F;app&#x2F;common&#x2F;number-input.directive.ts is part of the declarations of 2 modules: blablaA and blablaB Please consider moving NumberInputDirective to a higher module that imports blablaA and blablaB. You can also create a new NgModule import that NgModule in blablaA and blablaB\n\n指令是可声明对象。 它们必须在 NgModule 中声明(declarations)之后，才能用在应用中。指令应当且只能属于一个 NgModule。不要重新声明那些从其它模块中导入的指令。\n\nimport &#123; NgModule &#125; from &#39;@angular&#x2F;core&#39;;import &#123; CommonModule &#125; from &#39;@angular&#x2F;common&#39;;import &#123; NumberInputDirective &#125; from &#39;..&#x2F;common&#x2F;number-input.directive&#39;;@NgModule(&#123;    imports: [CommonModule],    declarations: [NumberInputDirective],    exports:[NumberInputDirective]export class SharedModule &#123;&#125;\nangular.json “should NOT have additional properties(xxxx)”因框架版本问题（归根结蒂是包版本差异问题），不支持xxx属性，如angular原生国际化配置v8与v9存在配置差异，查看文档应区分文档版本\n关于升级参考Angular 升级指南\n另，@angular/cli和angular-cli 是两个东西，安装了后者可以使用部分ng命令，可知ng version是beta版本，ng update无效且报“does not match any file…”\n\nissue 升级到9后，渲染中止，报“Uncaught SyntaxError: Strict mode code may not include a with statement”\n\n见stackoverflow回答remove from main.tsexport &#123; renderModule, renderModuleFactory &#125; from &#39;@angular&#x2F;platform-server&#39;;\n\nnpm ERR! Invalid package name “ngcc_entry_points.json”: name cannot start with an underscore升级Angular过程中未知package错误 清理依赖重新安装rm -rf node_modulesrm -f package-lock.jsonnpm i\ncss: ng-deep host-context曾使用ng-inline-svg将svg模板嵌入angular模板(见svg)，插入方式使用的是其定义的指令&lt;div [inlineSVG]&#x3D;&quot;&#39;assets&#x2F;image&#x2F;icon.svg&#39;&quot;&gt;&lt;&#x2F;div&gt;目的是使用类似.nav-checked svg&gt;path&#123;    fill:red&#125;的方式实现动态图标样式事实上，ng-inline-svg指令将宿主元素（div）作为组件锚点，用svg模板实例化为一个独立组件，宿主元素所在组件的样式无法作用到子组件Angular官方文档中对于样式‘透传’有如下solution:host ::ng-deep .nav-checked svg&gt;path&#123;    fill:red&#125;:host表示从本组件开始::ng-deep向下生效见Doc：组件样式\n\n参考ng-inline-svg issue#14\n关于deprecated，是deep与w3c的草案曾用关键字冲突，然而其一Angular尚无替代方案，其二w3c已移除了相关建议，若将来协议落地，Angular亦无须重复实现这个feature(引述：StackOverflow：What to use in place of ::ng-deep)\n:host-context可以根据组件外部元素来决定组件内的样式&lt;nav class&#x3D;&quot;collapse&quot;&gt;&lt;nav-header&gt;&lt;&#x2F;nav-header&gt;&lt;nav&gt;在NavHeader.component.less:host-context(.collapse) .title&#123;    ...&#125;\nCan’t bind to ‘ngForOf’ since it isn’t a known property of XXX疑似升级至ng11后出现，多个modules，任意组件使用指令均可能报错，解决方法是在所在子模块手动引入CommonModule...import &#123; CommonModule &#125; from &#39;@angular&#x2F;common&#39;;@NgModule(&#123;    imports: [SharedModule, CommonModule],    declarations: [...],    providers: [],&#125;)export class ManageModule &#123; &#125;\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Azure-ADB2C","url":"/qqsnote/2020/07/01/Azure-AD/","content":"Azure ADWindows2000 引入Active Directory作为identity provider和authorization database，可想而知，这个名称与其存储方式以及根据talent区分的文件结构之间的关系。随着Web应用的发展，有了云平台的Azure Active Directory，其主要功能之一仍是作为identity provider。\nAD和Azure AD的结合实现了以本地Windows身份通过web实现SSO认证。\n参考：《Is Azure AD an Identity Provider?》\nAzure AD在office软件甚至其他Saas（Software as a service, 软件即服务）之间无缝访问，以及多重身份验证和条件访问控制\n参考：使用 Azure Active Directory 进行应用程序管理\nAzure AD, B2B, B2C Puzzled Out – What Makes The Difference?\nB2B，对接Business和Business，使双方标识均可通过认证，主服务方持有访问权限的控制，B2C, 面向customer 如下引述：\n\nAzure Active Directory B2C provides business-to-customer identity as a service. Your customers use their preferred social, enterprise, or local account identities to get single sign-on access to your applications and APIs.\n\nAzure Active Directory B2C 以服务的形式提供企业到客户的身份。 客户可使用其喜欢的社交、企业或本地帐户标识完成单点登录，访问应用程序和 API 。\n“贴牌式身份验证解决方案” blabla\n届时，访问DataService，跳转到如 CSDataServices.onmicrosoft.com/oauth2/v2.0/authorize?xxxx 格式的地址, 这是挂在Azure上的页面，可以做成本公司产品风格(见本文章节自定义登录页)，sign in的form可以直接使用已注册（保存在Azure AD）的账号, 也可能提供了社交账号的链接，点击后跳转到社交平台登录页。\nAzure保存用户的标识，即使使用第三方的sso如公司的sso认证或社交账号，也会有将第三方凭据交换Azure标识的过程，该过程即典型的OAuth2\n\n名称和概念\n\nauthority 颁发机构 形如 https://login.microsoftonline.com/tfp/{tenant}/{policyName}\ntenantID 注册使用AAD 成为“tenant” 获得tenantID 由tenant name命名的子域名等\ndirectory 存储所涉及的对象（如凭据，用户信息，配置）的物理或逻辑位置 \nApplication registration 将自己公司产品注册为Azure AD B2C的App,以使用由Azure提供的贴牌认证\nuser flow 和 costom policy分别指基本的注册-登录-配置的流程以及自定义的策略\nidentity providers 第三方的标识提供方 如Facebook账号或Wechat账号授权服务 \n\nAzure ADB2CActive Directory 的identity是在login.microsoftonline.com注册的，登录Azure portal也是同样的唯一的账号，B2C则提供了选择多个identity provider的功能，可以使用自己注册的tenant，抑或是社交账号，注册登录入口形如https://qqstudio.b2clogin.com/qqstudio.onmicrosoft.com/oauth2/v2.0/authorize下面以官方sample为例配置，以求使用wpf桌面客户端通过Azure AD B2C的认证框架访问Web Api\n域服务(AD DS)和应用程序管理即除了B2C之外的主要功能。AD DS见Azure域服务AD可以用于管理Gallery App也就是微软库中的SaaS应用，也可以通过应用程序代理管理本地的应用(On-premises applications)What does Azure AD Application Proxy do?A.You use it to identify applications in your instance of Azure AD.B.You use it to add on-premises applications to your instance of Azure AD.C.You use it to add Azure AD Gallery applications to your instance of Azure AD.\n创建资源进入“创建资源”入口，搜索Azure AD B2C，选择创建—&gt;给出两个选项,选择创建新的loading半天后提示创建成功，点击链接切换directory\nDirectory creation was successful. Click here to navigate to your new directory: QQStudio.\n\nuser flow选择由Azure AD B2C控制的行为，一般就是登入登出，注册、注销，重置密码。选择Sign up and sign in输入user flow名称选择email作为sign up的身份验证选择需要收集的注册信息\n关于reset password\n\n使用本地帐户的 注册或登录 用户流在体验的第一个页面上包含“忘记了密码?”链接。 单击此链接不会自动触发密码重置用户流。而是将错误代码 AADB2C90118 返回给应用程序。 应用程序需要通过运行一个可重置密码的特定用户流来处理此错误代码。 Microsoft Docs：user flow 概述\n注册Api应用程序将访问受控的应用(这里是Web Api)注册到Azure AD B2C，框架给予应用程序client id等标记，记下当登录成功时跳转回的地址————Redirect URI(关于Redirect URI的限制见本文Q&amp;A部分)。Display name:Demo websiteApplication (client) ID:c4b27029-a5ad-4022-979d-8721101df951Directory (tenant) ID:9175ffa9-24b3-4fc1-806e-6d53582a7f4fObject ID:c5064a61-0321-4a39-9f3c-dcef0df9b99cSupported account types:All Microsoft  usersRedirect URIs:1 web, 0 spa, 0 public clientApplication ID URI:Add an Application ID URIManaged application in local directory:Demo website这里的Redireact URI是http://localhost:8888/auth，期望在本机运行桌面客户端程序，访问Api跳转到Azure Page登录，成功后进入到该地址。进入管理—认证(Authentication),选择使用隐式授权流(Implicit grant, 见笔记OAuth2), 并添加Redirect Uri进入管理—公开API(expose API),Application ID URI set 为https://qqstudio.onmicrosoft.com/api 默认是由GUID组成的添加scope(Add a scope)scope是控制访问权限的定义，将在后续步骤中被授权到已注册的client\n\n配置Web Api应用的Authorization使Web Api能将token拿到Azure AD B2C去校验，官方Sample中从config.js读取配置const config &#x3D; &#123;    identityMetadata: &quot;https:&#x2F;&#x2F;&quot; + b2cDomainHost + &quot;&#x2F;&quot; + tenantId + &quot;&#x2F;&quot; + policyName + &quot;&#x2F;v2.0&#x2F;.well-known&#x2F;openid-configuration&#x2F;&quot;,    clientID: clientID,    policyName: policyName,    isB2C: true,    validateIssuer: false,    loggingLevel: &#39;info&#39;,    loggingNoPII: false,    passReqToCallback: false&#125;express web api的认证和重定向用到了passport和passport-azure-ad两个包，后者直接带入上面的config对象做为参数const express &#x3D; require(&quot;express&quot;);const morgan &#x3D; require(&quot;morgan&quot;);const passport &#x3D; require(&quot;passport&quot;);const config &#x3D; require(&#39;.&#x2F;config&#39;);const BearerStrategy &#x3D; require(&#39;passport-azure-ad&#39;).BearerStrategy;const bearerStrategy &#x3D; new BearerStrategy(config,    function (token, done) &#123;        &#x2F;&#x2F; Send user info using the second argument        done(null, &#123;&#125;, token);    &#125;);const app &#x3D; express();app.use(morgan(&#39;dev&#39;));app.use(passport.initialize());passport.use(bearerStrategy);&#x2F;&#x2F;enable CORSapp.use((req, res, next) &#x3D;&gt; &#123;    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Authorization, Origin, X-Requested-With, Content-Type, Accept&quot;);    next();&#125;);&#x2F;&#x2F; API endpointapp.get(&quot;&#x2F;hello&quot;,    passport.authenticate(&#39;oauth-bearer&#39;, &#123;session: false&#125;),    (req, res) &#x3D;&gt; &#123;        console.log(&#39;User info: &#39;, req.user);        console.log(&#39;Validated claims: &#39;, req.authInfo);                if (&#39;scp&#39; in req.authInfo &amp;&amp; req.authInfo[&#39;scp&#39;].split(&quot; &quot;).indexOf(&quot;demo.read&quot;) &gt;&#x3D; 0) &#123;            &#x2F;&#x2F; Service relies on the name claim.              res.status(200).json(&#123;&#39;name&#39;: req.authInfo[&#39;name&#39;]&#125;);        &#125; else &#123;            console.log(&quot;Invalid Scope, 403&quot;);            res.status(403).json(&#123;&#39;error&#39;: &#39;insufficient_scope&#39;&#125;);         &#125;    &#125;);const port &#x3D; process.env.PORT || 5000;app.listen(port, () &#x3D;&gt; &#123;    console.log(&quot;Listening on port &quot; + port);&#125;);\n注册客户端程序将官网sample的wpf client注册到Azure AD B2C创建完成后添加Api权限，或者说授权scope：管理—API权限(API Permission)—Add a permission—My APIs,选择已注册的Web API应用勾选Permissions，即上文中的scopes授权client使用scope：管理—API权限(API Permission)—Grant admin consent for xxxx(telent Name)—click YesQQs跟随sample的步骤遗漏了下面这一步————添加重定向地址————导致在配置客户端时Redirect Uri不知道填什么管理—Authentication—Add a platform—Mobile and desktop applications 然后可以看到根据当前talent的user flow生成的登录页模板 勾选https://qqstudio.b2clogin.com/oauth2/nativeclient\n配置客户端以访问已授权的Apisample client是个WPF应用，引入了Microsoft.Identity.Client这个包来进行token校验&#x2F;&#x2F; Copyright (c) Microsoft Corporation. All rights reserved.&#x2F;&#x2F; Licensed under the MIT License.using System.IO;using System.Text;using System.Windows;using Microsoft.Identity.Client;namespace active_directory_b2c_wpf&#123;    public partial class App : Application    &#123;        private static readonly string Tenant &#x3D; &quot;61874450-1725-44bb-bb8e-314575861ad6&quot;;        private static readonly string AzureAdB2CHostname &#x3D; &quot;https:&#x2F;&#x2F;qqstudio.b2clogin.com&#x2F;oauth2&#x2F;nativeclient&quot;;        private static readonly string ClientId &#x3D; &quot;8e039329-171a-4484-8151-4e67bf561218&quot;; &#x2F;&#x2F; 这里的clientId是WPF Client自己的ID        private static readonly string RedirectUri &#x3D; &quot;https:&#x2F;&#x2F;fabrikamb2c.b2clogin.com&#x2F;oauth2&#x2F;nativeclient&quot;; &#x2F;&#x2F; 这个是Azure给桌面客户端的登录页        public static string PolicySignUpSignIn &#x3D; &quot;B2C_1_basic_sign_up_and_sign_in&quot;;        public static string[] ApiScopes &#x3D; &#123; &quot;https:&#x2F;&#x2F;qqstudio.onmicrosoft.com&#x2F;api&#x2F;demo.read&quot;, &quot;https:&#x2F;&#x2F;qqstudio.onmicrosoft.com&#x2F;api&#x2F;demo.write&quot; &#125;;        public static string ApiEndpoint &#x3D; &quot;https:&#x2F;&#x2F;fabrikamb2chello.azurewebsites.net&#x2F;hello&quot;;        private static string AuthorityBase &#x3D; $&quot;https:&#x2F;&#x2F;&#123;AzureAdB2CHostname&#125;&#x2F;tfp&#x2F;&#123;Tenant&#125;&#x2F;&quot;;        public static string AuthoritySignUpSignIn &#x3D; $&quot;&#123;AuthorityBase&#125;&#123;PolicySignUpSignIn&#125;&quot;;        public static IPublicClientApplication PublicClientApp &#123; get; private set; &#125;        static App()        &#123;            PublicClientApp &#x3D; PublicClientApplicationBuilder.Create(ClientId)            .WithB2CAuthority(AuthoritySignUpSignIn)            .WithRedirectUri(RedirectUri)            .WithLogging(Log, LogLevel.Info, false) &#x2F;&#x2F; don&#39;t log PII details on a regular basis            .Build();            TokenCacheHelper.Bind(PublicClientApp.UserTokenCache);        &#125;        private static void Log(LogLevel level, string message, bool containsPii)        &#123;            string logs &#x3D; ($&quot;&#123;level&#125; &#123;message&#125;&quot;);            StringBuilder sb &#x3D; new StringBuilder();            sb.Append(logs);            File.AppendAllText(System.Reflection.Assembly.GetExecutingAssembly().Location + &quot;.msalLogs.txt&quot;, sb.ToString());            sb.Clear();        &#125;    &#125;&#125;\nscopes通过scopes管理对受保护资源的权限，请求令牌时，客户端传递scope\n关于校验和跳转的包的实现的推测\n客户端访问api，Http/Https Request\n客户端Request使用Jwt Bearer Authentication 传递token\n服务端接收到的request中token缺少或过期，返回401\n客户端收到401打开Azure Sign in Page，附带重定向回api end point 的url\nAzure AD 框架进行认证\nAzure AD 框架查询并授权 颁发相应的token\n客户端接收到token并缓存自定义策略用户流使用ADB2C认证授权流可选择预置的User flow（见上文）或自定义策略\n\nMicrosoft Docs：为 Identity Experience Framework 应用程序添加签名和加密密钥\nA Walkthrough For Azure AD B2C Custom Policy (Identity Experience Framework)\n下载新手配置包（starterpack）\n移动客户端AndroidRedierct Uri形如 msauth://{PACKAGE_NAME}/{BASE64_URL_ENCODED_PACKAGE_SIGNATURE}将React Native应用注册为ADB2C的客户端：Azure Portal -&gt; ADB2C -&gt; App registration -&gt; Authentication -&gt; Platform configurations -&gt; Add a platform -&gt; Android\n\nPACKAGE_NAME /android/app/src/main/java/com/exampleapp/MainApplication.kt 从路径以及java源码的顶层包名可知，此处为 com.exampleapp\nSIGNATURE 生成签名↓keytool -exportcert -alias androiddebugkey -keystore %HOMEPATH%\\.android\\debug.keystore | openssl sha1 -binary | openssl base64\n移动客户端iosRedirect Urix形如msauth.{BUNDLE_ID}://auth同上Add a platform for iOS/macOS并填入BUNDLE_ID事实上BUNDLE_ID也是如com.exampleapp的字符串\n\n使用Azure AD 作为identity provider（存目）以实现一键(使用AD凭据)登录\n对接wechat 作为identity provider（存目）在user flow - identity provider中勾选社交账号 wechat\n关于系统角色定义多个系统使用Azure AD B2C，各个系统地权限角色是否要在Azure方维护呢？是否是在expose API时定义scope呢？私以为并不是，鉴于OAuth一篇中所述，资源服务器保留私钥对access token进行校验，甚至可以从中解析出当前用户key，过期时间等信息，籍此完全可以查询本系统定义地权限角色，而无须频繁访问SSO。\nQ&amp;A\nissue: The application associated with client id has no registered redirect URIs.\n\n按说在App Registry中配置 Redirect URI是optional的，曾遇到此问题是没有勾选隐式授权（Authentication—&gt;Implicit grant）\n\n一定需要注册Redirect URI吗，可以在跳转到登录页时作为query parameter传递吗？\n\n一定要注册, 似乎是出于复杂的安全性的考虑 见StackOverflow:Why is Redirect URL Fully Qualified in Azure AD B2C?\n跳转到登录页时确实会传递Redirect_URI参数，否则会报redirect_uri_mismatch的Error且不会传回access tokenRedirect Uri 的限制要求作为跳转参数的Redirect_URI，与注册在ADB2C上的若干Redirect URIs之一完全匹配，除了localhost(匹配时自动忽略端口)。官方文档还提到了state参数，跳转参数state将在登录成功后链在Redirect URI后面，可以用来恢复跳转登录前的浏览状态\n\nSilent Sign In Workflow\n\n自定义登录页参考Microsoft Docs: ADB2C UX自定义可设置蓝色 灰色 经典风格的sign in页面 以及公司logo设置表单项目及排序等\nWechat首先是在微信公众平台注册网站应用,注册过程需要填写企业/个人网站的官网和备案号，很头疼\n添加Wechat为AB B2C的identity provider：Azure AD B2C —&gt; Identity providers —&gt; WeChat(Preview) 可以看到Callback URL(填到微信公众平台上注册的网站应用的授权回调域配置中)，Name可以填WeChat，填写网站应用的id/secret\n添加identity provider到User flow：Azure AD B2C —&gt; User flows —&gt; [Your User flow] —&gt; Identity providers 选择已添加到AD B2C的 social identity provider\n多个资源\nissue: MSAL AADB2C90146 ‘Openid profile’ provided in request specifies more than one resource for an access token, which is not supported’\n\nstackoverflow: use requestsilent\nTips\nVisual Studio Code 的 Azure AD B2C 扩展\nApplication Insights-logs\n\n","categories":["云平台"],"tags":["Azure"]},{"title":"Azure-ADB2C-JWT-Validation","url":"/qqsnote/2020/10/27/Azure-ADB2C-JWT-Validation/","content":"见 Azure官方文档token overview\n如JWT所述，JWT包含三个部分，一个标头，一个正文和一个签名。签名段可用于验证令牌的真实性，以便您的应用程序可以信任它。Azure AD B2C通过使用行业标准的非对称加密算法（例如RSA 256）对令牌进行签名。header包含有关用于对令牌进行签名的密钥和加密方法的信息：&#123;        &quot;typ&quot;: &quot;JWT&quot;,        &quot;alg&quot;: &quot;RS256&quot;,        &quot;kid&quot;: &quot;GvnPApfWMdLRi8PDmisFn7bprKg&quot;&#125;Azure AD B2C具有一个OpenID Connect元数据EndPoint。大概长这样子:https:&#x2F;&#x2F;qqstudio.b2clogin.com&#x2F;qqstudio.onmicrosoft.com&#x2F;B2C_1_basic_sign_up_and_sign_in&#x2F;v2.0&#x2F;.well-known&#x2F;openid-configuration通过此EndPoint，可以get到有关Azure AD B2C的信息。此信息包括端点，令牌内容和令牌签名密钥。其中jwks_uri提供用于签署令牌的一组公共密钥的位置。https:&#x2F;&#x2F;qqstudio.b2clogin.com&#x2F;qqstudio.onmicrosoft.com&#x2F;b2c_1_basic_sign_up_and_sign_in&#x2F;discovery&#x2F;v2.0&#x2F;keysjwks_uri如上格式，建议通过get元数据文档并解析以动态获取jwks_uri，而不要写死。\nStackOverflow 上有个现成的var configurationManager &#x3D; new ConfigurationManager&lt;OpenIdConnectConfiguration&gt;(                                   &quot;https:&#x2F;&#x2F;testb2ctenant05.b2clogin.com&#x2F;testB2CTenant05.onmicrosoft.com&#x2F;v2.0&#x2F;.well-known&#x2F;openid-configuration?p&#x3D;B2C_1_test&quot;,                                    new OpenIdConnectConfigurationRetriever(), new HttpDocumentRetriever());            CancellationToken ct &#x3D; default(CancellationToken);            RSACryptoServiceProvider rsa &#x3D; new RSACryptoServiceProvider();            var discoveryDocument &#x3D; await configurationManager.GetConfigurationAsync(ct);            var signingKeys &#x3D; discoveryDocument.SigningKeys;            var validationParameters &#x3D; new TokenValidationParameters            &#123;                RequireExpirationTime &#x3D; true,                RequireSignedTokens &#x3D; true,                ValidateIssuer &#x3D; true,                ValidIssuer &#x3D; discoveryDocument.Issuer,                ValidateIssuerSigningKey &#x3D; true,                IssuerSigningKeys &#x3D; signingKeys,                ValidateLifetime &#x3D; true,            &#125;; var principal &#x3D; new JwtSecurityTokenHandler()            .ValidateToken(token, validationParameters, out var rawValidatedToken);Jim Xu’s Answer\n用例描述：\n\n使用非法字符串冒充access token，异常：decode fail\n使用其他来源的(比如其他talent)的token，异常：unmatch siguanture\n使用正确token 获得principal对象 \n\n回顾一下，对于非对称加密，签名用私钥产生，私钥绝对隐藏且不可被反推，公开公钥，任何人可以使用公钥验证签名。\n","categories":["云平台"],"tags":["Azure","C#"]},{"title":"Azure 域服务","url":"/qqsnote/2020/11/24/Azure-ADDS/","content":"Caution！ 这个东西非常昂贵 不要在自己的Azure上学习实践！\nAzure AD DS域名（domain name），是命名空间，域名用于在网络传输中标识资源的电子方位。\n\nAzure Active Directory 域服务 (AD DS) 提供托管域服务，如域加入（domain join）,group policy,轻量目录访问协议(lightweight directory access protocol,LDAP)等。无须在云端手动部署和管理domain controllers即可使用上述服务\n\n创建托管域Azure Portal上搜索并创建Azure AD Domain Services注意事项\n\n内置域名（Built-in domain name） 以 .onmicrosoft.com 为后缀的内置域名\n自定义域名，指定自定义域名，通常是你已拥有且可路由的域名\n前缀限制 15字符\n网络名称冲突： 托管域的 DNS 域名不能已存在于虚拟网络中。确认创建后便开始漫长的等待部署的过程后续步骤\n更新虚拟网络DNS\n“forest（林）”\n\n","categories":["云平台"],"tags":["Azure"]},{"title":"Azure-AppServices","url":"/qqsnote/2022/08/05/Azure-AppServices/","content":"App Services部署单页应用\nPublish 内容为 Code， 将构建好的architects上传到服务器wwwroot目录在App Services的通用设置（Configuration-&gt;General Settings）中设置startup commandpm2 serve &#x2F;home&#x2F;site&#x2F;wwwroot --no-daemon --spa\nTroubleshooting\nCould not detect any platform in the source directory.\n\n在App Services的应用设置（Configuration-&gt;Application Settings）中添加配置项SCM_DO_BUILD_DURING_DEPLOYMENT = false\nAPI Management\n","categories":["云平台"],"tags":["Azure"]},{"title":"Azure-AppInsights","url":"/qqsnote/2021/08/26/Azure-AppInsights/","content":"在你的应用中安装sdk向Azure Application Insight服务发送遥测数据，支持web客户端，web服务和后台服务等对应用性能影响小。非阻塞，单独线程\n\nThe instrumentation monitors your app and directs the telemetry data to an Azure Application Insights Resource using a unique GUID that we refer to as an Instrumentation Key. You can instrument not only the web service application, but also any background components, and the JavaScript in the web pages themselves. The application and its components can run anywhere - it doesn’t have to be hosted in Azure.  使用Guid作为Instrumentation Key(ikey)标识作为监视器的Azure Insights资源。 监测web服务应用或后台组件亦或页面js 这些应用或组件、命令不必托管在Azure中\n创建Azure App Insights资源Azure Portal -&gt; Application Insights -&gt; Create\n添加Javascript SDKnpm i --save @microsoft&#x2F;applicationinsights-web\n使用ikey或连接字符串创建客户端instanceimport &#123; ApplicationInsights &#125; from &#39;@microsoft&#x2F;applicationinsights-web&#39;const appInsights &#x3D; new ApplicationInsights(&#123; config: &#123;  instrumentationKey: &#39;YOUR_INSTRUMENTATION_KEY_GOES_HERE&#39; &#x2F;* 使用ikey *&#x2F;  &#x2F;* 或使用 connectionString: &#39;YOUR_CONNECTION_STRING_GOES_HERE&#39; *&#x2F;  &#x2F;* ...Other Configuration Options... *&#x2F;&#125; &#125;);appInsights.loadAppInsights();appInsights.trackPageView(); &#x2F;&#x2F; Manually call trackPageView to establish the current user&#x2F;session&#x2F;pageviewReact Pluginnpm install @microsoft&#x2F;applicationinsights-react-jsnpm install @microsoft&#x2F;applicationinsights-web创建实例&#x2F;&#x2F; AppInsights.jsimport &#123; ApplicationInsights &#125; from &#39;@microsoft&#x2F;applicationinsights-web&#39;;import &#123; ReactPlugin &#125; from &#39;@microsoft&#x2F;applicationinsights-react-js&#39;;import &#123; createBrowserHistory &#125; from &#39;history&#39;;const browserHistory &#x3D; createBrowserHistory(&#123; basename: &#39;&#39; &#125;);const reactPlugin &#x3D; new ReactPlugin();const appInsights &#x3D; new ApplicationInsights(&#123;    config: &#123;        instrumentationKey: &#39;YOUR_INSTRUMENTATION_KEY_GOES_HERE&#39;,        extensions: [reactPlugin],        extensionConfig: &#123;          [reactPlugin.identifier]: &#123; history: browserHistory &#125;        &#125;    &#125;&#125;);appInsights.loadAppInsights();export &#123; reactPlugin, appInsights &#125;;在AppComponent使用Context.Provider 使所有子组件内可使用 useContext hook调用AppInsights实例import React from &quot;react&quot;;import &#123; AppInsightsContext &#125; from &quot;@microsoft&#x2F;applicationinsights-react-js&quot;;import &#123; reactPlugin &#125; from &quot;.&#x2F;AppInsights&quot;;const App &#x3D; () &#x3D;&gt; &#123;    return (        &lt;AppInsightsContext.Provider value&#x3D;&#123;reactPlugin&#125;&gt;            &#x2F;* your application here *&#x2F;        &lt;&#x2F;AppInsightsContext.Provider&gt;    );&#125;;子组件import React from &quot;react&quot;;import &#123; useAppInsightsContext &#125; from &quot;@microsoft&#x2F;applicationinsights-react-js&quot;;const MyComponent &#x3D; () &#x3D;&gt; &#123;    const appInsights &#x3D; useAppInsightsContext();        appInsights.trackMetric(&quot;Component &#39;MyComponent&#39; is in use&quot;);    appInsights.trackEvent(&#123; name: &#39;Component Init&#39;, properties: &#123; &#39;mydata&#39; &#125; &#125;);        return (        &lt;h1&gt;My Component&lt;&#x2F;h1&gt;    );&#125;export default MyComponent;\nuseTrackMetricconst MyComponent &#x3D; () &#x3D;&gt; &#123;    const appInsights &#x3D; useAppInsightsContext();    const trackComponent &#x3D; useTrackMetric(appInsights, &quot;MyComponent&quot;);        return (        &lt;h1 onHover&#x3D;&#123;trackComponent&#125; onClick&#x3D;&#123;trackComponent&#125;&gt;My Component&lt;&#x2F;h1&gt;    );&#125;\nuseTrackEventimport React, &#123; useState, useEffect &#125; from &quot;react&quot;;import &#123; useAppInsightsContext, useTrackEvent &#125; from &quot;@microsoft&#x2F;applicationinsights-react-js&quot;;const MyComponent &#x3D; () &#x3D;&gt; &#123;    const appInsights &#x3D; useAppInsightsContext();    const [cart, setCart] &#x3D; useState([]);    const trackCheckout &#x3D; useTrackEvent(appInsights, &quot;Checkout&quot;, cart);    const trackCartUpdate &#x3D; useTrackEvent(appInsights, &quot;Cart Updated&quot;, cart);    useEffect(() &#x3D;&gt; &#123;        trackCartUpdate(&#123; cartCount: cart.length &#125;);    &#125;, [cart]);        const performCheckout &#x3D; () &#x3D;&gt; &#123;        trackCheckout();        &#x2F;&#x2F; submit data    &#125;;        return (        &lt;div&gt;            &lt;ul&gt;                &lt;li&gt;Product 1 &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCart([...cart, &quot;Product 1&quot;])&#125;&gt;Add to Cart&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;                &lt;li&gt;Product 2 &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCart([...cart, &quot;Product 2&quot;])&#125;&gt;Add to Cart&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;                &lt;li&gt;Product 3 &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCart([...cart, &quot;Product 3&quot;])&#125;&gt;Add to Cart&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;                &lt;li&gt;Product 4 &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCart([...cart, &quot;Product 4&quot;])&#125;&gt;Add to Cart&lt;&#x2F;button&gt;&lt;&#x2F;li&gt;            &lt;&#x2F;ul&gt;            &lt;button onClick&#x3D;&#123;performCheckout&#125;&gt;Checkout&lt;&#x2F;button&gt;        &lt;&#x2F;div&gt;    );&#125;export default MyComponent;\nClick Analytics Auto-collection plugin自动跟踪网页上的单击事件，并使用 HTML 元素上的 data-* 属性来填充事件遥测数据。import &#123; ApplicationInsights &#125; from &#39;@microsoft&#x2F;applicationinsights-web&#39;;import &#123; ClickAnalyticsPlugin &#125; from &#39;@microsoft&#x2F;applicationinsights-clickanalytics-js&#39;;const clickPluginInstance &#x3D; new ClickAnalyticsPlugin();&#x2F;&#x2F; Click Analytics configurationconst clickPluginConfig &#x3D; &#123;  autoCapture: true&#125;;&#x2F;&#x2F; Application Insights Configurationconst configObj &#x3D; &#123;  instrumentationKey: &quot;YOUR INSTRUMENTATION KEY&quot;,  extensions: [clickPluginInstance],  extensionConfig: &#123;    [clickPluginInstance.identifier]: clickPluginConfig  &#125;,&#125;;const appInsights &#x3D; new ApplicationInsights(&#123; config: configObj &#125;);appInsights.loadAppInsights();\n监视对象\nUser   用浏览器cookie中存储的匿名id区分用户JavaScript SDK 自动生成匿名用户和会话 ID，然后在从应用发送这些 ID 后使用这些 ID 填充遥测事件。\nSession 不活动半小时重新记Session 活动24h后重新记Session\nEvent 每次执行trackEvent逻辑 Event参数已加入一组标准属性，包括匿名用户id（anonymous user ID）QQs存疑！其他cookie处理 visit time\n\n\n","categories":["云平台"],"tags":["Azure"]},{"title":"Azure-BlobStorage","url":"/qqsnote/2021/02/03/Azure-BlobStorage/","content":"Blob Storage存储资源的三个层次\n\nstorage account 存储实例的顶级层次\ncontainers 相当于目录\nblob 文件实体\n\nAzure 门户点击Storage Account，查看当前tenant的Storage Account，进入其中某个account, 关于存储，提供了一个Explorer工具左侧工具 Blob Services - Containers 创建容器csd-commom，（意外地发现之前做App Services备份地Deploy Packages在这里）进入容器，可以直接使用页面提供的上传入口，上传可以填写一个folder，文件上传时自动使用该folder作为子目录官方教程：使用 Azure 存储在云中上传图像数据$blobStorageAccount（存储账户）    $blobStorageAccount（容器）myAppServicePlan（应用服务计划）    myResourceGroup（资源组）        $webapp（App Service）dotNet Blob Uploader\nYourStorageAccount — Settings — Access keys 查看账户密钥以及连接字符串\ndotNet Blob Client Package: Azure.Storageusing Azure.Storage;using Azure.Storage.Blobs;using Azure.Storage.Blobs.Models;...public Task&lt;bool&gt; UploadFileToStorage(Stream fileStream)&#123;  &#x2F;&#x2F; Create a URI to the blob  Uri blobUri &#x3D; new Uri(&quot;https:&#x2F;&#x2F;&quot; +                        _storageConfig.AccountName +                        &quot;.blob.core.windows.net&#x2F;&quot; +                        _storageConfig.ImageContainer +                        &quot;&#x2F;&quot; + fileName);  &#x2F;&#x2F; connection credential  StorageSharedKeyCredential storageCredentials &#x3D;      new StorageSharedKeyCredential(_storageConfig.AccountName, _storageConfig.AccountKey);  &#x2F;&#x2F; Create the blob client.  BlobClient blobClient &#x3D; new BlobClient(blobUri, storageCredentials);  &#x2F;&#x2F; Upload the file  await blobClient.UploadAsync(fileStream);  return await Task.FromResult(true);&#125;public static async Task&lt;List&lt;string&gt;&gt; GetThumbNailUrls(AzureStorageConfig _storageConfig)&#123;    List&lt;string&gt; thumbnailUrls &#x3D; new List&lt;string&gt;();    &#x2F;&#x2F; Create BlobServiceClient from the account URI    BlobContainerClient container &#x3D; new BlobContainerClient(connectionString, _storageConfig.ThumbnailContainer);    &#x2F;&#x2F; Get reference to the container    BlobContainerClient container &#x3D; blobServiceClient.GetBlobContainerClient(_storageConfig.ThumbnailContainer);    if (container.Exists())    &#123;        foreach (BlobItem blobItem in container.GetBlobs())        &#123;            thumbnailUrls.Add(container.Uri + &quot;&#x2F;&quot; + blobItem.Name);        &#125;    &#125;    return await Task.FromResult(thumbnailUrls);&#125;Blob SDK for Node.js： @azure/storage-blobconst express &#x3D; require(&#39;express&#39;)const bodyParser &#x3D; require(&#39;body-parser&#39;)const multer &#x3D; require(&#39;multer&#39;)const _fs &#x3D; require(&#39;fs&#39;)const &#123; StorageSharedKeyCredential,    BlobServiceClient &#125; &#x3D; require(&#39;@azure&#x2F;storage-blob&#39;)const &#123;AbortController&#125; &#x3D; require(&#39;@azure&#x2F;abort-controller&#39;)const app &#x3D; express();&#x2F;&#x2F; init blob clientconst STORAGE_ACCOUNT_NAME &#x3D; &#39;YourResourceGroupName&#39;const CONTAINER_NAME &#x3D; &#39;BlobStorageContainerName&#39;const ACCOUNT_ACCESS_KEY &#x3D;&#39;****************************&#39;const ONE_MEGABYTE &#x3D; 1024 * 1024;const FOUR_MEGABYTES &#x3D; 4 * ONE_MEGABYTE;const ONE_MINUTE &#x3D; 60 * 1000;const aborter &#x3D; AbortController.timeout(30 * ONE_MINUTE);const credentials &#x3D; new StorageSharedKeyCredential(STORAGE_ACCOUNT_NAME, ACCOUNT_ACCESS_KEY);const blobServiceClient &#x3D; new BlobServiceClient(&#96;https:&#x2F;&#x2F;$&#123;STORAGE_ACCOUNT_NAME&#125;.blob.core.windows.net&#96;,credentials);const containerClient &#x3D; blobServiceClient.getContainerClient(CONTAINER_NAME);&#x2F;&#x2F;app.use(bodyParser.urlencoded(&#123; extended: false &#125;));const upload &#x3D; multer(&#123;dest:&#39;&#x2F;uploads&#39;&#125;)app.post(&#39;&#x2F;upload&#39;,upload.single(&#39;file&#39;), async (req,res)&#x3D;&gt;&#123;    var des_file &#x3D; __dirname + &#39;&#x2F;tmp&#x2F;&#39; +req.file.originalname;    const stream &#x3D; _fs.createReadStream(req.file.path)    const blobClient &#x3D; containerClient.getBlobClient(req.file.originalname);    const blockBlobClient &#x3D; blobClient.getBlockBlobClient();    const uploadOptions &#x3D; &#123;        bufferSize: FOUR_MEGABYTES,        maxBuffers: 5,    &#125;;    const result &#x3D; await blockBlobClient.uploadStream(        stream,         uploadOptions.bufferSize,         uploadOptions.maxBuffers,        aborter);    res.json(result)&#125;)const port &#x3D;process.env.PORT||3000;app.listen(port,()&#x3D;&gt;&#123;    console.log(&#39;server on port:&#39;, port)&#125;)Azure Blob js SDK\n—&gt;自己的栗子\n","categories":["云平台"],"tags":["Azure"]},{"title":"Azure 标识管理","url":"/qqsnote/2021/01/28/Azure-IdentityManage/","content":"\n用户删除后挂起30日，期间可以还原\n\n","categories":["云平台"],"tags":["Azure"]},{"title":"Azure 网络管理","url":"/qqsnote/2020/12/09/Azure-Networkinng/","content":"配置和管理虚拟网络占比30-35%目标导向：\n\n学习创建虚拟网络\n创建虚拟VPN网关\n认识使用ExpressRouter虚拟网络功能:\n隔离和分割(Isolation &amp; segmentation)\n网络通信、资源间通信、与本地网络(on-premises)通信\n连接虚拟网络\n路由|筛选|连接网络流量(route|filter network traffic)\n\nVPN(virtual private networks):\n\nPoint-to-site\nSite-to-site\nAzure ExpressRouteNetwork Monitor\n监视vm与endpoint(可以是其他vm)之间的通信\n查看vnet中的资源及其关系\n诊断(Diagnose)出入vm的网络流量筛选问题\n诊断vm网络路由问题\n诊断vm出站连接(outbound connections)\n捕获出入vm的数据包\n诊断vnet网关与连接的问题\n检查区域与internet相对延迟\n查看安全规则概念IP地址空间：举个栗子地址空间192.168.1.0/24，子网掩码255.255.255.248。子网掩码用来指明某个IP地址哪些位是网络位，哪些是主机位，同网络位IP之间的通信不需要通过网关，主机位数值就是有多少主机。IP总共32位，‘/24’是指前24位都是网络位，主机坐在的网络，248即11111000，这个网络有可以有 25 即32个子网，每个子网可分配地址为 23 - 2（减去广播地址和网络地址），为6个虚拟机通过虚拟网络通信的实践创建虚拟网络,名为default$Subnet&#x3D;New-AzVirtualNetworkSubnetConfig -Name default -AddressPrefix 10.0.0.0&#x2F;24New-AzVirtualNetwork -Name myVnet -ResourceGroupName vm-networks -Location $Location -AddressPrefix 10.0.0.0&#x2F;16 -Subnet $Subnet\n使用powershell创建两个Azure VMNew-AzVm &#96; -ResourceGroupName &quot;vm-networks&quot; &#96; -Name &quot;testvm1&quot; &#96; -VirtualNetworkName &quot;myVnet&quot; &#96; -SubnetName &quot;default&quot; &#96; -image &quot;Win2016Datacenter&quot; &#96; -Size &quot;Standard_DS2_v2&quot;\n*取消其中一台的公共IP$nic &#x3D; Get-AzNetworkInterface -Name testvm2 -ResourceGroup vm-networks$nic.IpConfigurations.publicipaddress.id &#x3D; $nullSet-AzNetworkInterface -NetworkInterface $nic\n使用PublicIP远程VM1，在VM1使用计算机名访问同一虚拟网络的VM2\n\nVPN网关Azure虚拟网关为‘从本地到Azure’的传入连接提供一个endpoint，VPN网关是一种虚拟网关类型，可以作为加密的endpoint，在Azure的实践中，VPN网关用以在不同区域之间安全地链接虚拟机和服务\n","categories":["云平台"],"tags":["Azure"]},{"title":"Azure-SQLDB","url":"/qqsnote/2021/01/04/Azure-SQLDB/","content":"Azure SQL包括\n\nAzure SQL DB\nAzure MI (Managed Instance 与SQL Server功能一致的服务，用于云迁移方案)\nSQL Server in Azure VMAzure SQL DB 和 Azure MI属于PaaS， SQL Server in Azure VM属于IaaS可用性功能可用性区域和可用性组。较低服务层级中的数据库使用“不同但等效的机制”通过存储提供冗余。 内置逻辑可帮助防范单个计算机发生故障。 使用活动异地复制功能可以在灾难损毁整个区域时提供保护。业务连续性和全局可伸缩性。\n\n","categories":["云平台"],"tags":["Azure"]},{"title":"Azure Expert Notes","url":"/qqsnote/2020/10/20/AzureExpertNotes/","content":"云管理员，与普通IT管理员相比，不需要过多关注具体硬件软件的内容，云管理员管理着包括存储、网络连接和计算云功能在内的云服务，并对整个IT生命周期中的每项服务具有深入了解\n他们接收最终用户对接入新云应用程序的请求，为其提供服务建议\nOverviewThere are 7 modules to learn:\n\nPrerequisites for Azure administrators\nManage identities and governance in Azure\nImplement and manage storage in Azure\nDeploy and manage Azure compute resources\nConfigure and manage virtual networks for Azure administrators\nMonitor and back up Azure Resources即Azure的订阅和资源，管理身份，实施和管理存储，虚拟机，虚拟网络, 监视和备份https://docs.microsoft.com/en-us/learn/certifications/exams/az-104Azure Policy参考利用 Azure Policy 进行云上资源实时控制及合规监控\nAzure Policy的工作原理是选择或新建一个策略或计划（计划是一组策略的集合），分配给指定范围的资源，然后定期（24小时左右）Policy会检查这些资源是否符合策略或计划，并列出不合规项。\n\n\n\nAz104 Q5 使用resource policy修改虚拟网络的限制\n类似的： 蓝图blue print，为某个订阅制订蓝图（和策略一样，azure上由很多已定义的）Monitor里的Alert，为某个特定资源添加警报\n虚拟机可用性、可用区和可用集\n可用性是可供使用的时间段的百分比，任意时间可访问的服务即100%可用性\n\n因故障、因物理故障触发的自动迁移、定期更新都有可能造成资源可用性达不到100%\n管理可用性创建和部署高度可用的虚拟机\n\n可用性区域:区域中的唯一物理位置,每个区域由一个或多个数据中心组成，这些数据中心配置了独立电源，冷却和网络。区域中可用性区域的物理隔离可以在发生数据中心故障的情况下保护应用程序和数据。 区域冗余服务可跨可用性区域复制应用程序和数据，以防范单点故障。\n\n更新域和容错域的组合\n当两个或更多个 VM 部署在一个 Azure 区域中的两个或更多个可用性区域时，可获得99.99% VM 运行时间 SLA(service-level agreement, 服务级别协议)\n\n\n使用可用性区域创建vm settings—&gt;High availability—&gt;选择一个编号的区域 详细\n而可用性集是一种逻辑分组功能，将在物理层面相分离的vm连接到一起，如果运行服务器的其中之一的物理硬件有问题，可以确信服务器的其他实例保持运行，因为它们位于不同的硬件上。使用命令创建可用性集 详细\n\nMicrosoft 为部署在可用性中的多实例 VM 提供 99.95% 的外部连接性服务级别协议 (SLA)。 这意味着，对于要应用的 SLA，必须在可用性集中至少部署两个 VM 实例。\n\nYou plan to deploy three Azure virtual machines named VM1, VM2, and VM3. The virtualmachines will host a web app named App1.You need to ensure that at least two virtual machines are available if a single Azure datacenterbecomes unavailable.What should you deploy?A. all three virtual machines in a single Availability ZoneB. all virtual machines in a single Availability SetC. each virtual machine in a separate Availability ZoneD. each virtual machine in a separate Availability Set\nAnswer is B.\n\n可以自己提供非官方镜像用于创建虚拟机\nIt is possible to change the size of a VM after it’s been created, but the VM must be stopped first. So, it’s best to size it appropriately from the start if possible.调整vm配置需要停机\n\n\n几个size：普通的（B，D..）大数据存储（L-series），图形渲染（N-series），高性能（H-series）\nYou can store data on the primary drive along with the OS(默认挂载/dev/sda,最大2018G), but a better approach is to create dedicated data disks（可以挂几万GiB）. \n\n\n关于硬盘的unmanaged（以容量和IO计费）和managed（提供存储的伸缩性，提供快照和备份等）\nssh创建虚拟机时可以选择生成key pair，创建完成后下载pem文件用于连接，抑或在本地生成key pair使用其中的public key创建连接上VM使用下述方式添加更多的public key# 创建公钥私钥对ssh-keygen -t rsa -b 4098# 将公钥贴到虚拟机上ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub azureuser@myserver\n虚拟机创建完成的初始网络状态是：Outbound request are allowed. Inbound traffic is only allowed from within the virtual network.即出站任意，入站限制为允许虚拟网络内的访问\nWindows虚拟机相关：远程桌面连接(RDP 3389); 网络安全组（NSG）设置入站出站规则，软件防火墙 \nThe rules are evaluated in priority-order, starting with the lowest priority rule. Deny rules always stop the evaluation. The last rule is always a Deny All rule.That means to have traffic pass through the security group you must have an allow rule or it will be blocked by the default final rule. 规则使用优先级层叠，若无允许则被底层规则(the final rule)禁止\n\n\n\n虚拟机的备份(存目)\nNetworking学习目标：\n\n概念：网络协议和网络标准。\n网络拓扑类型（网格，总线，星形）\n网络设备。\n网络通信原则（如 TCP/IP、DNS 和端口）。\n！以上组件在 Azure 网络上的映射和配置。\n\nAzure虚拟网络Bridge(网桥)，将网络划分为网段，在其之间过滤和推送数据包，数据流向通过MAC地址决定，可以减少不必要的网络交通以提升网络传输性能。HUb(指网络集线器)，充当网络上的多端口中继器，用以连接多个设备并构建网络布局，集线器将以固定的速度运行即所连接的最慢的网络设备的速度Switch(交换机)，是网桥和集线器的结合\ntip：进入命令行help可看到所有支持的命令，用tcping代替ping\n协议：\n\n邮局协议 3(Post Office Protocol 3, POP3) 用于接收邮件\n简单邮件传输协议 (SMTP) 使用邮件服务器发送邮件\n交互式邮件访问协议 (IMAP) 管理邮箱\n安全套接字层 (Secure Socket Layer, SSL) 标准的加密和安全性协议，提供计算机和Internet访问目标服务器或设备之间的安全的加密连接\n传输层安全 (Transport Layer Security, TLS) SSL的后继者\n安全超文本传输协议 (HTTPS) 使用SSL或TLS加密的HTTP\n安全外壳 (Secure Shell, SSH) \nKerberos 验证协议 通过密钥加密为cs应用提供鲁棒的认证\n简单网络管理协议 (SNMP) 允许从网络上的设备收集数据以进行管理\nInternet 控制消息协议 (ICMP) 允许网络的设备发送警告或错误\n\nIPS模型：\nDNS(Domain Name System)分散式查找服务，将用户可读的域名或 URL 转换为承载站点或服务的服务器的 IP 地址。\n\nA SOA寻址\nAAAA IP寻址\nCNAME 域名别名\nNS 名称服务器 \nMX SMTP 电子邮件 网络安全学习目标\nC/S网络模型：请求-响应；P2P(Peer-to-Peer)；发布-订阅\n认证和授权\n网络防火墙类型\n监控项目\n在Azure上的映射\n\n关于认证：\n\n密码认证\n双因素(two-factor)认证:如账户密码+邮箱/手机认证\ntoken authentication\n生物识别认证(Biometric authentication)：如用指纹、语音或人脸识别\n事务认证(Transactional authentication) 通常用于提供额外的认证保护，如在工作时间范围内允许访问\n图灵测试(CAPTCHA)解释看到的信息,通常是模糊的文字或场景中的特征,CAPTCHA可能会给存在视力障碍的用户带来困难\n\n认证协议：\n\nKerberos\nTLS/SSL\n\n授权：私以为其概念是对已持有的认证身份标记所赋予的权限\n防范目标和措施：\n\nany user, 访问控制(access control)即对用户设置访问相应资源的权限级别\n恶意软件，杀软\n应用程序漏洞\n行为分析，创建安全策略识别具有潜在危险的行文\n邮件，识别可疑邮件和发信人\n入侵检测(存目)\n\n防火墙：\n\n应用程序层防火墙 如检测HTTP请求的插件或筛选器\n数据包筛选防火墙 如检测数据包\n线路级(circuit-level)防火墙 如检查TCP/UDP连接的源、目标、用户等是否符合既定规则\n代理服务器防火墙 以代理控制信息进出网络，因此可以监视、筛选和缓存网络上任意类型设备的internet访问\nstateful firewalls &amp; next-generation firewalls\n\n通过配置与 Azure 的“站点到站点 VPN”连接，将本地网络连接到 Azure 虚拟网络。亦可通过vpn配置实现点(client)到站点的连接\nNotice:\n\n关键 Azure 服务只连接 Azure 虚拟网络，不连接公共 Internet,比如Azure SQL数据库，Azure Storage等\n尽可能禁用SSH/RDP 访问，应先创建点到站点 VPN 连接，然后再为远程管理启用 SSH/RDP。\n\nMonitor：\n\nSNMP 简单网络管理协议，前文已述，允许访问网络设备的信息\nSyslog 允许设备发送事件，用于事件日志记录\nAzure Monitor是网络监控解决方案，包含Log Analytics工具，用以查询、分析日志PowerShell学习目标\n使用Azure PowerShell 连接/操作 Azure资源Azure Portal，Azure CLI，Azure PowerShell是管理Azure资源的三种工具，相比Azure Portal页面，脚本工具因可以编写逻辑而更适合进行批量操作，以及自动化Import-Module AzConnect-AzAccountGet-AzResourceGroup... &lt;-- 这里会列出资源组Get-Credential... &lt;-- 这里设置访问虚拟机的凭据New-AzVM -Name &quot;testvm-eus-01&quot; -ResourceGroupName &quot;learn-940e9418-9b64-4c5b-a12c-a136ccb641da&quot; -Credential (Get-Credential) -Location &quot;East US&quot; -Image UbuntuLTS -OpenPorts 22$vm &#x3D; (Get-AzVM -Name &quot;testvm-eus-01&quot; -ResourceGroupName learn-940e9418-9b64-4c5b-a12c-a136ccb641da)$vm | Get-AzPublicIpAddressssh QQs@13.92.231.172 ... &lt;-- 使用ssh连接虚拟机Stop-AzVM -Name $vm.Name -ResourceGroup $vm.ResourceGroupNameRemove-AzVM -Name $vm.Name -ResourceGroup $vm.ResourceGroupName$vm | Remove-AzNetworkInterface –ForceGet-AzDisk -ResourceGroupName $vm.ResourceGroupName -DiskName $vm.StorageProfile.OSDisk.Name | Remove-AzDisk -ForceGet-AzVirtualNetwork -ResourceGroup $vm.ResourceGroupName | Remove-AzVirtualNetwork -ForceGet-AzNetworkSecurityGroup -ResourceGroup $vm.ResourceGroupName | Remove-AzNetworkSecurityGroup -ForceGet-AzPublicIpAddress -ResourceGroup $vm.ResourceGroupName | Remove-AzPublicIpAddress -Force\n注意 上面停止并移除虚拟机后，其他相关资源如网络接口、托管磁盘、网络安全组、公共IP另需手动删除似乎应该具备编写powershell脚本的能力，知乎：PowerShell有没有必要学？param([string]$resourceGroup) &#x2F;&#x2F; 获取变量参数$adminCredential &#x3D; Get-Credential -Message &quot;Enter a username and password for the VM administrator.&quot;For ($i &#x3D; 1; $i -le 3; $i++)&#123;    $vmName &#x3D; &quot;ConferenceDemo&quot; + $i    Write-Host &quot;Creating VM: &quot; $vmName    New-AzVm -ResourceGroupName $resourceGroup -Name $vmName -Credential $adminCredential -Image UbuntuLTS&#125;\n\n\nQ: Admin1 attempts to deploy an Azure Marketplace resource by using an Azure Resource Manager template. Admin1 deploys the template by using Azure PowerShell and receives the following error message: “User failed validation to purchase resources. Error message: “Legal terms have not been accepted for this item on this subscription. To accept legal terms, please go to the Azure portal (http:// go.microsoft.com/fwlink/?LinkId=534873) and configure programmatic deploymentfor the Marketplace item or create it there for the first time.”You need to ensure that Admin1 can deploy the Marketplace resource successfully.What should you do?Answer is: From Azure PowerShell, run the Set-AzMarketplaceTerms cmdlet\n数据和存储数据：结构化数据、半结构化数据(也就是NoSQL数据，如Json数据，Xml数据)、非结构化数据事务数据库：联机事务处理(Online Transaction Processing，OLTP)系统和联机分析处理(Online Analytical Processing，OLAP)系统，通常情况下，前者服务于较大量的用户，响应更快，可用性更高，处理大量数据(handle large volumns of data)，后者用于处理大型复杂事务(handle large and complex transactions)建议使用Azure Cosmos DB管理NoSQL数据，使用Azue Blob Storage管理文件数据，结构化数据使用Azure SQL Database, Azure SQL Database可以认为是云端托管的sqlserver\n订阅AZ104 Q9 Only a global administrator can add users to this tenant.跨订阅移动资源，虚拟机、存储、虚拟网络、托管磁盘(managed disk)、Recovery Service均可移动 Microsoft Docs:跨订阅移动方案\nAzure BackupAZ104 Q7 Azure Backup 执行备份并不受限于虚拟机的os，是否在运行。AZ104 Q8 Azure Recovery Vault 如果数据源位于多个区域中，请为每个区域创建恢复服务保管库\nunachievedYou have a Microsoft 365 tenant and an Azure Active Directory (Azure AD) tenant namedcontoso.com.You plan to grant three users named User1, User2, and User3 access to a temporary Microsoft SharePoint document library named Library1. You need to create groups for the users. The solution must ensure that the groups are deleted automatically after 180 days.Which two groups should you create? Each correct answer presents a complete solution.A. an Office 365 group that uses the Assigned membership typeB. a Security group that uses the Assigned membership typeC. an Office 365 group that uses the Dynamic User membership typeD. a Security group that uses the Dynamic User membership typeE. a Security group that uses the Dynamic Device membership type\nhint:Microsoft 365 组过期策略 answer is AC\n","categories":["云平台"],"tags":["Azure"]},{"title":"Azure Fuctions","url":"/qqsnote/2019/08/05/AzureFuctions/","content":"Azure Functions 是微软云提供的部署Api服务的一种功能，利用Azure Functions部署些Api，无需创建/配置服务器环境。即无需先创建 VM 或发布 Web 应用程序。Azure Function项目自包含运行环境，不依赖外部服务、框架等\n安装Azure Functions Core Tools 2.x\n安装 .Net Core 2.x SDK用于 Windows 的 .NET Core 2.x SDK。\n使用npm安装Core Tools包  npm install -g azure-functions-core-tools\nVS Code Azure Functions 扩展搜索 azure functions，或者在 Visual Studio Code 中打开此链接，安装该扩展。命令行调试安装Azure Functions .NET Workerfunc host start --dotnet-isolated-debug\n创建Functions\n\n\n按 F1 键打开命令面板。 在命令面板中，搜索并选择 Azure Functions: Create new project…。\n按照提示对项目进行预设\n \n     \n         Prompt\n         value\n         description\n     \n     \n         Select a language for your function app project\n         C# or JavaScript\n         This article supports C# and JavaScript. For Python, see this Python article, and for PowerShell, see this PowerShell article\n     \n     \n         Select a template for your project’s first function\n         HTTP trigger\n         Create an HTTP triggered function in the new function app.\n     \n     \n         Provide a function name\n         HttpTrigger\n         Press Enter to use the default name.\n     \n     \n         Authorization level    \n         Function\n         Requires a function key to call the function’s HTTP endpoint.\n     \n     \n         Select how you would like to open your project    \n         Add to workspace\n         Creates the function app in the current workspace.\n     \n \n\n本地调试开启F5 / 停止shift+F5local.settings.json 文件存储应用设置、连接字符串和本地开发工具使用的设置。 只有在本地运行项目时，才会使用 local.settings.json 文件中的设置。 \n关于调用参数上面提到本地调试的参数可存于 local.settings.json，取这些参数的方法同取环境变量方法：\n\n\n\nSystem.Environment.GetEnvironmentVariable 或 ConfigurationManager.AppSettings （C#）\nprocess.env. Settings （js）\n在 Azure Functions 中，没有所有环境通用的基线配置, 即并非所有Azure Function实现都是从本地开发版本部署的，最初是在云中编辑独立解决方案，而不是部署多个版本具有不同的配置。探索 .NET Core 配置系列二\n发布Functions到Azure发布功能需要开启Azure Functions: Advanced Creation，在VS Code settings中可以设置，或者发布失败时根据弹窗提示更新设置\n\n\n\n\n在 Visual Studio Code 中，按 F1 键打开命令面板。 在命令面板中，搜索并选择 Azure Functions: Deploy to function app…。\nCreate New Function App in Azure\nEnter a global unique name for the new function app\nselect an OS\nselect a hosting plan 托管计划consumption plan 和 app service plan等，参考\n\n使用visual studio发布\n连接存储队列\n安装适应于 VS Code 的Azure存储扩展\n安装Azure存储资源管理器\n\n","categories":["云平台"],"tags":["Azure"]},{"title":"B1EnglishForDeveloper","url":"/qqsnote/2025/11/18/B1EnglishForDeveloper/","content":"\nThat’s queit a hunt 形容这个issue的debug如狩猎\nsomething odd [a:d]\nThat’s great, wasn’t it stressful thought 太棒了或者还是有点压力？ though句末表转折\nappropriate naming 恰当的命名\nfine-tuning code 代码\nanticipate / predict 预测\nroll out / launch an update\nThanks for staying proactive, QQs 感谢你积极响应\nkeep up momentum 保持势头 干劲\nsolely 仅仅 merely 只是 only 只有\nsecurity vulnerability 安全漏洞\noverlook 忽视\n\n","tags":["英语"]},{"title":"Babylon","url":"/qqsnote/2023/09/12/BabylonJS/","content":"","categories":["前端技术"],"tags":["Babylon"]},{"title":"基本算法-String, Array","url":"/qqsnote/2018/07/31/BasicAlgorithm1/","content":"\n实现字符串翻转方法function reverseString(str) &#123;    var litters&#x3D;str.split(&quot;&quot;);    var rlitters&#x3D;litters.reverse();    return rlitters.join(&quot;&quot;);&#125;reverseString(&quot;hello&quot;);\n区分String方法split以及Array方法slice, splicesplit 以特定字符或正则表达式为标记，将字符串分割为字符串数组slice 以起止下标为界切片返回新数组，原数组不受影响splice 以起止下标为界切片从数组中剔除\n\n常用到的将含length的对象转为数组用Array.prototype.slice.call(a)\n\n实现数字千位分隔符function kiloFormat(num)&#123;\tnum&#x3D;num.toString().split(&quot;.&quot;);&#x2F;&#x2F;区分整数部分和小数部分\tnum[0]&#x3D;num[0].split(&quot;&quot;).reverse();&#x2F;&#x2F;整数部分数组化并翻转\tnum[0]&#x3D;num[0].map((item,i)&#x3D;&gt;&#123;\tif(i%3&#x3D;&#x3D;0&amp;&amp;i!&#x3D;0)&#123;\t\treturn item+&#x3D;&quot;,&quot;;&#125;else&#123;return item;&#125;&#125;);num[0]&#x3D;num[0].reverse().join(&quot;&quot;);return num.join(&quot;.&quot;);&#125;&#x2F;&#x2F; 另 正则表达式实现function thousandBitSeparator(num) &#123;    return num &amp;&amp; num        .toString()        .replace(&#x2F;(\\d)(?&#x3D;(\\d&#123;3&#125;)+\\.)&#x2F;g, function($0, $1) &#123;            return $1 + &quot;,&quot;;        &#125;);&#125;\n\n","categories":["算法"],"tags":["算法","javascript"]},{"title":"数据可视化入门","url":"/qqsnote/2019/08/16/BasicDataVisualization/","content":"D3.js 和 Echart原文：D3.js与echart.js的应用场景\n\necharts和D3都是常用的数据可视化库，实现了能应用于各场景的图表等插件，两者之间的不同之处就在于echarts是使用canvas来绘制图形的，而D3是通过Svg来绘制图形的。svg可以操作dom支持事件处理器，想要实现某个操作，直接调用相关的方法实现效果就行，svg操作存在链式语法，与jQuery的链式调用差不多，简单易读。canvas不支持事件处理器所以只能展示数据，而不能修改。\n\n\nD3使用svg绘制图形，echarts使用canvas绘制图形\nD3兼容IE9及以上主流浏览器，echarts兼容IE6及以上主流浏览器\nD3使用灵活，学习成本大，echarts封装好的，使用简单，不够灵活\n\n因为D3支持事件处理器可以操作dom，所以如果在项目开发中如果有较多用户交互的场景，可以使用D3.如果项目中一般没有用户交互的场景，我们只需要将图表展示给用户看，而不需要更改，可以使用echarts。因为D3它展示的每一个数据都是一个标签，所以当数据发生改变的时候图表会重新渲染，会不停的操作dom，这对性能的消耗是非常大的（存疑，对于同样需要交互的需求，究竟是D3因为绑定了数据的dom频繁渲染消耗大，还是任意修改都需要重绘整个canvas的Echart消耗大呢?）。\n掘金：前端可视化工具库\n其中提到 Echarts分享社区\n","categories":["前端技术"],"tags":["数据可视化"]},{"title":"Node 及 Express 入门","url":"/qqsnote/2019/07/19/BasicNodeAndExpress/","content":"\n一切可以用JavaScript实现的，终将用Javascript来实现\n\nNode.js官方定义\n\nNode.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.\n\nNode 是js的一种新的运行环境，基于Chrome V8 js引擎开发，以事件驱动和无阻塞IO模型实现轻量和高效. npm是Node包管理生态系统，目前是世界最大的开源库。\n关于CommonJSCommonJS规范————阮一峰CommonJS规范是旨在解决Javascript的作用域问题，其规定每个文件就是一个模块，有其自己的作用域，一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见（例外的文件之间分享使用global全局变量）模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。\nrequire是同步执行的，只有加载完成，才能执行后面的操作 浏览器端一般遵循异步模块定义(asynchronous module definition, AMD)协议\nmodule上文所述，每个文件就是一个模块，在每个模块/文件内部，都有一个module对象，该对象存在以下属性\n\nmodule.id 模块的识别符，通常是带有绝对路径的模块文件名。\nmodule.filename 模块的文件名，带有绝对路径。\nmodule.loaded 返回一个布尔值，表示模块是否已经完成加载。\nmodule.parent 返回一个对象，表示调用该模块的模块。(可以判断是否为应用入口)\nmodule.children 返回一个数组，表示该模块要用到的其他模块。\nmodule.exports 表示模块对外输出的值。\n\nExpress.jsExpress 是一个简洁而灵活的 node.js Web 应用程序框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。\nserver.js\nconst express = require(&#x27;express&#x27;);const app = express();app.get(&#x27;/&#x27;,function(req, res)&#123;    res.send(&#x27;hello express&#x27;)&#125;);const listener = app.listen(8080, function()&#123;    console.log(&#x27;express app is running on port &#x27;+listener.address().port)&#125;)\n插一句，require和importvscode 建议我将上面第一行代码改为‘import express from ‘express’’Require是CommonJS的语法，CommonJS的模块是对象，输入时必须查找对象属性。\ndeclare module.fs&#123;  function stat()&#123;&#125;  //...&#125;\nlet &#123; stat, exists, readFile &#125; = require(&#x27;fs&#x27;);// 等同于let _fs = require(&#x27;fs&#x27;);let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile;\nES6模块不是对象，而是通过export命令显示指定输出代码，再通过import输入。import的可以是对象定义或表达式等express封装了http method 和 router\n/** A first working Express Server */app.get(&#x27;/&#x27;,function(req, res)&#123;  res.send(&#x27;Hello Express&#x27;)&#125;)/** Serve an HTML file */app.get(&#x27;/views/index.html&#x27;,function(req,res)&#123;  let absolutePath = __dirname + &#x27;/views/index.html&#x27;  res.sendFile(absolutePath)&#125;)/** Serve static assets  */app.use(&#x27;/public&#x27;, express.static( __dirname + &#x27;/public&#x27;))// 内置中间件函数，访问静态资源文件/** params  add a &#x27;?&#x27; if the parameter is omissible */app.get(&quot;/api/timestamp/:date_string/:addr_string?&quot;,function(req,res)&#123;  res.json(req.params.date_string)&#125;)/** Request Headers */app.get(&quot;/api/whoami&quot;, function (req, res) &#123;  var ip = req.header(&#x27;x-forwarded-for&#x27;) || req.connection.remoteAddress;  var lang = req.header(&#x27;Accept-Language&#x27;);  var software = req.header(&#x27;User-Agent&#x27;);  console.log(&#123;&quot;ip&quot;:ip,&quot;language&quot;:lang,&quot;software&quot;:software&#125;)  res.json(&#123;&quot;ip&quot;:ip,&quot;language&quot;:lang,&quot;software&quot;:software&#125;);&#125;);\n请求参数的获取方式\n\npath中的变量，形如/api/user/:userId, 用req.params.userId\nurl参数如?org=dw001&amp;type=1,将直接结构化为req.query对象\npost请求的RequestBody，使用bodyParser中间件，添加到req.body中\nreq.param(parameterName)方法\n\n中间件middleware\n\nExpress是一个自身功能极简，完全是路由和中间件构成一个web开发框架：从本质上来说，一个Express应用就是在调用各种中间件。\n\napp.get(&#x27;/now&#x27;, function(req, res, next)&#123;        let now = new Date().toString();        req.time = now;        next();&#125;,  function(req, res)&#123;        res.json(&#123;time: req.time&#125;)&#125;)\n大致是express().[method]([path],[middleware],(req,res)=&gt;{…})\n可以引用第三方中间件函数\nbody-parse将post body内容编码并放入req.body\nvar bodyParser = require(&#x27;body-parser&#x27;);app.use(bodyParser.urlencoded(&#123; extended: false &#125;));/** Get data form POST */app.post(&#x27;/name&#x27;,function(req, res)&#123;  res.json(&#123;name: req.body.first + &#x27; &#x27; + req.body.last&#125;)&#125;)\ncookie-parseconst cookieparser = require(&#x27;cookie-parser&#x27;)const util =require(&#x27;util&#x27;)app.use(cookieparser())app.get(&#x27;/getcookie&#x27;,function(req, res)&#123;    res.send(util.inspect(req.cookies))&#125;);\nutil.inspect类似于JSON.stringify将json对象属性以{key}={value};的字符串格式输出\nmulter文件上传\n\nMulter 会添加一个 body 对象 以及 file 或 files 对象 到 express 的 request 对象中。 body 对象包含表单的文本域信息，file 或 files 对象包含对象表单上传的文件信息。 GitHub:multer\n\nvar _fs = require(&#x27;fs&#x27;) var multer = require(&#x27;multer&#x27;) const upload = multer(&#123;dest:&#x27;/tmp&#x27;&#125;) app.post(&#x27;/files/upload&#x27;, upload.single(&#x27;file&#x27;), function(req,res)&#123; // image是input [type=&#x27;file&#x27;] 的name属性 或 formdata的field名    console.log(req.files[0])    var des_file = __dirname + &#x27;/tmp/&#x27; +req.files[0].originalname;    _fs.readFile(req.files[0].path, function(err, data)&#123;      _fs.writeFile(des_file, data, function(err)&#123;        var response=&#123;&#125;        if(err)&#123;            console.log(err)        &#125;else&#123;            response=&#123;                message:&#x27;File uploaded successfully&#x27;,                filename:req.files[0].originalname            &#125;        &#125;        console.log(response);        res.end(JSON.stringify(response))      &#125;)    &#125;)&#125;)\nMulter 接受一个 options 对象，其中最基本的是 dest 属性，这将告诉 Multer 将上传文件保存在哪。如果你省略 options 对象，这些文件将保存在内存中，永远不会写入磁盘。 关于options\n环境变量服务端口号变量控制\n// listen for requestsconst listener = app.listen(process.env.PORT, function() &#123;  console.log(&#x27;Your app is listening on port &#x27; + listener.address().port);&#125;);\nunix shell prompt:\nexport PORT=1234echo env|PORTunset PORT\nwindows CMD\n# 设置set PORT=1234# 移除set PORT=\nwindows powershell\n$env:PORT = 1234del env:PORT\ncross-env从package.json获取版本作为环境变量\ncross-env REACT_APP_VERSION=$(node -p &#x27;require(\\&quot;./package.json\\&quot;).version&#x27;)\n关于Node.js的系统学习Node.js的实现的学习才应该是你要学的Node.js本身，而不是无尽的工具和第三方库。\n参考官方文档\n\n熟悉Node.js REPL(Read Eval Print Loop:交互式解释器)\n常用全局变量Global Objects / util\n核心概念 Timers /Buffer / Events / Stream / Modules / Errors\n\n\n外部服务访问静态文件也会有跨域问题, 解决方法:\n\nlet options = &#123;  setHeaders: function (res, path, stat) &#123;    res.set(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;)  &#125;&#125;app.use(express.static(&#x27;public&#x27;, options))\napplication performance使用chrome devtoolProfile和MemoryEasy-Monitor[阿里Node.js性能平台]（https://cn.aliyun.com/product/nodejs）\nto be continued…\nTipspath.resolve vs path.join\nexpress-async-errors\nLimit repeat requests\n","categories":["前端技术"],"tags":["Node.js","环境变量"]},{"title":"BasicPHP","url":"/qqsnote/2019/09/03/BasicPHP/","content":"Linux查看 phpinfophp -i\n或者php -r &quot;phpinfo();&quot;\nsystem执行外部程序$last_time &#x3D; system(&quot;ls&quot;, $retVal)返回值和返会状态。$retVal 可选参数， 记录命令执行后的返回状态。system 返回值，输出命令输出的最后一行\nSession用户在计算机上操作某个应用程序时，打开应用程序 — 做些更改 — 然后关闭它。这很像一次对话（Session）。计算机知道您是谁。它清楚您在何时打开和关闭应用程序。然而，在因特网上问题出现了：由于 HTTP 地址无法保持状态，Web 服务器并不知道您是谁以及您做了什么。\nPHP session 解决了这个问题，它通过在服务器上存储用户信息以便随后使用（比如用户名称、购买商品等）。然而，会话信息是临时的，在用户离开网站后将被删除。如果您需要永久存储信息，可以把数据存储在数据库中。\nSession 的工作机制是：为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，或者通过 URL 进行传导。\nphp中的session有效期默认是1440秒（24分钟），也就是说，客户端超过24分钟没有刷新，当前session就会失效。\n集成环境phpEnv 一键安装php、Apache/Nignx、MySQL\nThinkPHP使用composer管理工具\n# 配置使用镜像源composer config -g repo.packagist composer https:&#x2F;&#x2F;packagist.phpcomposer.com# 查看composer config -g -l\n在www目录下创建tp服务项目cd wwwcomposer create-project topthink&#x2F;think www.tp.com# tp5版本composer create-project topthink&#x2F;think&#x3D;5.0.* www.tp.com # 启动php think run\ntrouble-shooting:\n\ncomposer.json requires topthink/think-trace ^2.0, found topthink/think-trace[2.0.x-dev] but it does not match your minimum-stability.\n\n# 更换composer源composer config -g repo.packagist composer https:&#x2F;&#x2F;packagist.org","categories":["编程语言"],"tags":["PHP"]},{"title":"Python 编程基础","url":"/qqsnote/2019/08/29/BasicPython-0/","content":"目前是python3.5\n\nprint() 和 n=input()\n单行注释# 多行’’’\n编码声明# -*- coding:utf-8 -*-缩进\n\nPython没有分割代码块符号，以缩进以及冒号:区分层次，一般以4个空格为基本缩进单位。\n\n命名规范\n\n模块名：全部小写 + 下划线_连接 如 update_userlist\n包名：全部小写，不推荐使用下划线\n类名：Pascal风格（首字母大写）如RegularUser\n模块内部类型： + Pascal风格 如_Config使用单下划线开头的变量和函数是受保护的 protected，在使用from xxx import  时不会被导入；使用双下划线__开头的变量或方法是类私有的 *private\n函数、类的属性和方法：同模块命名\n常量：全部大写\n\n字符串类型’’和””和’’’’’’\n\n使用’’’表示多行字符,使用r’’屏蔽转义\n\n列表和元组\n\narr = [0, 1, 2, 3, 4, 5]arr.append(6)  # [0, 1, 2, 3, 4, 5, 6]arr.remove(0)  # [1, 2, 3, 4, 5]del arr[2]     # [0, 1, 3, 4, 5]del arr[2:4]   # [0, 1, 4, 5]\n\n字符串操作\nglobal关键字\n\n在python中，变量不需要先声明，直接使用即可，那我们怎么知道用的是局部变量还是全局变量呢？首先：python使用的变量，在默认情况下一定是用局部变量。其次：python如果想使用作用域之外的全局变量，则需要加global前缀。\ndef initSettings(self):    global config    config &#x3D; Configure()\n执行脚本$ python test.py arg1 arg2 arg3\n脚本内容如#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import sysprint &#39;参数个数为:&#39;, len(sys.argv), &#39;个参数。&#39;print &#39;参数列表:&#39;, str(sys.argv)\n关于python2.7和python3.5的一万种冲突方式目前的很多情况下，linux的软件管理工具仍然会将python2.7作为默认安装版本，然后在某个时刻你会看到error: xxxx requires python 3.5 or above于是你再安装一个python3，然而python -V依然是2.7于是乎卸载python做link: alias python=python3 均是徒劳\n最后sudo apt install python-is-python3唉，行吧。。\npip 升级issuepython -m ensurepippython -m pip install --upgrade pip\npython packages 国内源pip install -i https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;pypi&#x2F;web&#x2F;simple ****\n查看package版本控制台pip listpip list | grep opencv-python程序中import cv2print(cv2.__version__)\nrequirements.txt\nrequirements.txt is a file that contains a list of packages or libraries needed to work on a project that can all be installed with the file. It provides a consistent environment and makes collaboration easier. 包含项目工作所需的包或库，可以用于一键安装pip install -r requirements.txttips: 加如下参数以指定源 -i https://pypi.douban.com/simple\n\n生成requirements.txt:pip freeze &gt; requirements.txtpip freeze 保存当前Python环境下所有类库\npip install pipreqspipreqs .&#x2F; --encoding&#x3D;utf-8\npipreqs 导出当前项目使用的类库\nglobal#","categories":["编程语言"],"tags":["Python"]},{"title":"Python基础——模块","url":"/qqsnote/2019/08/29/BasicPython-Module/","content":"\n模块是天然的单例模式\n\n","categories":["编程语言"],"tags":["Python"]},{"title":"Python基础——PyCharm","url":"/qqsnote/2022/08/29/BasicPython-PyCharm/","content":"更换国内镜像源\n","categories":["工具"],"tags":["Python","PyCharm"]},{"title":"Python基础——文件系统与IO","url":"/qqsnote/2019/08/29/BasicPython-filesystem/","content":"base, dirs, files in os.walk(indatadir)","categories":["编程语言"],"tags":["Python"]},{"title":"Python基础——内置函数","url":"/qqsnote/2019/08/29/BasicPython-innerFunc/","content":"type()\ntype(obj) 返回对象类型,即返回object的class 或 基本类型变量的类型名\ntype(name, bases, dict) 返回name为类名 bases为基类元组， dict为属性的新类型\n\n&gt;&gt;&gt; type(1)&lt;class &#39;int&#39;&gt;&gt;&gt;&gt; type([])&lt;class &#39;list&#39;&gt;&gt;&gt;&gt; type(&#123;&#125;)&lt;class &#39;dict&#39;&gt;&gt;&gt;&gt; x&#x3D;1&gt;&gt;&gt; type(x)&#x3D;&#x3D;intTrue\n","categories":["编程语言"],"tags":["Python"]},{"title":"Python基础-argparse模块","url":"/qqsnote/2022/09/19/BasicPython-argparse/","content":"argparse模块是python用于解析命令行参数和选项的标准模块 对于封装好的py函数文件 可实现在命令行输出—help的效果：\n定义函数文件#-*- coding: UTF-8 -*-import argparsedef parse_args():    &quot;&quot;&quot;    :return:进行参数的解析    &quot;&quot;&quot;    description &#x3D; &quot;you should add those parameter&quot;     parser &#x3D; argparse.ArgumentParser(description&#x3D;description)        # 这些参数都有默认值，当调用parser.print_help()或者运行程序时由于参数不正确(此时python解释器其实也是调用了pring_help()方法)时，                                                                     # 会打印这些描述信息，一般只需要传递description参数，如上。    mode_desc &#x3D; &quot;action mode&quot;    image_desc &#x3D; &quot;the path of image&quot;    parser.add_argument(&#39;--mode&#39;, help&#x3D;mode_desc)    parser.add_argument(&#39;--image&#39;, help&#x3D;image_desc)    args &#x3D; parser.parse_args()    return argsif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    args &#x3D; parse_args()    if()命令行输入python arg.py -h输出提示为Windows PowerShellCopyright (C) Microsoft Corporation. All rights reserved.   you should add those parameteroptional arguments:  -h, --help            show this help message and exit  --addresses ADDRESSES                        The path of address\nArgumentParser.add_argument(name or flags…[,  action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])\n\nname or flags — 选项字符串的名字或者列表，例如 foo 或者 -f, —foo。\naction— 命令行遇到参数时的动作，默认值是 store; store_const—表示赋值为const；append—将遇到的值存储成列表，也就是如果参数重复则会保存多个值; append_const—将参数规范中定义的一个值保存到一个列表；count—存储遇到的次数；此外，也可以继承 argparse.Action 自定义参数解析动作；\n\nnargs — 应该读取的命令行参数个数，可以是数字，或者通配符如?表示0个或1个；*表示 0 或多个；+表示 1 或多个。\n\nconst - action 和 nargs 所需要的常量值。\n\ndefault— 不指定参数时的默认值。\ntype — 命令行参数应该被转换成的类型。(str, int, bool..)\nchoices — 参数可允许的值的一个容器。\nrequired — 可选参数是否可以省略 (仅针对可选参数)。\nhelp — 参数的帮助信息，当指定为 argparse.SUPPRESS 时表示不显示该参数的帮助信息.\nmetavar — 在 usage 说明中的参数名称，对于必选参数默认就是参数名称，对于可选参数默认是全大写的参数名称.\ndest — 解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线.\n\nparser.add_argument(&#39;--name&#39;, type&#x3D;str, required&#x3D;True, default&#x3D;&#39;&#39;, help&#x3D;&#39;名&#39;)parser.add_argument(&#39;--foo&#39;, action&#x3D;&#39;store_const&#39;, const&#x3D;42) # 实际foo&#x3D;42\n是否输入了某参数parser.add_argument(&#39;--properties&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;properties_desc) 如上调用python arg.py时，若带参数—properties 则args.properties=True 否则为False\n","categories":["编程语言"],"tags":["Python"]},{"title":"BasicShell","url":"/qqsnote/2019/12/26/BasicShell/","content":"","categories":["工具"],"tags":["Shell"]},{"title":"从javascript自执行函数说起","url":"/qqsnote/2018/08/06/BeginWithSelf-ExecutingFunction/","content":"\n出于复用需要的函数封装\n典型的函数库Jquery\n\n匿名函数function()&#123;&#125;\n匿名函数使用func1&#x3D;function()&#123;    console.log(1);&#125;func1();考点：下面的代码输出结果var func&#x3D;function a()&#123;&#125;;console.log(func);console.log(a);答案：function undefined这个叫具名函数表达式变量func引用函数体，虽然该函数具有函数名a 实际上 函数名a仅在其函数体内部有效\n自执行函数\n(function()&#123;    console.log(1);&#125;)()\nfunction外面的括号()消除歧义1\n\n使用自执行函数创建命名空间var qqsNamespace &#x3D; function()&#123;    var func1 &#x3D; function(parameter1,parameter2)&#123;        console.log(&#39;func1&#39;);    &#125;    return &#123;action:func1&#125;&#125;();qqsNamespace.action(1,2);所谓创建命名空间，模仿了块级作用域，调用匿名函数生成一个对象Lib，对象Lib内部定义了自己的方法，使用时根据需要从生成的对象Lib中调用\n\nJQuery","categories":["前端技术"],"tags":["javascript"]},{"title":"CAS","url":"/qqsnote/2020/04/07/CAS/","content":""},{"title":"大前端","url":"/qqsnote/2021/01/12/BidFrontEndTrend/","content":"2020前端展望\n跨端开发，混合应用，小程序等工程化FCC article：前端工程化\n\n编码规范\nrepository规范\nci/cd\n测试 单元测试 e2e\n性能\n数据上报 requestIdleCallback, restful api\n用户行为收集 metadata, page/input/click… —&gt; kafka Queue —&gt; ElasticSearch\n\nTips刷新/关闭页面前发请求Navigator.sendBeacon(url, data) 在页面unload时也可以调用\nmicroservice和serverlessInterview T-stack后端一次性给你10w条数据\n网络延迟抓包工具 Fiddler4 配置移动设备抓取 Https 请求\n","categories":["前端技术"],"tags":["Web开发"]},{"title":"CDN(存目)","url":"/qqsnote/2024/08/13/CDN/","content":""},{"title":"CSS3","url":"/qqsnote/2019/10/18/CSS3/","content":"边框\nbox-shadow examplebox-shadow: red 0 0 5px 5px\n颜色可以放在开头或结尾，也可缺省(即#fff) 数值顺序依次x-offset, y-offset, blur radius, spread radius\nborder-image背景#example1 &#123;     background-image: url(img_flwr.gif), url(paper.gif);     background-position: right bottom, left top;     background-repeat: no-repeat, repeat; &#125;\n渐变\n线性渐变 liner-gradient\n径向渐变 radial-gradient文字特效\ntext-shadow转换 过渡 动画transform 转换 translate() &#x2F;&#x2F; 移动rotate() scale() &#x2F;&#x2F; 缩放skew() &#x2F;&#x2F; 倾斜matrix() &#x2F;&#x2F; 上述转换的综合\n居中：position: &#39;absolute&#39;,margin: &#39;auto&#39;,top: &#39;50%&#39;,left: &#39;50%&#39;,transform: &#96;translate(-50%, -50%)&#96;,\ntransition 过渡transition:transform 0.5s\n将某个样式的变化加入一定过渡动画animation 动画div&#123;    animation: myfirst 5s;    -webkit-animation: myfirst 5s; &#x2F;* Safari 与 Chrome *&#x2F;&#125;@keyframes myfirst&#123;    from &#123;background: red;&#125;    to &#123;background: yellow;&#125;&#125; @-webkit-keyframes myfirst &#x2F;* Safari 与 Chrome *&#x2F;&#123;    from &#123;background: red;&#125;    to &#123;background: yellow;&#125;&#125;\ntransparent vs rgba(0,0,0,0)\n\n优先级\n相同选择器 层叠覆盖\n具体、特异性强的选择器优先级高：类选择器 &gt; 元素选择器中空元素clip-patchcss实现toggle switchhow to css switchtip：在html中 input:type=checkbox 天生具有bool特征 即以checked属性跟踪状态3d效果-prespective, xyzCss 3DHTML + CSS 实现点击旋转&lt;html&gt;  ...  &lt;input type&#x3D;&quot;button&quot; class&#x3D;&quot;csd-icon icon-refresh&quot;&gt;&lt;&#x2F;html&gt;\n目标元素要改为input，因为要用到focus伪类.csd-icon.icon-refresh &#123;  width: 24px;  height: 24px;  padding: 0;  cursor: pointer;  position: absolute;  border:hidden;  background: url(&quot;data:image&#x2F;svg+xml,&quot; + map-get($icon,refresh) + &quot;&quot;) no-repeat top left;  right: 0;  &amp;:focus&#123;    outline: none;    animation: rotatefresh 1s;  &#125;  &amp;:active&#123;    animation: none;      &#x2F;&#x2F;background: &#39;#eee&#39;;  &#125;  @keyframes rotatefresh &#123;    from &#123; transform: rotate(0deg) &#125;    to &#123;        transform: rotate(180deg);        transition: all 0.6s;    &#125;  &#125;&#125;\n磨砂特效CSS秘密花园:磨砂玻璃效果减少异步使用形如background: url(‘../../icon.svg’)的样式无疑在渲染页面时又添加了异步调用，页面会出现从图片空缺到图片加载的’跳变’，可以用F12—Performance—Network：slow 3G如果是img:src可以直接把svg代码贴在页面上，优点是图像作为页面代码的一部分一次性从服务端获取，缺点是布局代码会被推至很下面，且svg代码的可读性比较差。另一种方式是将图片转为encodeURL贴在css中，这样使图片作为css的一部分从服务端获取css形如background: url(&quot;data:image&#x2F;svg+xml,%3Csvg%20width%3D%2218%22%20height%3D%2218%22%20viewBox...&quot;);\n一个在线转换工具见URL Decoder将源码\\…\\贴入，进行转码另用scss的预编译过程转换见sass-svgbox-sizing当元素特效使用2px border代替1px border时，发现元素宽高变化 布局略微‘抖动’应将box-sizing设为border-box另可考虑margin减1px另margin和box-sizing在flex布局下是无效的\n\n前端小智 CSS特效\nContainer Query文字对齐单行文字可以调整line-hight行内元素文字内容换行 会向上堆叠 元素高出其他行内元素，竖直方向对齐时，调整其他元素的vertical-align&lt;div class&#x3D;&quot;field-label&quot;&gt;content:&lt;&#x2F;div&gt;&lt;div class&#x3D;&quot;field-text&quot;&gt;blablablah&lt;&#x2F;div&gt;&lt;style&gt;  .field-label&#123;    display: inline-block;    width: 8em;    vertical-align: top;  &#125;  .field-text&#123;    display: inline-block;    width: 8em;    word-break: break-word;  &#125;&lt;&#x2F;style&gt;\n混合模式 mix-blend-modemix-blend-mode将所处位置的层叠像素叠加 可以叠加视频背景区别于text-fill-color\n三角triangle:&#123;    position:&#39;absolute&#39;,    top:42,    right:28,    width:0,    height:0,    backgroundColor:&#39;transparent&#39;,    borderWidth:10,    borderStyle:&#39;solid&#39;,    borderTopColor:&#39;transparent&#39;,    borderRightColor:&#39;transparent&#39;,    borderBottomColor:&#39;white&#39;,    borderLeftColor:&#39;transparent&#39;,    justifyContent:&#39;center&#39;,    alignItems:&#39;center&#39;&#125;\nCanvas 加载后出现滚动条\nhtml body需覆盖默认margin padding\n父元素100vw 100vh\n以父元素clientWidth clientHeight设置宽高\ncanvas默认是行内元素 受到 line-height 或 baseline 对齐的影响 需要 display:block\n\n","categories":["前端技术"],"tags":["CSS"]},{"title":"C# kernal常用方法","url":"/qqsnote/2020/07/27/CSharp-KernalMethod/","content":"[DllImport(&quot;kernel32.dll&quot;, CharSet &#x3D; CharSet.Auto, SetLastError &#x3D; true)]static extern bool SetDllDirectory(string lpPathName);protected override void OnStartup(StartupEventArgs e)&#123;    SetDllDirectory(AppContext.BaseDirectory + &quot;VisualEngine&quot;);    base.OnStartup(e);&#125;","categories":["后端技术"],"tags":[".Net","C#"]},{"title":"C#","url":"/qqsnote/2020/07/27/CSharp/","content":"编程概念Microsoft Docs: C#\n\n.NET 中的程序集 程序集是.net应用程序的最小部署单元。它可以是dll或exe。\n使用 Async 和 Await 的异步编程 (使用Task保存异步操作)\n特性 (Attribute)    将元数据或声明性信息与代码相关联。 关联的特性在运行时使用 反射 这项技术实现\n集合 (C#)    介绍了 .NET 提供的一些类型集合。 展示了如何使用简单的集合和键/值对集合。\n协变和逆变 (C#)    介绍了如何在接口和委托中启用隐式转换泛型类型参数。\n表达式树 (C#)    介绍了如何使用表达式树来启用动态修改可执行代码。\n迭代器 (C#)    介绍了用于单步执行集合并一次返回一个元素的迭代器。\n语言集成查询 (LINQ) (C#)    介绍了 C# 语言语法中强大的查询功能，以及用于查询关系数据库、XML 文档、数据集和内存中集合的模型。\n反射 (C#)    介绍了如何使用反射来动态创建类型实例、将类型绑定到现有对象，或从现有对象获取类型并调用其方法或访问其字段和属性。\n序列化 (C#)    还介绍了有关二进制、XML 和 SOAP 序列化的关键概念。object 值类型和引用类型 装箱拆箱值类型：\n简单类型\n结构体\n枚举\n存于栈中 自动释放\n不可派生引用类型\n类定义\n接口\nString\nArray\n存于堆 手动释放值类型转换为引用类型为装箱 反之为拆箱，装箱拆箱操作显著消耗系统资源 应当避免decimal因为float计算时有精度损耗，而且产生损耗时在程序中并不提示，于是创建decimal类型，付出额外的性能，进行高精度计算decimal d&#x3D;1.23M\nforeachforeach (Object item in items)&#123;    ...&#125;\nstring formatString result &#x3D; $&quot;the value is &#123;value&#125;&quot;\n见Mircrosoft Docs: C#字符串内插\n\nstring list 分隔String.Join(&quot;,&quot;, list)\nIEnumerable.Selectvm.children &#x3D; parentList.Select(parentItem &#x3D;&gt; parentItem.Child).ToList();\n初始化Objectresult.data &#x3D;new &#123;        List &#x3D; itemList,        Total &#x3D; itemsTotal &#125;;result &#x3D; await _context.OurBrand        .Where(brand &#x3D;&gt; brand.name !&#x3D; &quot;QQsIndustry&quot;)        .Select(brand&#x3D;&gt;new JObject&#123;&#123;&quot;name&quot;, brand.name&#125;, &#123;&quot;logo&quot;, brand.logo&#125;&#125;)        .ToListAsync();\n正则表达式及其校验string pattern &#x3D; @&quot;^[A-Z]&#123;4&#125;[AB0-9][0-9]&#123;3&#125;$&quot;;flag &#x3D; Regex.IsMatch(sn, pattern)\nHttpWebRequestpublic async Task&lt;MyResult&gt; SendHttpRequestAsync(string uri, Object postData, string token)&#123;        HttpWebRequest request &#x3D; WebRequest.CreateHttp(uri); &#x2F;&#x2F; TODO deal with exception        request.Headers.Add(&quot;Authorization&quot;, string.Format(&quot;Bearer &#123;0&#125;&quot;, token));    request.ContentType &#x3D; @&quot;application&#x2F;json&quot;;    request.Method &#x3D; @&quot;Post&quot;;    request.Host &#x3D; GetHost(uri);    request.Timeout &#x3D; 60000;    byte[] data &#x3D; Encoding.UTF8.GetBytes(JsonUtility.ObjToJson(postData));    request.ContentLength &#x3D; data.Length;    using (var stream &#x3D; request.GetRequestStream())    &#123;        stream.Write(data, 0, data.Length);    &#125;    try&#123;        using (WebResponse response &#x3D; await request.GetResponseAsync())        &#123;            using (var receiveStream &#x3D; response.GetResponseStream())            &#123;                using (var reader &#x3D; new StreamReader(receiveStream)) &#x2F;&#x2F; TODO deal with System.ArgumentNullException                &#123;                    if (reader !&#x3D; null)                    &#123;                        var responseString &#x3D; System.Web.HttpUtility.HtmlDecode(reader.ReadToEnd().Trim());                        return JsonUtility.JsonToObj&lt;MyResult&gt;(response);                    &#125;                &#125;            &#125;        &#125;    &#125;catch(WebException ex)&#123;        string message;        WebResponse errorResponse &#x3D; ex.Response;        if (errorResponse !&#x3D; null)        &#123;            using (Stream responseStream &#x3D; errorResponse.GetResponseStream())            &#123;                StreamReader reader &#x3D; new StreamReader(responseStream, Encoding.GetEncoding(&quot;utf-8&quot;));                message &#x3D; reader.ReadToEnd();            &#125;        &#125;else&#123;            throw new Exception(&quot;Unknown&quot;);        &#125;    &#125;&#125;\n上例中的发送/接收用了流读写的方式，估计这也是所有封装Http请求的通用原理，注意catch块中对WebException的处理，这样可以看到服务端返回的所有信息，相当于用postman调用失败后看到的错误信息，比error code 或 ‘Bad Request’描述丰富参考: StackOverflow: HttpWebRequest 400 Bad Request, HttpWebRequest详细用法\n文件接口IFormFile\nRegexemail 地址校验前进行域名转码try&#123;    email &#x3D; Regex.Replace(email, @&quot;(@)(.+)$&quot;, DomainMapper,                        RegexOptions.None, TimeSpan.FromMilliseconds(200));    &#x2F;&#x2F; Examines the domain part of the email and normalizes it.    string DomainMapper(Match match)    &#123;        &#x2F;&#x2F; Use IdnMapping class to convert Unicode domain names.        var idn &#x3D; new IdnMapping();        &#x2F;&#x2F; Pull out and process domain name (throws ArgumentException on invalid)        string domainName &#x3D; idn.GetAscii(match.Groups[2].Value);        return match.Groups[1].Value + domainName;    &#125;catch (RegexMatchTimeoutException e)&#123;    return false;&#125;catch (ArgumentException e)&#123;    return false;&#125;try&#123;    return Regex.IsMatch(email,        @&quot;^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$&quot;,        RegexOptions.IgnoreCase, TimeSpan.FromMilliseconds(250));&#125;catch (RegexMatchTimeoutException)&#123;    return false;&#125;IdnMapping.GetAscii:将包含 US-ASCII 字符范围以外的Unicode字符的域名称标签字符串编码为（U+0020 至 U+007E）内的可显示 Unicode 字符的字符串\nsealed classcatch whentry&#123;    await _dbContext.SaveChangesAsync();&#125;&#x2F;&#x2F; Is this error due to device SerialNumber constraint violation?catch (SqlUniqueConstraintViolationError ex) when (ex.Message.Contains(device.SerialNumber))&#123;    throw new DataException($&quot;A device with the same serial number (&#123;device.SerialNumber&#125;) already exist.&quot;, ex);&#125;\nHttp Requestusing System.IO;using System.Net;using System.Net.Http;using System.Text;using System.Threading.Tasks;using QQsProj.Models;namespace QQsProj.Utilities&#123;    internal class HttpUtility    &#123;        public static async Task&lt;string&gt; DoHttpRequestAsync(string host, string uri, string postData,                                                        string contentType, HttpMethod method,                                                        string token)        &#123;            HttpWebRequest request &#x3D; CreateHttpRequest(host, uri, method, contentType, token);            if (request &#x3D;&#x3D; null)            &#123;                return string.Empty;            &#125;            request.Timeout &#x3D; 60000;            if (postData !&#x3D; null)            &#123;                byte[] byte1 &#x3D; Encoding.UTF8.GetBytes(postData);                request.ContentLength &#x3D; byte1.Length;                using (var stream &#x3D; request.GetRequestStream())                &#123;                    stream.Write(byte1, 0, byte1.Length);                &#125;            &#125;            else            &#123;                request.ContentLength &#x3D; 0;            &#125;            try            &#123;                using (var response &#x3D; await request.GetResponseAsync())                &#123;                    using (var receiveStream &#x3D; response.GetResponseStream())                    &#123;                        using (var reader &#x3D; new StreamReader(receiveStream))                        &#123;                            if (reader !&#x3D; null)                            &#123;                                return System.Web.HttpUtility.HtmlDecode(reader.ReadToEnd().Trim());                            &#125;                        &#125;                    &#125;                &#125;            &#125;            catch (WebException ex)            &#123;                using (HttpWebResponse httpResponse &#x3D; (HttpWebResponse)ex.Response)                &#123;                    if (httpResponse !&#x3D; null &amp;&amp; httpResponse.StatusCode &#x3D;&#x3D; HttpStatusCode.Unauthorized)                    &#123;                        var strToken &#x3D; await EventManager.TokenExpired();                        return await DoHttpRequestAsync(null, uri, postData, contentType, method, strToken);                    &#125;                &#125;            &#125;            return null;        &#125;        private static HttpWebRequest CreateHttpRequest(string host, string uri, HttpMethod method,                                                        string conentType, string token)        &#123;            HttpWebRequest request &#x3D; WebRequest.CreateHttp(uri);            if (!string.IsNullOrEmpty(token))            &#123;                request.Headers.Add(&quot;Authorization&quot;, string.Format(&quot;Bearer &#123;0&#125;&quot;, token));            &#125;            request.ContentType &#x3D; conentType;            request.Method &#x3D; method.ToString();            if (!string.IsNullOrEmpty(host))            &#123;                request.Host &#x3D; host;            &#125;****            return request;        &#125;    &#125;&#125;\n反序列化JsonUtility.csusing System.IO;using System.Runtime.Serialization.Json;using System.Text;namespace QQsProj.Utilities&#123;    internal class JsonUtility    &#123;        public static string ObjToJson&lt;T&gt;(T obj)        &#123;            DataContractJsonSerializer serializer &#x3D; new DataContractJsonSerializer(obj.GetType());            string retVal &#x3D; string.Empty;            using (MemoryStream ms &#x3D; new MemoryStream())            &#123;                serializer.WriteObject(ms, obj);                retVal &#x3D; Encoding.UTF8.GetString(ms.ToArray());            &#125;            return retVal;        &#125;        public static T JsonToObj&lt;T&gt;(string json)        &#123;            T obj;            using (MemoryStream ms &#x3D; new MemoryStream(Encoding.Unicode.GetBytes(json)))            &#123;                DataContractJsonSerializer serializer &#x3D; new DataContractJsonSerializer(typeof(T));                obj &#x3D; (T)serializer.ReadObject(ms);            &#125;            return obj;        &#125;    &#125;&#125;调用：var res &#x3D; JsonUtility.JsonToObj&lt;List&lt;Account&gt;&gt;(response)其中Model.Account须标记属性如下using System;using System.Runtime.Serialization;namespace QQsProj.Models&#123;    [DataContract]    public class Account    &#123;        [DataMember(Name &#x3D; &quot;name&quot;)]        public string Name &#123; get; set; &#125;        [DataMember(Name &#x3D; &quot;emailAddress&quot;)]        public string EmailAddress &#123; get; set; &#125;        [DataMember(Name &#x3D; &quot;logo&quot;)]        public string Logo &#123; get; set; &#125;        [DataMember(Name &#x3D; &quot;addressId&quot;)]        public string AddressId &#123; get; set; &#125;        [DataMember(Name &#x3D; &quot;recordId&quot;, EmitDefaultValue &#x3D; false)]        public string RecordId &#123; get; set; &#125;        [DataMember(Name &#x3D; &quot;recordStatus&quot;, EmitDefaultValue &#x3D; false)]        public string RecordStatus &#123; get; set; &#125;        &#x2F;&#x2F;[DataMember(Name &#x3D; &quot;recordCreated&quot;)]        public DateTime RecordCreated &#123; get; set; &#125;    &#125;&#125;DataMember注解使Model的属性可以与json属性相互转化，此处因为时间类型牵扯到格式问题偷懒注释掉DataMember以避免报错，亦可在get set中进行具体时间格式转换EmitDefaultValue = false在Model转json时不自动初始化如”recordId”:null的键值对，以免于在接口中传输\n服务调用OData API，用HttpWebRequest.GetResponseAsync获取的string反序列化为目标Model的list，定义：ODataResponse.csusing System.Runtime.Serialization;namespace QQsProj.Models&#123;    [DataContract]    public class ODataResponse&lt;T&gt;    &#123;        [DataMember(Name &#x3D; &quot;value&quot;)]        public T[] Value &#123; get; set; &#125;        [DataMember(Name &#x3D; &quot;odata.metadata&quot;)]        public string Metadata &#123; get; set; &#125;    &#125;&#125;调用:var responseObj &#x3D; JsonUtility.JsonToObj&lt;ODataResponse&lt;CsfpPartner&gt;&gt;(response);if (null !&#x3D; responseObj.Value &amp;&amp; responseObj.Value.Length&gt;0)&#123;    res &#x3D; responseObj.Value[0];&#125;\nvolatileMicrosoft Docs 关键字\nnameof返回变量名称的字符串\n泛型public static void foo&lt;T&gt;(T parameter)&#123;    Console.WriteLine(&quot;parameter&#x3D;&#123;0&#125; type is &#123;1&#125;&quot;, paramater.toString(), parameter.GetType().Name)&#125;\nIEnumerable ICollection IQeurable List T[]IEnumerable是其他接口或实现的基类\n\nExposes the enumerator, which supports a simple iteration over a collection of a specified type. 暴露enumerator，支持在指定类型的集合上进行简单迭代\n\n并不常用IEnumerable声明变量，更多使用ICollection 使用ToList方法IEnumerable将其转换为ICollection：public interface ICollection&lt;T&gt; : IEnumerable&lt;T&gt;, IEnumerablepublic interface IList&lt;T&gt; : ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable public class List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable\nDictionary面试问题\n函数柯里化js柯里化求和const sum&#x3D;a&#x3D;&gt;b&#x3D;&gt;c&#x3D;&gt;(a+b+c) &#x2F;&#x2F; sum &#x3D; a &#x3D;&gt; (b &#x3D;&gt; (c &#x3D;&gt; (a+b+c))) sum(1)(1)(2)  &#x2F;&#x2F;res:4C#柯里化Func&lt;Int32, Func&lt;Int32, Int32&gt;&gt; sum &#x3D; x &#x3D;&gt; y &#x3D;&gt; x + y;Func&lt;Int32, Int32&gt; sumwith5 &#x3D; sum(5)\n异步编程模式\n基于任务(Task&lt;&gt;)的异步模式\n基于事件的异步模式 XXAsync(object sender, EventArgs e)\nIAsyncResult 模式（不建议）\n\n命名的惯例：Task&lt;string&gt; GetAsync()&#123;&#125;Task BeginProcess()&#123;&#125;\n多线程创建线程和结束线程wpf 关闭程序退出线程_多线程与高并发\n\nApplication.Shutdown(exitCode) 或因线程未结束 无法返回正确的exitCode\nSystem.Environment.Exit(exitCode) 强制关闭进程\n\nWhenAny WhenAll 类似响应式编程函数，分别为任意task返回、所有task返回，task的异常会抛出在相同层面 AggregateException 类\ncancellationTokenCancellationToken 线程取消信号 用于取消异步操作或长时间运行的同步操作The cancellation token to which you should respond to. See https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-cancellation for details.\n线程安全通用类型很少整体上是线程安全的，原因如下：\n\n开发成本 全线程安全的开发负担可能会很大，特别是如果一个类型有很多字段（每个字段在任意多线程上下文中都是潜在的交互）。\n可能会带来性能成本（无论该类型是否被多个线程实际使用，都需要付出一定的代价）。\n线程安全类型并不一定会使使用它的程序成为线程安全的，并且通常后者涉及的工作使前者变得多余。因此，线程安全通常在需要的地方实现，以便处理特定的多线程场景。lock\n\n委托Delegate\nC# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针, 是一种引用类型变量 \n\n作为函数方法的引用，委托用于将方法作为参数传给其他方法public delegate int MethodDelegate(int x, int y)public int Add(int x, int y) &#123; return x + y;&#125;public static void Main(string[] args)&#123;    MethodDelegate method &#x3D; new MethodDelegate(Add);    Console.WriteLine(method(10, 20));&#125;委托可通过+ -运算符进行组合，多个方法组合的委托为多播(multicast)委托\n如将回调函数传给System.Timers.Timer构造函数var timer &#x3D; new Timer(delegate &#123;    Dispatcher.Invoke(() &#x3D;&gt; &#123; lst.Add(DateTime.Now.ToString(); &#125;));&#125;, null, 3000, 1)其灵活性在于可以在既定的程序结构中更改函数方法的调用，类似于接口之于模块\nAction\\ 和 Func\\两个内置的泛型委托，唯一的区别在于Action没有范围值而Func必有返回值\n事件是特殊的委托————变量委托public delegate void DoSth(object sender, EventArgs e);public static event DoSth myDoSth;static void Print(object sender, EventArgs e)&#123;    Console.WriteLine(sender);&#125;...&#x2F;&#x2F; 注册事件响应DoSth d &#x3D; new DoSth(Print);object sender &#x3D; 10;EventArgs e &#x3D; new EventArgs();myDoSth +&#x3D; new DoSth(d);&#x2F;&#x2F;+&#x3D;委托（委托的实例化对象）myDoSth(sender, e);&#x2F;&#x2F;执行方法&#x2F;&#x2F;声明了事件myDoSth,事件的类型是DoSth这个委托&#x2F;&#x2F;通过 +&#x3D; 为事件注册委托&#x2F;&#x2F;通过DoSth委托的构造函数为事件注册委托实例&#x2F;&#x2F;采用委托变量(参数列表)这种形式，让事件执行方法\n","categories":["后端技术"],"tags":[".Net","C#"]},{"title":"CSharpRazor","url":"/qqsnote/2020/03/03/CSharpRazor/","content":"\nRazorEngine: Open source templating engine based on Microsoft’s Razor parsing engine.\n\nRazor文件类型Razor可以在vb.net和C#中使用。分别对应了两种文件类型，.vbhtml和.cshtml \nRazor的标识符@字符被定义为Razor服务器代码块的标识符，表示是服务器代码。web form中使用&lt;%%&gt;中写服务器代码一个道理。@&#123;    string userName&#x3D; &quot;邓星林&quot;;&#125; &lt;!-- 块级作用域 --&gt;&lt;span&gt;@userName&lt;&#x2F;span&gt;&lt;span&gt;@DateTime.Now.ToString(&quot;yyyy-MM-hh&quot;)&lt;&#x2F;span&gt;\nHTML@Href(“~/“)//表示网站的根目录\n@Html.Raw(Module.Content)  输出HTML\nRazor标识混合HTML@&#123;    &#x2F;&#x2F; html标签    &lt;div&gt;&lt;&#x2F;div&gt;    var str &#x3D; &quot;abc&quot;;    &#x2F;&#x2F; 下面会输出：this is a mail：dxl0321@qq.com, this is var: abc,this is mail@str,this is @；    @: this is a mail：dxl0321@qq.com, this is var: @str,this is  mail@str,this is @@；    &#x2F;&#x2F; 下面输出abc    @str&#125;\na.在作用域内如果是以html标签开始则视为文本输出\nb.如果要输出符号@，则使用@@\nc.如果要输出非html标签和非Razor语句的代码，则用@:，他的作用是相当于在处于html下面编写一样了，如在@：后面可以加上@就是表示Razor语句的变量\n注释@&#123;   @*       多行注释       多行注释   *@   var i &#x3D; 10;  @* asdfasf *@&#125;\nLayout 视图片段插入指定路径定义的布局视图模板@&#123;    ViewData[&quot;Title&quot;] &#x3D; &quot;分享优惠券管理&quot;;    Layout &#x3D; &quot;~&#x2F;Views&#x2F;Shared&#x2F;_Layoutv2.cshtml&quot;;&#125;&lt;div class&#x3D;&quot;main&quot;&gt;    ...&lt;&#x2F;div&gt;\n插入Page&lt;div class&#x3D;&quot;area&quot;&gt;    @RenderPage(&quot;&#x2F;b.cshtml&quot;)&lt;&#x2F;div&gt;\nSectionHelperhelper就是可以定义可重复使用的帮助器方法，不仅可以在同一个页面不同地方使用，还可以在不同的页面使用。@helper sum(int a,int b)&#123;     var result&#x3D;a+b;　　@result  &#125;&lt;div &gt;    &lt;p&gt;2+3&#x3D;@sum(2,3)&lt;&#x2F;p&gt;     &lt;p&gt;5+9&#x3D;@sum(5,9)&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;\n自带类型转换\nAsInt()\nIsInt()\nAsBool()\nIsBool()\nAsFloat()\nIsFloat()\nAsDecimal()\nIsDecimal()\nAsDateTime()\nIsDateTime()\nToString()\n\n","categories":["前端技术"],"tags":["C#"]},{"title":"CUDA","url":"/qqsnote/2024/06/14/CUDA/","content":"begining at this moment when Nvidia’s stock price was soaring 英伟达的股票飞涨不因为他生产的显卡，而是如今的人们开始意识到计算机运算势必会越来越多地以GPU并行量子运算地形式进行\n黄仁勋高超的前瞻眼光，高薪聘用伊恩·巴克（Ian Buck），并在2006年，NVIDIA正式发布了CUDA。CUDA是建立在NVIDIA GPU上的一个通用并行计算平台和编程模型，它的设计旨在让开发者能更容易地利用GPU的并行计算能力来加速原本由CPU处理的复杂计算任务。\nCUDA(Compute Unified Device Architecture)提供丰富的api及范例以便开发人员将\n"},{"title":"相机标定","url":"/qqsnote/2022/02/18/CameraCalibrate/","content":"输入棋盘图片路径 棋盘角点数（横纵方格数减1）def calibratePos(imgPath, w, h):    chessboardImg &#x3D; cv2.imread(imgPath)    chessboardImg &#x3D; cv2.cvtColor(chessboardImg, cv2.COLOR_BGR2GRAY)    ret, chessboard &#x3D; cv2.findChessboardCorners(chessboardImg, (w, h), None)    cv2.drawChessboardCorners(chessboardImg, (w, h), chessboard, ret)    # cv2.imwrite(&#39;calibrated_image.jpg&#39;, chessboardImg)    cv2.imshow(&#39;calibrated image&#39;, chessboardImg)    cv2.waitKey(0)\n","categories":["算法"],"tags":["算法"]},{"title":"ChromeTools","url":"/qqsnote/2020/03/27/ChromeTools/","content":"capture full size screenshot\nF12\nCtrl + Shift + P\ntype in capture full size screenshot\n\ndom process tipsFreeCodeCamp:你知道 Chrome 自带的开发者工具有这些功能吗\n\n$$(‘.className’) chrome自带元素选择器\n将页面作为文本进行编辑document.body.contentEditable &#x3D; true;\n获取事件以及监听事件\nconsole.time()console.time(&#39;heavy process&#39;)console.timeLog(&#39;heavy process&#39;, &#39;step1 finished&#39;)console.timeLog(&#39;heavy process&#39;, &#39;step2 finished&#39;)console.timeEnd(&#39;heavy process&#39;)\nconsole.table(array)\nconsole.assert(exp,’description’) 断言exp返回false时输出字符串使用chrome 模拟加载较慢网速\n\n\nF12\nNetwork Tab\nChange “Online” to “Slow 3G”页面元素断点第三方UI控件会动态添加元素事件，使用css的hover，focus无法触发，把光标放上去触发又无法查看code，设置element的breakpoint可以在指定元素被修改时break，无论查看js逻辑还是元素的样式变化都很方便headless chrome知乎：Headless Chrome入门 即不显示浏览器界面而在命令行运行Chrome功能，该模式主要用于自动化测试工具#### 响应式使用 Chrome DevTools 中的 Device Mode 模拟移动设备\n\nperformance","categories":["工具"],"tags":["Web开发"]},{"title":"Canvas-wordCloud","url":"/qqsnote/2021/04/25/Canvas-wordCloud/","content":"基础const canvas &#x3D; document.getElementById(&#39;canvas&#39;)const ctx &#x3D; canvas.getContext(&#39;2d&#39;)ctx.beginPath()ctx.arc(75,75,50,0,Math.PI*2,true);&#x2F;&#x2F;以(75, 75)为圆心50为半径绘制从0~2pi的圆弧，true为顺时针ctx.stroke() &#x2F;&#x2F;使用线条绘制图形轮廓 相对的fill是填充图形\n\ncanvas元素创造了一块固定的画布，它公开了一个或多个渲染上下文，其可以用来绘制和处理要展示的内容。getContext(‘2d’)提供了二维渲染上下文 并没有‘3d’参数，而是‘webgl’或‘webgl2’ 见GetContext MDN\nhexo tag cloudHexo plugin: hexo-tag-cloud该项目使用使用胶水语言(如swig)，将tagCanvas.js植入Hexo项目tagCanvas.js 库在本项目qqsnote中，并按hexo-tag-cloud的README示意的没有集成到sidebar,而是集成到了theme/next/layout/page.swig，并按tagCanvas.js 库文档示意设置了权重显示模式\n\n在屏幕上画一个立体球看一眼 吖猩的3D旋转球\n在球面的经纬焦点处绘制粒子，从球心到球半径R分n层纬度，2n经度，则共4n2+2n个点假设在每个点处放置半径r的粒子小球，小球在二维屏幕的投影用arc绘制填充即可，投影圆的位置为(x,y)，z=(R2-x2-y2)1/2有意思的来了：球在二维的投影，位置(远近z)反映在投影上是投影圆的半径(也可以进而根据这个比例设置opacity)，两个成像物体成像到固定像平面，像高r与物距l的关系是r’/r = (l-f)/(f-z)当l=2f时成像与物体等大 即r’=f/(f-z)*r&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;    &#x2F;&#x2F; init webgl    const canvas &#x3D; document.getElementById(&#39;wordCloud&#39;)    const ctx &#x3D; canvas.getContext(&#39;2d&#39;)    ctx.clearRect(0, 0, canvas.width, canvas.height);    const vpx &#x3D; canvas.width&#x2F;2 &#x2F;&#x2F; 圆心偏移原点(0,0) 使x，y不为负数    const vpy &#x3D; canvas.height&#x2F;2    const R &#x3D; 300    &#x2F;&#x2F; z: [-300 300]    f &#x3D; 600     opacity_min &#x3D; 0.3    const atoms&#x3D;[]    &#x2F;&#x2F; solid ball 经纬    &#x2F;&#x2F; 粒子    const atom &#x3D; function(x,y,z,r)&#123;        this.x &#x3D; x;        this.y &#x3D; y;        this.z &#x3D; z;        this.r &#x3D; r;    &#125;    atom.prototype.paint&#x3D;function()&#123;        ctx.save() &#x2F;&#x2F;?        ctx.beginPath()        const r_projection &#x3D; this.r*f&#x2F;(f-this.z) &#x2F;&#x2F; projection 投影        ctx.arc(vpx+this.x,vpy+this.y,this.r,0,Math.PI*2,true)        ctx.fillStyle&#x3D;&#96;rgba(255,255,255,$&#123;opacity_min + (R+this.z)&#x2F;2&#x2F;R&#125;)&#96;        ctx.fill()        ctx.restore()    &#125;    const N &#x3D; 5    for(let k&#x3D;-N; k&lt;&#x3D;N; k++)&#123; &#x2F;&#x2F; 2N+1个纬度        const R_latitude &#x3D; Math.pow(R*R - Math.pow(R*k&#x2F;N,2),0.5)        for(let i &#x3D; 0; i&lt;2*N; i++)&#123; &#x2F;&#x2F; 2N条经线            const x &#x3D; R_latitude*Math.cos(i*Math.PI&#x2F;N)            const y &#x3D; R_latitude*Math.sin(i*Math.PI&#x2F;N)            const z &#x3D; k&#x2F;N*R            const a &#x3D; new atom(x,y,z,1.5)            a.paint()            atoms.push(a)        &#125;    &#125;&lt;&#x2F;script&gt;\n如上相当于从z轴方向俯视一个球，了解另一种“撒点”方式:球坐标点(R, θ, φ)x = R  sinθ  sinφy = R  sinθ  cosφz = R  cosθθ不取0和180就可以避免出现‘南北极’(上面的算法中极点是一圈粒子重合在一起)设共N个粒子，i取[0, N)找一个f(i)取值(-1, 1) 作为cosθ 那就f(i) = 2(i + 1)/N - 1找一个g(i)\n旋转绕z轴 转过角度θ\n\n\\left[\n \\begin{matrix}\n   x' \\\\\n   y' \n  \\end{matrix}\n  \\right]=\n \\left[\n \\begin{matrix}\n   cosθ & -sinθ \\\\\n   sinθ & cosθ \n  \\end{matrix}\n  \\right]·\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y \n  \\end{matrix}\n  \\right]旋转矩阵的推导\n实际上绕z旋转在投影屏幕上就是同心圆环绕，并没有粒子的前后(z)不变，也难以用一个二维的变量控制，因此前辈们都使用将鼠标(x, y)的偏移对应并分解到绕x，y轴的旋转之实现旋转矩阵是相同的let angleX &#x3D; angleY &#x3D; 0function rotateX(angle)&#123;    atoms.forEach(atom&#x3D;&gt;&#123;        const y &#x3D; atom.y*Math.cos(angle) - atom.z*Math.sin(angle)         const z &#x3D; atom.y*Math.sin(angle) + atom.z*Math.cos(angle)        atom.y &#x3D; y        atom.z &#x3D; z     &#125;)&#125;function rotateY(angle)&#123;    atoms.forEach(atom&#x3D;&gt;&#123;        const z &#x3D; atom.z*Math.cos(angle) - atom.x*Math.sin(angle)         const x &#x3D; atom.z*Math.sin(angle) + atom.x*Math.cos(angle)        atom.z &#x3D; z        atom.x &#x3D; x     &#125;)&#125;function rolling()&#123; &#x2F;&#x2F; click事件，点击一下随机绕x或y转十分之一圆周    ctx.clearRect(0, 0, canvas.width, canvas.height);    if(Math.random()&gt;0.5)&#123;        rotateX(Math.PI&#x2F;36)    &#125;else&#123;        rotateY(Math.PI&#x2F;36)    &#125;    atoms.forEach(atom&#x3D;&gt;&#123;        atom.paint()    &#125;)&#125;根据鼠标偏移控制旋转角度canvas.addEventListener(&#39;mousemove&#39;,function(e)&#123;    var x &#x3D; e.clientX - vpx    var y &#x3D; e.clientY - vpy    angleX &#x3D; -x*0.00001    angleY &#x3D; -y*0.00001&#125;)对于博客，该事件加在body上，使整个页面上都可以响应鼠标位置，相应的应减去球心位置偏移 (canvas.offsetLeft + document.body.scrollLeft + document.documentElement.scrollLeft, canvas.offsetTop + document.body.scrollTop + document.documentElement.scrollTop)\nwindow.requrestAnimationFrame\n告诉浏览器:你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n\n因为渲染canvas和执行js不是一个线程，使用for循环来串起动画是行不通的，setInterval和setTimeout倒可以使用let startfunction animation(timestamp)&#123;    ctx.clearRect(0, 0, canvas.width, canvas.height);    if(!start)&#123;        start &#x3D; timestamp    &#125;    rotateX(angleX)    rotateY(angleY)    atoms.forEach(atom&#x3D;&gt;&#123;        atom.paint()    &#125;)    const elapsed &#x3D; timestamp - start    if(true)&#123;        requestAnimationFrame(animation)    &#125;&#125;requestAnimationFrame(animation)\n","tags":["javascript","canvas"]},{"title":"常见认证授权方式","url":"/qqsnote/2020/07/20/Common-Auth-Methods/","content":"参考前后端常见的几种鉴权方式\nBasic Authentication","categories":["协议和规范"],"tags":["认证&授权"]},{"title":"计算机图形学 光栅化","url":"/qqsnote/2024/11/05/ComputerGraphics-Resterization/","content":"几何图形渲染到有限分辨率的屏幕上 将图形划成其最小组成部分————片元 对于显示器 就是RGB像素点\n判断点是否在三角形内部顺序边向量叉乘同号\n","tags":["图形学"]},{"title":"CodeReview","url":"/qqsnote/2020/01/14/CodeReview/","content":""},{"title":"计算机图形学","url":"/qqsnote/2024/11/05/ComputerGraphics/","content":"RoadMap\n编程基础：C++， 设计模式 —&gt; C++ STL\n图形管线：WebGL —&gt; OpenGL\n项目实践：闫令琪GAMES101 GAMES202 GAME104 TA百人计划\n\n仿射变换和齐次坐标仿射变换：位移 缩放 旋转 错切(单一方向等比例缩放)\n仿射变换前后保持一致的“平直行” 即直线变换后仍然为直线 相互平行的关系变换后仍然平行\n齐次坐标是解决仿射变换中“平移无法用矩阵乘法表示”这一问题的关键。\n在二维空间中，一个笛卡尔坐标点 $(x, y)$ 对应的齐次坐标是一个三元组 $(x, y, 1)$。\n使用齐次坐标的二维变换矩阵现在，所有变换都可以表示为 $3 \\times 3$ 矩阵：\n\n平移:\nT(t_x, t_y) =\n\\begin{pmatrix}\n1 & 0 & t_x \\\\\n0 & 1 & t_y \\\\\n0 & 0 & 1\n\\end{pmatrix}\n缩放:\nS(s_x, s_y) =\n\\begin{pmatrix}\ns_x & 0 & 0 \\\\\n0 & s_y & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n旋转:\nR(\\theta) =\n\\begin{pmatrix}\n\\cos\\theta & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n组合变换:变换的顺序至关重要（通常不满足交换律）。例如，先缩放后旋转，与先旋转后缩放结果不同。要表示“先变换 $A$，再变换 $B$”，最终的变换矩阵为 $M = B \\cdot A$。例如，绕一个任意点 $(c_x, c_y)$ 旋转：\n平移至原点: $T(-c_x, -c_y)$\n绕原点旋转: $R(\\theta)$\n平移回去: $T(c_x, c_y)$总变换矩阵 $M = T(c_x, c_y) \\cdot R(\\theta) \\cdot T(-c_x, -c_y)$。\n\n\n\n三维仿射变换笛卡尔坐标点 $(x, y, z)$ 的齐次坐标为 $(x, y, z, 1)$。\n主要的三维仿射变换矩阵所有变换都由一个 $4 \\times 4$ 的矩阵表示。\n平移沿 $x, y, z$ 轴分别移动 $t_x, t_y, t_z$。\n\nT(t_x, t_y, t_z) =\n\\begin{pmatrix}\n1 & 0 & 0 & t_x \\\\\n0 & 1 & 0 & t_y \\\\\n0 & 0 & 1 & t_z \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}缩放在 $x, y, z$ 轴方向分别缩放 $s_x, s_y, s_z$。\n\nS(s_x, s_y, s_z) =\n\\begin{pmatrix}\ns_x & 0 & 0 & 0 \\\\\n0 & s_y & 0 & 0 \\\\\n0 & 0 & s_z & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}3.2.3 旋转旋转比二维复杂，因为需要指定旋转轴。我们使用右手坐标系。\n\n绕 X 轴旋转 $\\theta$ (Pitch):\nR_x(\\theta) =\n\\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & \\cos\\theta & -\\sin\\theta & 0 \\\\\n0 & \\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}\n绕 Y 轴旋转 $\\theta$ (Yaw):\nR_y(\\theta) =\n\\begin{pmatrix}\n\\cos\\theta & 0 & \\sin\\theta & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n-\\sin\\theta & 0 & \\cos\\theta & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}\n绕 Z 轴旋转 $\\theta$ (Roll):\nR_z(\\theta) =\n\\begin{pmatrix}\n\\cos\\theta & -\\sin\\theta & 0 & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}组合变换与二维相同，组合变换通过矩阵乘法实现，且顺序至关重要。例如，一个常见的场景相机的视图变换可以表示为 T * R * S 的形式，具体取决于实现方式。\n\n\ncamera: position lookat lookup\n视图变换 camera移动至原点 绕轴旋转 反向位移\n\n透视投影(锥形视场 近大远小) 正交投影(相机无限远 远近投影一致)\n\n\n旋转矩阵的转置即逆矩阵，这种矩阵为正交矩阵 \n采样 混叠 深度屏幕呈现图像的过程是以屏幕分辨率对原始图像采样的结果，当采样频率与图像频率相乘的结果呈现与原始形态不同的规律形态时即发生了混叠\n消除高频然后采样\nDLSS(Deep Learning Super Sampling)\n‘挤压’到投影空间 保留z轴分量的目的是根据投影结果深度 区分前后遮挡 投影计算的迭代过程中保留最小深度数据 复杂度O(n) 不适用于透明物体\n光照强度\nI_{\\text{diffuse}} = k_d \\cdot \\frac{I}{r^2} \\cdot max(0, \\mathbf{L} \\cdot \\mathbf{N})$k_d$为漫反射系数 光照强度与光源距离的平方成反比\nhttps://marmoset.co/posts/physically-based-rendering-and-you-can-too/https://marmoset.co/posts/basic-theory-of-physically-based-rendering/\n纹理映射纹理映射中随透视距离拉大 纹理图像缩小 若采样点不足 贴图出现混叠 远处呈现摩尔纹\nMipmap 多级纹理映射 生成级数下降的低分辨率纹理 根据投影距离映射不同分辨率纹理 结合滤波处理 削弱高频 \ntexture map在没有指定uv坐标的情况下 由引擎自动按照一定规则或重复或拉伸素材生成默认的uv坐标序列 这样映射出的纹理可能存在明显的失真和接缝\nblender等建模软件提供了自定义uv的功能 blender Doc: uv工具\n对于接缝可指定接缝处映射\nTexture can affact shading 类似蒙版用纹理深浅作用于面片法线(fake normal) 从而使之作用于光照 如凹凸贴图 法线贴图 物体边缘和自身投影会露馅 因为没有实际的起伏细节\n位移贴图 作用于顶点坐标 产生实际移动\n三维纹理 和 体渲染 CT影像\n几何体隐式表示和显式表示\n隐式表示方式：\n\n数学公式 如(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 = R^2a(x-x_0)+b(y-y_0)+c(z-z_0) = 0\nConstructive Solid Geometry—构造性立体几何(CSG) 即利用基础集合形体的交并关系\n距离函数\n水平集\n分形\n\n重心坐标已知三角形三个顶点的坐标$P_1, P_2, P_3$  则三角形内任一点可以用三个顶点坐标的线性组合表示 \nA = b_1P_1+b_2 P_2+b3 P_3且有 $b_1+b_2+b_3=1$\n贝塞尔曲线 任意t∈(0,1) 迭代二分控制点线段 得到点p(t) 其轨迹即贝塞尔曲线\n光栅化阴影从光源出发记录投影到光源的像素的深度信息 再从相机出发将投影到相机的像素深度信息与前者比较 深度值大则被遮挡 显示为阴影\n因为比较结果是二值化的 因此非黑即白 称为硬阴影 \n现实中 阴影应有过渡 称为软阴影 光栅化阴影只能通过一些边缘模糊手段模拟软阴影\n光线追踪计算模拟光线自光源射出经过反复的折射、反射、衰减，计算量巨大常用于影视渲染等非实时的场景\n","tags":["图形学"]},{"title":"复杂算法","url":"/qqsnote/2019/01/03/ComplexAlgorithm/","content":"P类问题(Polynomial Problem)简单的认为，P问题就是可以在多项式时间被图灵机判定的语言类。这里又涉及到图灵机，那么我们可以简单的认为，如果一个算法可以在多项式时间内求解，那么就可以认为它是P类问题。这样你就会感觉好多算法都是P类问题，对！没错！如何证明一个问题是否是P类问题呢？只要它满足以下两个条（证明它在多项式时间内完成）\n\n运行步骤数要有多项式上届时间\n每一步都要保证它可以由合理的确定模型在多项式时间内完成，其实就是每一步的求解过程也是多项式时间\n\n这样步骤是多项式时间的，而每一步也是多项式时间，整合起来整个算法还是多项式时间的。\nNP类问题(Non-deterministic Polynomial Problem)NP问题指的是，这个算法可以在多项式时间内可验证，什么意思呢？我们知道对于P类问题，可以在多项式时间内求解出来，但是NP问题不行。可以这样理解，NP虽然不能在多项式时间内被求解，但是如果给出这个问题的某个解，那么我们可以在多项式时间内验证这个解是不是这个问题的解。P是属于NP的，但是NP是否等于P是著名的千禧年七大难题之一 (有人说证明NP=P，相当于论证，世间万事皆有捷径)\nNPC(Non-deterministic Polynomial Complete Problem)","categories":["算法"],"tags":["算法"]},{"title":"ComputerScience","url":"/qqsnote/2024/03/27/ComputerScience/","content":"线程\nQ: java线程池和cpu线程数的关系\n\n文心一言：Java线程池与CPU线程数之间的关系主要体现在线程池如何根据系统的需求和硬件环境灵活地控制线程的数量，以及如何通过线程池管理线程来提高系统的运行效率并降低系统的运行压力。\n\n首先，线程池通过在初始化时创建一个线程集合，然后在需要执行新任务时重用这些线程，而不是每次都新建线程。这种方式减少了线程的创建和销毁开销，从而提高了系统的性能。\n\n其次，线程池可以控制并发的线程数量，这有助于避免因为线程数量过多而导致的系统资源耗尽或性能下降。线程池会根据任务的提交情况和系统的负载情况，动态地调整线程的数量，确保系统的稳定运行。\n\n在Java中，线程数通常模拟的是CPU的核心数，但需要注意的是，线程数并不等于CPU的物理核心数。一个CPU核心可以对应一个或多个线程，这取决于是否使用了超线程技术。通过超线程技术，一个物理核心可以模拟出两个逻辑线程，从而提高了CPU的并行处理能力。\n\n在设置线程池的大小时，需要考虑任务的性质。对于CPU密集型任务，如加密、解密、压缩和计算等，最佳线程数通常是CPU核心数的1~2倍。设置过多的线程并不会提升性能，反而可能导致性能下降，因为过多的线程会导致不必要的上下文切换。\n\n另一方面，对于耗时IO型任务，线程池的大小可能需要更大，以充分利用系统的IO能力。但是，这仍然需要考虑到系统的整体负载和资源限制。\n\n总的来说，Java线程池与CPU线程数之间的关系是一个动态平衡的过程，需要根据具体的任务需求、系统负载和硬件环境进行灵活的调整和优化。\n32位/64位操作系统32位、64位指的是CPU的GPRs（General-Purpose Registers，通用寄存器）如今计算机CPU基本上都是64位架构，运算能力是一次性64bit的整数运算，支持64位地址寻址和更大的内存\n当代码编译成exe时，x86平台编译出来的exe(可执行文件)或dll(动态链接库)都是32位的。类似的，x64对应的则是64位的。\nx86平台下编译的应用程序，而它所依赖的一个项目（或动态链接库）是由x64位平台编译出来的，则会提示“未能加载文件或程序集…或它的某一个依赖性。试图加载格式不正确的程序。”之类的错误。这是因为32位程序不能加载64位的dll，更不能调用其中的类、方法和对象等。\n如dotnet publish -f win-x86 打包的wpf应用，在已装有vcredist x64的计算机上无法启动，查看windows evnet viewer可看到.net运行时报错：CoreCLR Version: 6.0.2523.51912.NET Version: 6.0.25Description: The process was terminated due to an unhandled exception.Exception Info: System.IO.FileNotFoundException而安装vcredist x86后修复\n","tags":["操作系统"]},{"title":"C++ issues","url":"/qqsnote/2022/11/11/CppIssues/","content":"悬空指针即指针指向内容已被销毁某年月日 考虑到返回空结构体难以判断，遂返回nullptrMyExample::AdjustmentPop()&#123;    if(list.size&gt;0)&#123;        auto* struct_ptr &#x3D; &amp;list.back(); &#x2F;&#x2F; 返回最后一个元素的地址        list.pop_back();           &#x2F;&#x2F; 注意：此时 structt_ptr 指向的元素已被移除        return structt_ptr;       &#125;else&#123;        return nullptr;    &#125;&#125;当调用AdjustmentPop并访问指向的结构体内容时，其内容会突变为随机值\n","tags":["C++"]},{"title":"C++","url":"/qqsnote/2022/11/11/Cpp/","content":"C++ 为什么要先声明头文件\n\n声明而非定义：头文件通常包含的是声明（declarations），而不是定义（definitions）。这意味着它们告诉编译器某个变量、函数或类的存在及其类型（即静态类型），但不包括具体的实现细节。例如，函数的原型会告诉你函数的名字、返回类型和参数列表，但不会包含函数体。\n避免类型错误和未识别接口：通过在头文件中声明变量、函数和类的结构，编译器可以在编译阶段进行类型检查，确保代码中使用的变量和函数调用与它们的声明相匹配。这有助于提前发现类型错误，并确保所有接口都被正确识别。如果尝试使用一个没有在任何地方声明过的函数或变量，编译器将无法识别并报错。\n模块化设计和代码复用：头文件支持模块化设计，允许开发者将程序分割成多个逻辑部分。每个部分可以通过包含相应的头文件来访问其他部分的接口，而不需要了解其内部实现细节。这种方式不仅提高了代码的可读性和维护性，还促进了代码复用。\nc解决依赖关系：在大型项目中，不同源文件之间可能存在复杂的依赖关系。通过头文件，可以清晰地指定这些依赖关系，使得编译器能够正确解析跨文件的引用。\n提高编译效率：合理组织头文件可以帮助减少不必要的重新编译工作。比如，当修改了一个源文件时，只有直接或间接依赖于该源文件的其他文件需要重新编译，从而节省时间。成员函数的调用void res &#x3D; ClassA::functionX()ClassA a;void res &#x3D; a.functionX()\n\n\nvcpkg install libjpeg-turbo:x64-windows\n内联函数inline function编译时函数体会直接复制到 调用处（类似宏定义）是一种空间换时间的效率提升\n指针int a; int* p;p &#x3D; &amp;a;&#x2F;&#x2F; *p 相当于a的值\n禁写间接引用const int *p &#x3D; &amp;a;p&#x3D;&amp;b; &#x2F;&#x2F; 指针p指向可以修改&#x2F;&#x2F; *p&#x3D;1 非法 禁止操作*p &#x2F;&#x2F; 扩展 如果禁止修改指向 应声明为&#x2F;&#x2F; const int const* p &#x3D; &amp;a 声明时必须初始化&#x2F;&#x2F; 扩展 禁写指针即禁止修改指向 常指针&#x2F;&#x2F; int* const p &#x3D; &amp;a 可以操作*p修改a的值\ndebug在visual studio中open一个cpp文件，执行 Ctrl+F5 提示“Please Select a Valid Startup Item”一般要下载一个c语言编译器，并配置到vscode对于已经安装visual studio的环境，应能配置使用已有编译器\n类型安全类型安全指变量仅能访问权限匹配的内存区域。该概念区分编程语言和程序语境，C++是不具有类型安全的，因为在C++中，没有限制对于内存的解释方式，比如如int型的数据1，同时也可以解读为bool型的数据true，但是可以编程声明加以区分，使程序达成类型安全\n协程（存目）troubleshooting或出现error LNK2019: unresolved external symbol _Thrd_sleep_for类似错误 与编译器版本有关 应升级visual studio\n","tags":["C++"]},{"title":"跨域","url":"/qqsnote/2020/07/21/Cross-Origin/","content":"同源和跨域参考Enabling CORS in ASP.NET Core\n同源策略（Same Origin Policy）Web应用程序安全模型中的概念，具有相同的URL方案（HTTP或HTTPS），相同的主机名（域名）和相同的端口号（应用程序相互通信的端点），则认为它们具有相同的来源。同源策略要求请求的客户端（httpclient）应与服务器应用属于同一源点\n\n如果两个URL具有相同的URL方案（HTTP或HTTPS），相同的主机名（域名）和相同的端口号（应用程序相互通信的端点），则认为它们具有相同的来源。禁止跨域访问，目的是为了隔离潜在的恶意脚本，以免破坏Web上的其他文档\n\n如果服务器允许来自Origin（https://example.com）的跨域请求，则它将Access-Control-Allow-Origin标头设置为其值与请求中的源标头的值相匹配。如果服务器不包含此标头，则请求将失败。浏览器应接收响应数据，但是客户端不能访问该数据。\nStartup.cspublic void ConfigureServices(IServiceCollection services)&#123;    services.AddCors();    services.AddMvc();    ...&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123;    app.UseCors(x &#x3D;&gt; x    .AllowAnyOrigin()    .AllowAnyMethod()    .AllowAnyHeader());    ...&#125;\n","tags":["认证&授权"]},{"title":"DAC","url":"/qqsnote/2020/05/19/DAC/","content":"\n数据层应用程序 (DAC) 是一个逻辑数据库管理实体，用于定义与用户数据库关联的所有 SQL Server 对象，如表、视图和实例对象（包括登录名）。 DAC 是 SQL Server 数据库部署的一个自包含单元，它使数据层开发人员和数据库管理员能够将 SQL Server 对象打包到一个名为“DAC 包”（也称作 DACPAC）的可移植项目中。\n\n","categories":["数据库"],"tags":["sqlServer"]},{"title":"Cross-Platform-Development","url":"/qqsnote/2020/03/27/Cross-Platform-Development/","content":"Electron vs React Native\n","tags":["Web开发"]},{"title":"DICOM","url":"/qqsnote/2019/08/19/DICOM/","content":"参考CSDN zssure 文集。\n\n将DICOM协议当做是专属于医疗领域的“HTTP”传输协议，常见的HTTP协议是通过上表中的各种服务来实现浏览器与服务器之间HTML格式数据的传输；DICOM协议是通过上表中的各种服务实现了医疗设备与数据中心之间DCM格式数据的传输。\n\n\n\n\n\n对比\nHTTP\nDICOM\n\n\n\n\nOSI层\n应用层\n应用层\n\n\n数据\nHTML文件\n.DCM文件\n\n\n服务\nGET、POST、HEAD、PUT、DELETE、TRACE、CONNECT、OPTIONS\nC-ECHO、C-FIND、C-STORE、C-MOVE、C-GET、N-GET、N-SET、N-ACTION、N-CREATE、N-DELETE、N-EVENT-REPORT\n\n\n应用\n互联网B/S模式，也可以用于C/S模式\nC/S模式，也可以用于WADO(B/S模式)\n\n\n\n\n","categories":["图形学"],"tags":["医学图像"]},{"title":"DataBaseLock","url":"/qqsnote/2021/06/11/DataBaseLock/","content":"","categories":["数据库"],"tags":["数据库锁"]},{"title":"数字图像处理","url":"/qqsnote/2023/05/29/DIP/","content":"图像的线性变换基于图像矩阵与代数的点运算\n\nI_{out}(x, y) = a· I_{in}(x, y) + b\na=1, b=0: 恒等\na&lt;0: 黑白翻转\n|a|&gt;1: 增加对比度\n|a|&lt;1: 减小对比度\nb&gt;0: 增加亮度\nb&lt;0: 减小亮度\n\n"},{"title":"Data Lake","url":"/qqsnote/2021/03/31/DataLake/","content":"Philosophy湖是水源汇聚之处\n\nAzure Data Lake includes all the capabilities required to make it easy for developers, data scientists, and analysts to store data of any size, shape, and speed, and do all types of processing and analytics across platforms and languages. It removes the complexities of ingesting(插入) and storing all of your data while making it faster to get up and running with batch(批量), streaming, and interactive analytics.  ———— Azure Data Lake Solution\n\n","categories":["数据库"],"tags":["Azure"]},{"title":"数据结构和算法","url":"/qqsnote/2021/04/23/DataStructuresAndAlgorithms/","content":"数据结构——图各元素之间有路径 如a1 -&gt; a2, a2 -&gt; a4, a3 -&gt; a1\n根据路径的指向 给每个元素统计入度和出度\n例 寻找小镇法官问题\n题解即求是否存在入度为n出度为0的节点\n例 课程表问题：该学期必须选修 numCourses 门课程 课程存在的前置关系数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi]\n约定俗成地，用两个节点对表示图上的有向路径 某节点有多条路径 在图关系列表中 就有多项 包含该节点元素\n题解思路 入度为0的课程xi可直接选 以xi为前置的课程随后可选 以此类推 可选课程等于 numCourses 即可完成学期课程任务\n数据结构——堆(heap)数据结构中的堆是完全二叉树(从上到下、从左到右连续性) 通常依序以长列表的形式存储在计算机中\n若以1~n为序号 任意i∈n节点 左右子节点分别是2i，2i+1\n堆排序 就是将数据整理成大根堆(根节点均大于等于子节点)或小根堆(根节点均小于等于子节点)，js并不像C++、Java等面向对象语言提供了堆结构的Api, 堆排的js实现复杂 手写容易出错。且记堆排序时间复杂度O(nlogK) \n对于形似堆结构的题目 退而求其次使用sort api和循环计数的方式完成\n应用场景如 top K问题：找出数组中最大/小的count个数\n桶排序问题\n堆型数据结构的问题 有时可以用桶排序的方式解。 所谓桶排序 就是将项放到某集合中 通过对集合进行排序 筛选出解\n如 返回前k高频元素\n// 桶排var createBucket = (nums)=&gt;&#123;    // value - frequency Map    const map = new Map()    nums.forEach(val=&gt;&#123;        if(map.get(val))&#123;            map.set(val, map.get(val)+1)        &#125;else&#123;            map.set(val,1)        &#125;    &#125;)    //console.log(&#x27;map:&#x27;,map)    return map&#125;var topKFrequent = function(nums, k) &#123;    const map = createBucket(nums)    const arr = [] // 相同频次(freq)的value 归并到一起 作为arr的一项 该项放到arr的下标为req的位置    const res = []    map.forEach((freq,key)=&gt;&#123;        if(arr[freq])&#123;            arr[freq].push(key)        &#125;else&#123;            arr[freq] = [key]        &#125;    &#125;)    //console.log(&#x27;arr:&#x27;,arr)    for(i=arr.length-1;i&gt;=0&amp;&amp;res.length&lt;k;i--)&#123;        if(arr[i])&#123;            res.push(...arr[i])        &#125;    &#125;    return res&#125;\n数据结构——栈数据结构——队列数据结构——链表至少两部分：数据域&amp;指针域 链表没有索引 查找复杂度O(n)\nclass Node()&#123;    constructor(data)&#123;        this.data = data        this.next = null    &#125;&#125;const head = new Node(1)head.next = new Node(2)// 输出链表let point = headlet res = &#x27;&#x27;while(point)&#123; // 若链表有环 循环不会停止    res+=`$&#123;point.data&#125;-&gt;`    point = point.next&#125;console.log(res)\n检查链表是否有环\n\n节点放入集合(如Set)遍历中利用Set.has(point)检查是否存在此节点对象\n\n快慢指针 遍历环时必会套圈 无环则快指针先跳出循环\n\n\nfast = headslow = headwhile(fast &amp;&amp; fast.next)&#123;    slow = slow.next    fast = fast.next.next    if(fast === slow)&#123;        return true    &#125;&#125;return false\n双向链表 克服单向链表逆序查找困难的问题\nclass Snode&#123;    constructor(val,next = null)&#123;        this.data = val        this.next = next    &#125;&#125;class Dnode&#123;    constructor(val, perv = null, next = null)&#123;        this.data = val        this.next = next        this.prev = perv    &#125;&#125;// test caselet head = new Snode(null)let node = headfor(let val of [1,2,3,4,5])&#123;console.log(val)    node.next = new Snode(val)    node = node.next&#125;head = head.next// constructed test caseconst dhead = new Dnode(head.data)let point = headlet dpoint = dheadwhile(point.next)&#123;    dpoint.next = new Dnode(point.next.data, dpoint, null)    point = point.next    dpoint = dpoint.next&#125;console.log(dhead)\n数据结构——数组数据结构——矩阵数据结构——字符串数据结构——哈希表数据结构——二叉树遍历顺序(前、中、后)指的是根节点在遍历时的先后顺序 均为递归遍历 深度优先\n二叉树的广度优先遍历(层序遍历)\n算法——广度优先搜索(BFS)算法——深度优先搜索(DFS)算法——滑动窗口滑动窗口本质是双指针问题 一 在一个游标(指针)基础上 移动另一个游标 判断符合条件 然后分情况移动左右游标\n三数之和\n数组中任意三数之和 与目标数值最接近的\nfunction nearThreeSumary(arr, target) &#123;    arr.sort((a, b) =&gt; (a - b))    let distance = Number.MAX_VALUE    res = []    for (let i = 0; i &lt; arr.length-3; i++) &#123;        let left = i + 1        let right = arr.length - 1        while (left &lt; right) &#123;            const sum = arr[i] + arr[left] + arr[right]            if (Math.abs(target - sum) &lt; distance)                res = [arr[i], arr[left], arr[right]]            distance = target - sum            console.log([arr[i], arr[left], arr[right]], sum)            if (target &gt; sum) &#123;                left++            &#125; else if (target &lt; sum) &#123;                right--            &#125; else &#123;                return res            &#125;        &#125;    &#125;    return res&#125;\n两数之和的问题利用的就是left right双指针，三数之和的问题是在两数之和基础上固定一个。\n算法——动态规划(DP)爬楼梯问题被称为动态规划\n统计一步两步上楼方式 f(n) = f(n-1) + f(n-2)只是个简单的迭代方法\n每级台阶设上权重 即爬楼梯最小开支问题\n\n整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用(起点和终点不在数组中)。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n\n下面是个错误题解！迭代较大数组时计算开销激增 甚至测试用例运行超时\nvar minCostClimbingStairs = function(cost) &#123;    if(cost.length&lt;=1) return 0    // up1    const pay1 = minCostClimbingStairs(cost.slice(0,cost.length-1))  + cost[cost.length-1]    // up2    const pay2 = minCostClimbingStairs(cost.slice(0,cost.length-2))  + cost[cost.length-2]    return Math.min(pay1,pay2)&#125;;\n事实上 return f(n-1) + f(n-2) 的代码在统计上楼方式时已经存在问题 如下统计f(5)时，f(3)重复计算(称为重叠子) 当迭代层级增大时重复计算以指数激增\n        f(5)       /    \\    f(4)      f(3)   /    \\    /    \\f(3)  f(2)  f(2)  f(1) / \\f(2) f(1)\n为避免重复计算 要自低阶到高阶 将已经计算的结果(应称为子问题最优解或最优子，并非局部最优解)缓存起来 \nvar minCostClimbingStairs = function(cost) &#123;    const dp = []    dp[0] = 0    dp[1] = 0    for(let i=2;i&lt;=cost.length;i++)&#123;        dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2]+ cost[i-2])    &#125;    return dp[cost.length]&#125;;\nf(n) = f(n-1) + f(n-2) 斐波那契数列\n算法——二分查找典型的复杂度O(logN)的算法\n算法——双指针快慢指针\n对向指针\n算法——并查集算法——位运算算法——分治快排的本质也是分治\n返回第k大的数 数组值范围大 要求O(n)复杂度\nfunction findKmax(nums, k)&#123;        quickSort(nums, 0, nums.length-1)    function quickSort(nums, left, right)&#123;        // 枢轴        const pivot = nums.length-1        quickSort()    &#125;    function patition(arr, left, right)&#123;        const pivot = Math.floor(Math.random()*(right - left +1 ) + left)        let i = left, j = right        while(i&lt;=j)&#123;            while(arr[i]&lt;arr[pivot]) &#123;                i++            &#125;            while(arr[j]&gt;arr[pivot])&#123;                j--            &#125;            if(i&lt;=j)&#123;                [arr[i],arr[j]] = [arr[j], arr[i]]            &#125;        &#125;        return i    &#125;&#125;\n算法——回溯算法——贪心算法——递归算法——数学","tags":["算法"]},{"title":"DeepLearning","url":"/qqsnote/2022/01/20/DeepLearning/","content":"\n深度学习网络对输入的数据进行多层的非线性变换操作, 不断耦合低层特征, 层层往上, 最后得到高层的语义表达\n\n卷积神经网络模型gpt 175 billion netro cell\n资源白嫖限制试用的api使用cloud function实现外网gpt代理访问\n","tags":["AI"]},{"title":"设计模式原则","url":"/qqsnote/2021/08/04/DesignPatternPrinciples/","content":"简写为SOLID\n单一职责(Sigle Responsibility Principle)避免设计对象（类，方法）承担多项职责，在对职责1操作或修改时可能会造成职责2的异常。\n\n在需要if else时考虑划分为两个类或方法\n在需求变更导致职责细分时考虑将类或方法划分\n\n开放关闭(Open Closed Principle)设计对象应该根据需求被扩展，而不应该因需求而做修改，即对类进行抽象和继承违反开放关闭原则：class Factory &#123;    public Computer produceComputer(String type) &#123;        Computer c &#x3D; null;        if(type.equals(&quot;macbook&quot;))&#123;            c &#x3D; new Macbook();        &#125;else if(type.equals(&quot;surface&quot;))&#123;            c &#x3D; new Surface();        &#125;        return c;    &#125;   &#125;抽象出produce接口interface Factory &#123;    public Computer produceComputer();&#125;class AppleFactory implements Factory &#123;    public Computer produceComputer() &#123;        return new Macbook();    &#125;&#125;class MSFactory implements Factory &#123;    public Computer produceComputer() &#123;        return new Surface();    &#125;&#125;\n里氏替换(Liskov Substitution Principle)\n所有引用基类的地方必须能透明地使用其子类的对象。\n\nA的子类B继承父类时，不应改变原功能，只做扩展\n接口隔离(Interface Segregation Principle)合理设计接口的粒度，避免类型依赖它不需要的接口\n依赖倒置(Dependency Injection Principle)高层模块不应依赖低层模块，以免因为低层修改而牵扯高层，两者应该共同依赖接口，将改动限制在接口的实现上即最少知道，类型对其直接引用的对象A保持最少的了解，不会通过该对象与第三者对象B建立间接的调用关系，要求A将必要的方法封装为public提供外部调用，而不暴露其引用了B的事实\n23种设计模式\n","categories":["后端技术"],"tags":["设计模式"]},{"title":"DevOps-Database","url":"/qqsnote/2021/09/23/DevOps-Database/","content":"参考数据迁移，不停机上线的正确姿势\nstaging slot 切换新建staging库，从旧数据库同步数据，同步数据结束后在空闲时段停服，将流量切换至新库\n不停机\n准备新库 表结构更新或分库分表操作\n开启双写，服务端同时向新老两个库写入数据 此阶段需要联查历史数据进行写入的操作可以先查老数据库 再写入新库\n双写过程中，开始历史数据迁移，将某一时间点的历史数据迁移到新库，迁移范围要覆盖到双写数据范围以避免数据遗漏\n数据校验，确认没有遗漏 以及写入失败的个别情况\n开启双读，流量逐步过渡到新库\n关闭老库写功能\n删除双写双读等业务无关逻辑\n\n","categories":["数据库"],"tags":["DevOps"]},{"title":"DevOps-Overview","url":"/qqsnote/2020/12/10/DevOps-Overview/","content":"Azure DevOps Engineer Expert\n\nDevOps 是人员、流程和产品的集合体现，它可让我们向最终用户持续交付价值。 ———— Donovan Brown\n\nAzure DevOpsAzure DevOps 是 Microsoft 提供的一种软件即服务 (SaaS) 平台，它能提供用于开发和部署软件的端到端 DevOps 工具链。组成\n\nAzure Repos 源代码管理\nAzure Pipelines CI/CD服务\nAzure Boards 类似TP的kanban工具以及Agile tools等\nAzure Test Plans 测试工具，包括manual/exploratory testing 和 continuous testing\nAzure Artifacts 大致上就是构建自己的库(allows teams to share packages such as Maven, npm, NuGet and more from public and private sources and integrate package sharing into your CI/CD pipelines)\n\n生产DevOps的内容\n操作系统\n脚本\n容器\n云\n其他\n\n琐碎\nstaging vs deployment slot它们是两个不同层面、维度的概念，但它们经常被结合使用，以实现高效的软件发布流程。 \n\nstaging环境介于开发和生产之间的独立、隔离的运行环境。用于模拟生产环境以发现问题。deployment slot是云平台提供的 可运行同一个应用的多个版本（比如生产版和暂存版）亦可做蓝绿部署和版本回退\n","tags":["DevOps"]},{"title":"DevOps之基于Release的工作流","url":"/qqsnote/2020/12/10/DevOps-ReleaseWorkflow/","content":"对于branch对于敏捷开发的团队，选择避免使用长期分支(long-lived branch)，以致力于短期功能和 Bug 修复分支，任何工作付出的目标都是以生成pull request将工作合并回master\n\nA long-lived branch is a Git branch that is never deleted. Some teams prefer to avoid them altogether in favor of short-lived feature and bug fix branches. For those teams, the goal of any effort is to produce a pull request that merges their work back into master.对于web应用，往往不会支持或回退到起初的版本，适用于上述工作方式，但也有其他场景需要长期保留分支，如用于同时支持市场上的多个版本，release V1， release V2将持续维护\n\n来源微软Docs：GitHub基于Release的工作流\nmaster是稳定版分支，与线上版本保持绝对一致，release是预发布分支，从develop创建出来进行测试。\n关于release语义化版本标签release notes(存目)\n","tags":["DevOps"]},{"title":"设计图","url":"/qqsnote/2020/09/07/Diagrams/","content":"架构视图\n设计文档中要附有大量、各种各样的图，目的是为了与包括开发，项目，dba等角色达成更好的沟通\n\n逻辑视图\n开发视图\n过程视图（如泳道图）\n物理视图\n场景视图\n\n\nWireframe"},{"title":"数字签名","url":"/qqsnote/2022/09/30/DigitalSignature/","content":"使用 jenkins ant 自动化脚本调用build.xml任务&lt;?xml version&#x3D;&quot;1.0&quot; ?&gt;&lt;project basedir&#x3D;&quot;.&quot; default&#x3D;&quot;build_all&quot; name&#x3D;&quot;TestProj&quot;&gt;    &lt;description&gt;        TestProj Build File.    &lt;&#x2F;description&gt;    &lt;tstamp&gt;        &lt;format locale&#x3D;&quot;en&quot; pattern&#x3D;&quot;yyMMdd&quot; property&#x3D;&quot;TODAY_CN&quot;&#x2F;&gt;    &lt;&#x2F;tstamp&gt;\t\t&lt;property name&#x3D;&quot;build_ver&quot; Value&#x3D;&quot;1.0.5.0&quot; &#x2F;&gt;    &lt;target description&#x3D;&quot;Create publish folder&quot; name&#x3D;&quot;create_folder&quot;&gt;        &lt;delete dir&#x3D;&quot;$&#123;build_ver&#125;&quot; quiet&#x3D;&quot;true&quot;&#x2F;&gt;        &lt;mkdir dir&#x3D;&quot;$&#123;build_ver&#125;\\publish&quot;&#x2F;&gt;    &lt;&#x2F;target&gt;    &lt;target description&#x3D;&quot;Pack TestProj&quot; name&#x3D;&quot;sign_and_copy&quot;&gt;        &lt;exec dir&#x3D;&quot;.&quot; executable&#x3D;&quot;cmd.exe&quot;&gt;            &lt;arg line&#x3D;&quot;&#x2F;c&quot;&#x2F;&gt;            &lt;arg line&#x3D;&quot;.\\uac_cert\\signtool.exe sign &#x2F;f &quot;.\\uac_cert\\test.pfx&quot; &#x2F;p passwordxxx &#x2F;fd SHA256 &#x2F;t &quot;http:&#x2F;&#x2F;timestamp.digicert.com&quot; &quot;..\\TestProj\\bin\\Release\\TestProj.exe&quot;&quot;&#x2F;&gt;        &lt;&#x2F;exec&gt;        &lt;copy file&#x3D;&quot;..\\TestProj\\bin\\Release\\TestProj.exe&quot; overwrite&#x3D;&quot;true&quot; todir&#x3D;&quot;$&#123;build_ver&#125;\\publish&quot;&#x2F;&gt;\t\t&lt;copy file&#x3D;&quot;..\\TestProj\\bin\\Release\\Microsoft.Identity.Client.dll&quot; overwrite&#x3D;&quot;true&quot; todir&#x3D;&quot;$&#123;build_ver&#125;\\publish&quot;&#x2F;&gt;\t\t&lt;copy file&#x3D;&quot;..\\TestProj\\bin\\Release\\Newtonsoft.Json.dll&quot; overwrite&#x3D;&quot;true&quot; todir&#x3D;&quot;$&#123;build_ver&#125;\\publish&quot;&#x2F;&gt;\t\t&lt;zip destfile&#x3D;&quot;$&#123;build_ver&#125;\\publish.zip&quot; basedir&#x3D;&quot;$&#123;build_ver&#125;\\publish&quot; &#x2F;&gt;\t\t&lt;delete dir&#x3D;&quot;$&#123;build_ver&#125;\\publish&quot; quiet&#x3D;&quot;true&quot;&#x2F;&gt;    &lt;&#x2F;target&gt;    &lt;!-- Build All --&gt;    &lt;target description&#x3D;&quot;Build solution&quot; name&#x3D;&quot;build_all&quot;&gt;        &lt;antcall target&#x3D;&quot;create_folder&quot;&#x2F;&gt;        &lt;antcall target&#x3D;&quot;pack_pubclient&quot;&#x2F;&gt;    &lt;&#x2F;target&gt;&lt;&#x2F;project&gt;其中使用signtool.exe给构建生成的应用添加数字签名，签名密钥保存在pfx文件中 需使用password访问 \n\nissue: capicom.dll没有正确安装或者是没有注册\n\n加密API组件对象模型（Cryptographic API Component Object Model，capicom）微软Windows系统组件，用于以数字方式签署数据代码、验证数字签章、加密解密等，见CryptoAPI\n注册capicomRegsvr32 c:&#x2F;windows&#x2F;system32&#x2F;capicom.dll\n","tags":["加密","数字签名"]},{"title":"Docker_Container","url":"/qqsnote/2019/11/05/Docker-Container/","content":"启动一个Jenkins dockerdocker pull jenkinssudo mkdir &#x2F;var&#x2F;jenkins_homedocker run -d -u root --rm --name myjenkins -p 8080:8080 -p 50000:50000 -v &#x2F;var&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home --restart always jenkins\n说明\n\ndocker run启动一个container \n-d 后台运行\n-u root 以root权限执行 尤其对于jenkins 权限不足会影响持久化卷的访问\n—rm 容器退出后自动移除 实际上写这个会报与—restart always冲突\n—name myjenkins容器Name命名为myjenkins\n-p 8080:8080 -p 50000:50000 容器端口映射到宿主端口，前者是主机端口，后者是容器端口\n-v volume设置（详见“卷和持久化数据”）\n—restart always重启策略\njenkins 镜像\n\n参考 docker run命令\nDocker提供了3种预置网络配置：桥接、主机、无网络端口映射适应于桥接网络，是启动容器的默认网络设置，如果是主机网络，则可以直接使用主机上的剩余端口\njenkins升级在jenkins ui中upgrade 重启后无法访问 查看docker container log发现需要升级JDK版本\n由于我们启用jenkins时映射了宿主volume,不用担心丢失工作数据， 可以更新docker image 删除并重建容器\n如何进入无限重启的容器\n更新docker jenkins环境(jdk, ant)\n连接到容器docker attach [containerID]\ndocker exec -it [containerID] bash或sh\n前者是直接进入容器启动命令的终端，不开启新的进程，退出终端意味着容器命令被终结后者是打开一个新的终端(bash或sh)在容器终端键入 exit 退出\n使用Container ID 停止和重启等docker ps -adocker ps | grep jenkinsdocker stop&#x2F;restart iddocker rm id\n\nIssue：如何得知特定镜像需要的持久化卷配置，即我要创建哪些路径的映射呢？\n\ntomcat docker的卷设置docker run --name tomcat -p 8080:8080 -v $PWD&#x2F;test:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;test -d tomcat \n容器重连有的封装服务的容器是可以docker run -d 保持后台运行的，很多容器如ubuntu等，断开终端连接往往会结束运行，在docker ps -a中看到状态是Exited。启动容器并附加到当前进程docker start -a -i &#96;docker ps -q -l&#96;说明：docker start启动容器（需要名称或ID） -a附加到容器 -i交互模式docker ps列表容器 -q列表仅容器ID -l列表仅最后创建容器\n检索自腾讯云问答\n另，对于这种容器，可以保持一个“前台”的进程运行，如docker run ubuntu &#x2F;bin&#x2F;bash -c &quot;while true; do echo docker connected; sleep 5; done&quot; &#x2F;&#x2F; 每5s 输出一次\ndocker for mysql 5.7docker pull mysql:5.7docker run --name mysql_57_instance -v &#x2F;home&#x2F;qqs&#x2F;Workspace&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 -d mysql:5.7docker exec -it mysql_57_instance bashmysql -u root -p...\n\nContainers for the linked service will be reachable at a hostname identical to the alias, or the service name if no alias was specified.\n\n使用docker for mysql部署数据库，docker容器运行起后，不需要进入容器修改配置（事实上使用docker -it进入容器终端后，/etc/mysql/下面没有配置文件），在配置外部数据连接时，使用容器名代替localhost或127.0.0.1参考issue: SQLSTATE[HY000] [2002] Connection refused\n","categories":["容器"],"tags":["Docker"]},{"title":"Dockerfile","url":"/qqsnote/2020/03/16/DockerBuild/","content":"docker buildDockerfile是构建docker的脚本，docker Hub很多应用容器以Dockerfile方式分享。docker build -t tomcat8.5.51 .命令格式 docker build [option] [url]\n\n选项-t tomcat8.5.51将build完成的镜像命名为tomcat8.5.51\n. 是当前目录,即执行当前目录下的Dockerfile\n\n执行完成后可在 docker images中查到tomcat8.5.51\ndocker composeCompose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」\n我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如,要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。\nCompose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。\n安装docker-compose$ sudo curl -L &quot;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;v2.17.2&#x2F;docker-compose-$(uname -s)-$(uname -m)&quot; -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose$ sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose$ sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose菜鸟教程\n使用docker为某项开发封装开发环境（存目）","categories":["容器"],"tags":["Docker"]},{"title":"Docker入门","url":"/qqsnote/2019/10/31/DockerInstallation/","content":"容器\n容器时一种松散隔离(loosely, isolated)的环境，允许我们构建或运行软件包(software packages)。这些软件包包括源码和依赖，称为容器镜像。容器镜像是我们用于分发应用程序的单位。\n\n一般来说，下文只记录操作记录而不是详细步骤\n\nubuntu install docker\n\nusermod aG docker\n\n自动启动systemctl enable docker\n\n镜像列表docker image ls\n\n从Docker Hub搜索并下载镜像\n  docker search httpddocker pull httpd:latest\n\n这里的Docker Hub相当于npmjs.org仓库，镜像是容器的模板，镜像之于容器，如同class之于object。这里的httpd称为应用容器镜像，是包含指定应用的环境。\n\n  latest 是版本tag，下载非latest的指定版本镜像只能查Docker Hub\n\n删除镜像 docker image rm hello-world\n\n启动容器 docker container run [OPTIONS] IMAGE [COMMAND]\n  docker container run -it centos:latest &#x2F;bin&#x2F;bashdocker container ls\n查看日志（输出到当前终端）docker logs -f contianderId \n\ndocker CI/CD\n在 CI 流水线的“构建”阶段，执行 docker build 命令来生成一个包含你前端静态文件的镜像。\n\n为项目编写了多阶段构建的 Dockerfile；然后配置了 GitHub Actions，在代码推送到 develop 分支时自动构建 Docker 镜像并部署到测试服务器\n问：“你如何优化前端 Docker 镜像？”\n答：“我主要采用多阶段构建。第一阶段使用 node 镜像来安装依赖和构建，这个阶段会比较大；第二阶段我只复制第一阶段的 dist 静态文件到一个轻量的 nginx 镜像中。这样最终镜像体积可能只有 几十MB，而不是 1GB 以上。同时我会使用 .dockerignore 来排除不必要的文件。”\n","categories":["容器"],"tags":["Docker"]},{"title":"卷和持久化数据","url":"/qqsnote/2019/12/17/DockerVolume/","content":"\n数据分为持久化和非持久化两类。对于容器，非持久化数据从属其容器，生命周期与容器相同，删除容器时也会删除所有非持久化数据。如果希望自己的容器数据保存下来，需要将数据存储在卷上，卷与容器是解耦的，可以独立地创建并管理。\n\n在主机上创建Docker的卷，实质上是创建一个目录，使之能且只能被Docker进程修改，除了‘卷’，可使用绑定装载的方式在主机和容器间共享文件\n卷命令docker volume create myvoldocker volume ls &#x2F;&#x2F; 查看已创建地卷docker volume inspect myvol &#x2F;&#x2F; 查看指定卷详细信息docker volume rm myvol &#x2F;&#x2F; 删除指定卷docker volume prune &#x2F;&#x2F; 删除所有未装入容器使用的卷\n装入容器-v, —volumedocker run -d --name myjenkins -p 8080:8080 -p 50000:50000 -v &#x2F;var&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home --restart always jenkins用:分隔的3个field，卷名称 : 路径或文件 : 选项，通常只保留卷路径ro 即 readonly原文：\n\nIn the case of named volumes, the first field is the name of the volume, and is unique on a given host machine. For anonymous volumes, the first field is omitted.The second field is the path where the file or directory will be mounted in the container.The third field is optional, and is a comma-separated list of options, such as ro.\n\n上例中，-v /var/jenkins_home:/var/jenkins_home 两个field前者是宿主路径，后者是容器路径，即将jenkins用户数据保存到容器的/var/jenkins_home同时持久化到本地位于/var/jenkins_home的卷中\n引述 jenkins官网\n\n-v $HOME/jenkins:/var/jenkins_home would map the container’s /var/jenkins_home directory to the jenkins subdirectory within the $HOME directory on your local machine, which would typically be /Users//jenkins or /home//jenkins.\n\n—mountdocker run --name myjenkins -p 8080:8080 -p 50000:50000 \\ --mount source&#x3D;jenkins_home,target&#x3D;&#x2F;var&#x2F;jenkins_home,driver&#x3D;local --restart always jenkins用 , 分隔三个字段，卷名称，目标路径或文件，驱动。\n","categories":["容器"],"tags":["Docker"]},{"title":"ECMAScript","url":"/qqsnote/2018/08/27/ECMAScript6/","content":"ES6ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n基本数据类型基本类型：string, number, boolean, null, undefined, symbol, bigint。它们存储的是值本身。引用类型：Object。所有非基本类型都属于 Object 类型，包括 Array, Function, Date, Map, Set 等。它们存储的是对内存中一个对象的引用（地址）。\n模块化export require是CommonJS规范的方法,es6 引入了import，可以将模块中的对象部分引入，以减少开销，或者使用import  as objName from 引入文件所有对象CommonJS vs ES Modules:*nodejs是默认使用CommonJS的，其表现可见express的服务中，如”module.exports = AssetService;”以及”var AssetService = require(‘./AssetService’)”。而es6中用”import common from ‘@myRepo/core’”和”export ..”更多了解NodeJS Docs\n\nCaution: the semicolon at the end of the import is mandatory!\n\n/*util1.js*/export default&#123;    a:100&#125; \n/*index.js*/import util1 from &#x27;./util1.js&#x27;console.log(util1)\n动态引入\nimport(&#x27;/modules/my-module.js&#x27;)  .then((module) =&gt; &#123;    // Do something with the module.  &#125;);// ORlet module = await import(&#x27;/modules/my-module.js&#x27;);\n见MDN:import据说动态import的模块在打包时会自动分割，见React Docs: 代码分割\n关于声明&gt;\n\nlet 代替 var. 同一变量不能重复使用let声明, 否则报错\nconst是常量，区别于只读\n\nconst s = [1];s[0]=0;\n但是可以用Object.freeze()\nfunction freezeObj() &#123;  &quot;use strict&quot;;  const MATH_CONSTANTS = &#123;    PI: 3.14  &#125;;  Object.freeze(MATH_CONSTANTS)  try &#123;    MATH_CONSTANTS.PI = 99;  &#125; catch( ex ) &#123;    console.log(ex);  &#125;  return MATH_CONSTANTS.PI;&#125;const PI = freezeObj();\nObject.assign()&gt;\n\n将所有可枚举属性的值从一个或多个源对象复制到目标对象Object.assign(target, …sources)\n\nconst target = &#123; a: 1, b: 2 &#125;;const source = &#123; b: 4, c: 5 &#125;;const returnedTarget = Object.assign(target, source); // expected output: Object &#123; a: 1, b: 4, c: 5 &#125;\n用法用途\n\n浅拷贝 cloneObj = Object.assign({}, …sources)\n覆盖目标同名属性\n合并数组 实际上是覆盖序号属性值 即Object.assign([1,2,3], [4,5]) // [4,5,3]\n\n箭头函数表达式const squaredIntegers = arr.filter(item=&gt;&#123; return Math.floor(item)===item&amp;&amp;item&gt;0 ;&#125;).map(item=&gt;Math.pow(item, 2))\n箭头表达式牵扯到的一个知识点是“箭头表达式不会创建this”需知javascript this是区分运行环境的标记，见 阮一峰 JavaScript 的 this 原理，箭头表达式继承外层函数运行环境。\n\nQQs按：创建/生成this的说法只是方便记忆 事实上 this 是运行时调用的东西 箭头函数没有自己的this绑定 其运行时this永远指向到定义箭头函数的所在(即所谓词法作用域)的this\n\n关于省略，函数体只有一个return语句时，可省略return关键字和花括号\nfunc = x =&gt; &#123; return x+1;&#125;func = x =&gt; (x+1)\n剩余参数运算符（Rest Operator）使用Rest Operator定义参数数量可变的函数，参数将存入Rest Operator指定的变量指代的数组中\nfunction howMany(...args) &#123;  return &quot;You have passed &quot; + args.length + &quot; arguments.&quot;;&#125;console.log(howMany(0, 1, 2)); // You have passed 3 arguments\nconst sum = (function() &#123;  &quot;use strict&quot;;  return function sum(...args) &#123;    //const args = [ x, y, z ];    return args.reduce((a, b) =&gt; a + b, 0);  &#125;;&#125;)();console.log(sum(1, 2, 3)); // 6\n回顾下归并方法reduce，array.reduce(callback,[, initialValue])，callback接受以下参数：previousValue，前一次调用回调函数的返回值；currentValue当前处理的数组元素，currentIndex可选，当前数组元素下标；array可选，调用reduce()方法的数组。initialValue可选，作为第一次调用callback方法的previousValue参数\nvar arr = [6, 89, 3, 45];var maximus = Math.max.apply(null, arr); // returns 89maximus = Math.max(...arr); // returns 89arr0 = [...arr]console.log(arr0==arr)  // false\n异步归并方法\nconst groupedMeshes = await meshes.reduce(async (accP, mesh, index) =&gt; &#123;  const acc = await accP;  const group = isUpper(mesh) ? acc[0]: acc[1];  if(group.length==0)&#123;    group.push(mesh)  &#125;else&#123;    const newMesh = compute(mesh, group[0])    group.push(newMesh)  &#125;  return Promise.resolve(acc)&#125;, Promise.resolve([  new Array&lt;IMesh&gt;(),  new Array&lt;IMesh&gt;()]))\n上述代码的需求是，将一个集合中的Mesh进行分组运算，分组依据是Upper or Lower，组内运算时以第一个Mesh为基准，调整组内其他Mesh\n解构赋值（Destructuring Assignment）var voxel = &#123;x: 3.6, y: 7.4, z: 6.54 &#125;;const &#123; x, y, z &#125; = voxel; // x = 3.6, y = 7.4, z = 6.54\n或者将部分属性 voxel.x, voxel.y 存入指定变量 a, b\nconst &#123; x : a, y : b&#125; = voxel // a = 3.6, b = 7.4\n分离多余的变量\nlet postData = Object.assign(&#123; extraAttr:&#x27;extra&#x27; &#125;, dto);let &#123; extraAttr, ...entity &#125; = postData;\n嵌套对象（nested objects）\nconst tree = &#123;    text:&#x27;A&#x27;,    value:0,    parentNode:&#123;        text:&#x27;Root&#x27;,        value:-1    &#125;&#125;const &#123;parentNode:&#123;value:RootVal&#125;&#125; = tree;console.log(RootVal)\n数组\nconst [a, b,,, c] = [1, 2, 3, 4, 5, 6];console.log(a, b, c); // 1, 2, 5// use rest operatorconst [begining,...rest] = [1, 2, 3, 4, 5, 6];\n交换值\n[a, b] = [b, a];\n函数传参\nconst stats = &#123;  max: 56.78,  standard_deviation: 4.34,  median: 34.54,  mode: 23.87,  min: -0.75,  average: 35.85&#125;;const half = (function() &#123;  &quot;use strict&quot;;   return function half(&#123;max,min&#125;) &#123;    return (max + min) / 2.0;  &#125;;&#125;)();console.log(half(stats)); // 28.015\n函数返回多个值\nfunc = () =&gt; &#123;  return [1,2]&#125;const [x, y] = func()\n类似python中常用的返回多个结果，需要在调用函数时清楚的知道其返回的结果结构 实际上可能并不利于维护\nES9 剩余运算符可应用于解构语法\n幂运算符2**3Math.pow(2,3)// 右结合优先级2**3**2 // 不等于8的平方64 而是512Math.pow(2, Math.pow(3,2))-2**3 // Error 语法歧义\nMath函数扩展常用的Math.sigh返回正负符号(-1,0,1) Math.trunc直接移除小数部分\n字符串模块（Template Literals）String.prototype.format\n// source codeƒ ()&#123;  var e=arguments;  return!!this&amp;&amp;this.replace(/\\&#123;(\\d+)\\&#125;/g,function(t,n)&#123;return e[n]?e[n]:t&#125;)&#125;\n`xxx${str}xxx`模板\nresultDisplayArray = arr.map(item=&gt;&#123;   return `&lt;li class=&quot;text-warning&quot;&gt;$&#123;item&#125;&lt;/li&gt;` &#125;);\n标签函数\nfunction tag(strings, ...keys)&#123;&#125;tag`string1$&#123;key1&#125;string24&#123;key2&#125;`\n将模板中的字符串和变量分别再拎出来\n简化声明const person = &#123;  name: &quot;Taylor&quot;,  sayHello: function() &#123;    return `Hello! My name is $&#123;this.name&#125;.`;  &#125;&#125;;\n可写作\nconst person = &#123;  name: &quot;Taylor&quot;,  sayHello() &#123;    return `Hello! My name is $&#123;this.name&#125;.`;  &#125;&#125;;\nclass 以及 get set 以及superclass Book &#123;  constructor(author) &#123;    this._author = author;  &#125;  // getter  get writer()&#123;    return this._author;  &#125;  // setter  set writer(updatedAuthor)&#123;    this._author = updatedAuthor;  &#125;&#125;\nPromise&gt;\n\n区别于回调函数方式的异步编程方案， ES6将其写入语言标准。\n所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\n\nPromise对象的状态pending（进行中）、fulfilled（已成功）和rejected（已失败）只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\nfunction loadImageAsync(url) &#123;  return new Promise(function(resolve, reject) &#123;    const image = new Image();    image.onload = function() &#123;      resolve(image);    &#125;;    image.onerror = function() &#123;      reject(new Error(&#x27;Could not load image at &#x27; + url));    &#125;;    image.src = url;  &#125;);&#125;\n加载图片的异步过程，成功或失败时触发相应的事件(load,error)，resolve和reject刚好对应作为事件响应方法\nPromise 链式调用Promise可以链式调用是因为then()返回也是一个Promise，见手写Promise 注意是then(onFulfilled, onRejected)如果缺省onFulfilled，则第一个Promise中的结果不做任何保留，意义在于过程，如果onFulfilled=(result)=&gt;{ return newPromise(…)} 即将第一个Promise过程得到的result传入newPromise newPromise作为onFulfilled，resolve(newPromise)就将数据传递给了下一个过程，依次类推可以依次执行不同的异步操作\nPromise().then(…)的第二个参数可以捕捉异常，和链式调用最后的catch有和区别？\n\ncatch只是一个语法糖而己 还是通过then 来处理的，大概如下所示\n\nPromise.prototype.catch = function(fn)&#123;    return this.then(null,fn);&#125;\ngenerator以function*定义的生成器，与function的区别是除了return，其执行期间可以yield‘返回’多次\nfunction* foo(x) &#123;  yield x + 1;  yield x + 2;  return x + 3;&#125;\n斐波那契生成器\nfunction* fib(max) &#123;  var      t,      a = 0,      b = 1,      n = 0;  while (n &lt; max) &#123;      yield a;      [a, b] = [b, a + b];      n ++;  &#125;  return;&#125;\nfib(5)返回一个generator对象console输出形如fib {[[GeneratorStatus]]: “suspended”, [[GeneratorReceiver]]: Window}调用generator对象的next方法迭代\nvar f = fib(5);f.next(); // &#123;value: 0, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 1, done: false&#125;f.next(); // &#123;value: 2, done: false&#125;f.next(); // &#123;value: 3, done: false&#125;f.next(); // &#123;value: undefined, done: true&#125;\n也可以var x of fib(5)进行迭代，x即valuegenerator似乎是为了状态管理而生的工具,所谓状态管理，因为其表象是一步接一步(next)来的,后面步骤的结果有可能需要依赖前面一步的状态(比如成功或失败，抑或current result)async await是generator的语法糖\n关于迭代器和可迭代对象迭代器是使用next()方法实现迭代器协议(lterator protocal)的任意对象，如Array迭代器可以使用for of迭代的对象即可迭代对象\nES7Array.protorype.includesarray.includes(x) 相当于 array.indexOf(x)ES6中已添加了String.prototype.includes\n类似的还有startsWith endsWith 参数接受偏移量\nconst str = &#x27;Hello World&#x27;str.include(&#x27;W&#x27;) // truestr.indexOf(&#x27;W&#x27;)&gt;=0 // truestr.starsWith(&#x27;World&#x27;, 6)// truestr.indexOf(&#x27;World&#x27;)===6 //true\nString.prototype.repeat\n&#x27;*&#x27;.repeat(6) // ******\n指数运算符 **2 ** 2 // 42 ** 3 // 8\njs引擎（V8）对**的实现与Math.pow的运算结果是会有差别的\nES8字符串填充以指定字符/字符串/函数方式, 在首或尾填充字符串至特定长度\nstr.padStart(targetLength [, padString])str.padEnd(targetLength [, padString])\nObject.values, Object.entries获取对象属性值的集合\nconst obj = &#123; x: &#x27;xxx&#x27;, y: 1 &#125;;Object.values(obj); // [&#x27;xxx&#x27;, 1]\n其实现是for in，因此obj也可以是Array或string，其输出结果也是遍历逐个下标组成的集合。\n获取对象键值对的集合\nconst obj = &#123; x: &#x27;xxx&#x27;, y: 1 &#125;;Object.entries(obj); // [[&#x27;x&#x27;, &#x27;xxx&#x27;], [&#x27;y&#x27;, 1]]\nasync, awaitasync(asynchronous)异步\nawait(asynchronous wait)等待异步结果下面的代码结构被称作callback hell其需求是从input.xml文件中读取action，如果action=token，则读取注册表，验证token时效，其中读文件，xml转json，读注册表均为异步操作\n(function()&#123;  fs.readfile(&#x27;input.xml&#x27;,(err,data)=&gt;&#123;    if(err)&#123;      console.error(err)    &#125;else&#123;      regedit.list(&#x27;HKCU\\Software\\QQSTEST\\&#x27;,(err,data)=&gt;&#123;        if(err)&#123;          console.error(err)        &#125;else&#123;          xmlParser.parseString(data,(err,data)=&gt;&#123;            if(err)&#123;              console.error(err)            &#125;else&#123;              done(data)            &#125;          &#125;)        &#125;      &#125;)    &#125;  &#125;)&#125;)()\nfunction readfileAsync(filepath)&#123;  return new Promise((resolve,reject)=&gt;&#123;    fs.readFile(filepath,(err,data)=&gt;&#123;      if(err)&#123;        reject(err)      &#125;else&#123;        resolve(data)      &#125;    &#125;)  &#125;)&#125;(async function()&#123;  var fileData = &#x27;&#x27;;  await readfileAsync(&#x27;input.xml).then(data=&gt;&#123;    fileData=data;  &#125;,err=&gt;&#123;    console.log(err)  &#125;)  if(!fileData) return;  await readRegEditAsync(&#x27;&#x27;)&#125;)()\n在async声明的function内使用await, 执行时等待promise对象的结果，完成其resolve或reject操作后向下执行。\nCaution! 在forEach中加async await不能阻塞循环，事实上forEach回调函数无法跳出循环，不要在forEach里面使用async-await、break、return，在有相关需求的场景下使用for循环语法Q160解析\n见下文 ES 9 异步迭代\nES9异步迭代async function process(array) &#123;  for await (let i of array) &#123;    doSomething(i);  &#125;&#125;\nPromise.finallyiPromise.then(do_sth1).then(do_sth2).catch(err_handle).finally(complete_handle)\n在正则表达式中命名模式匹配结果模式指使用()封装的规则，在ES9中可以用(?\\)的方式封装，在之后的js逻辑中，可以使用命名变量\n// 将&quot;年-月-日&quot;改为&quot;月-日-年&quot;  const reDate = /(?&lt;year&gt;[0-9]&#123;4&#125;)-(?&lt;month&gt;[0-9]&#123;2&#125;)-(?&lt;day&gt;[0-9]&#123;2&#125;)/,  d = &#x27;2018-04-30&#x27;,  usDate = d.replace(reDate, &#x27;$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;&#x27;);\n正则表达式断言和反向断言见正则表达式\n正则表达式dotAll正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，使之匹配包含终止符的所有字符，例\n/hello.world/.test(&#x27;hello\\nworld&#x27;);  // false/hello.world/s.test(&#x27;hello\\nworld&#x27;); // true\n正则表达式 Unicode 转义转义语法\\p{…}\nconst reGreekSymbol = /\\p&#123;Script=Greek&#125;/u;reGreekSymbol.test(&#x27;π&#x27;); // true\nES10Ecmascript2025(ES16)Array.prototype.flat, flatMap可指定层次数（允许Infinity）迭代遍历，输出元素的集合 ———— 数组降维\nvar arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2); // [1, 2, 3, 4, 5, 6]```jsflat自动移除空项### Array.prototype.flatMap如array.map(callback)一样遍历每个元素，之后，把运算结果“压平”成一个数组，QQs：不如改叫mapFlat```js[1,2,3].flatMap(i=&gt;&#123;return new Array(i).fill(i)&#125;)// output: [1, 2, 2, 3, 3, 3]\nString.prototype.trimStart, trimEnd去除首/尾的空白字符\nObject.prototype.fromEntries是ES8 Object.entries 的反向操作\nString.prototype.matchAll返回匹配正则表达式的所有结果的集合\n新增基本数据类型 BigIntjs基本数据类型（值类型）已不止5种（ES6之后是六种）！ES10后一共有七种基本数据类型，分别是： String、Number、Boolean、Null、Undefined、Symbol、BigInt\n关于Symbol，生成唯一的值，用于不关心具体值(只需要用变量名区分即可)的场景 见知乎：JS 中的 Symbol 是什么？\n装饰器DecoratorAngular常见的@Component(), @Module()等，在Ts中已有规范ES6 提案 尚未标准化，js decorator或无法被浏览器适用，需使用babel打包并规范化其实质是将定义的方法(装饰器名即函数签名)添加到紧随其后的class, function的propotype上\n// 例如 mobx 中 @observer 的用法/** * 包装 react 组件 * @param target */function observer(target) &#123;    target.prototype.componentWillMount = function() &#123;        targetCWM &amp;&amp; targetCWM.call(this);        ReactMixin.componentWillMount.call(this);    &#125;;&#125;\n关注木易杨每日面试题Daily Interview Question\n","categories":["前端技术"],"tags":["javascript"]},{"title":"ElasticSearch","url":"/qqsnote/2021/04/02/ElasticSearch/","content":"参考https://www.cnblogs.com/dreamroute/p/8484457.html\n全文搜索引擎‘全文检索’不是ElasticSearch，ElasticSearch是一个开源的基于全文搜索引擎（Apache Lucene）的搜索和分析引擎。\n全文搜索引擎面向文档型存储，即插入其数据库的每条记录作为一个文档，搜索引擎为提取文档的词，生成索引，通过查询索引达到搜索目标文档的目的。这种先建立索引，再对索引进行搜索的过程就叫全文检索（Full-text Search）\n文档-类型-索引关系数据库：      ⇒ 数据库 ⇒ 表    ⇒ 行    ⇒ 列(Columns)\nElasticsearch：  ⇒ 索引(Index)   ⇒ 类型(type)  ⇒ 文档(Docments)  ⇒ 字段(Fields)  \n二叉树 倒排KibanaElasticSearch的可视化仪表盘\n","tags":["ElasticSearch"]},{"title":"Electron C++ 插件","url":"/qqsnote/2020/03/09/Electron-Cpp-Addon/","content":"Node.js 官方文档 C++ Addon\n\n基于Node.js c++ Addons机制对接动态链接库，以实现现有Node.js接口外的底层访问\n“Chromium和Node.js大部分的代码都是用c++实现的，所以理所当然地也可以用C++为它们开发插件。” ——— &lt;给electron做c开发的那些坑&gt;\n\nnode-gypGYP is short for ‘Generate Your Projects’，顾名思义，GYP工具用于生成在相应平台上的项目，如在windows平台上生成Visual Studio解决方案(.sln), Mac下则是XCode项目配置以及Scons工具。\n\nnode-gyp is a cross-platform command-line tool written in Node.js for compiling native addon modules for Node.js. It contains a fork of the gyp project that was previously used by the Chromium team, extended to support the development of Node.js native addons.node-gyp 用于编译nodejs原生addon模块的，跨平台的命令行工具，fork了Chromium team使用的gyp项目，该项目用户开发Node.js C++插件npm install -g node-gypnpm install --global --production windows-build-toolsCaution！安装过程中出现 issue#147 Hangs on Python is already installed, not installing again. 原因是VisualStudio有进程占用了相关工具链，结束VS进程并重新安装windows-build-tools即可\n\n当前版本node-gyp使用 vs2017 build tools而不支持2019版本，下文中记述了workaround\npython依赖\n支持v2.7, v3.5, v3.6, or v3.7 v3.8 （QQs已实践2.7，3.8）如果安装了多个版本 应使用下述命令注明python路径node-gyp &lt;command&gt; --python &#x2F;path&#x2F;to&#x2F;executable&#x2F;python抑或修改npm调用设置npm config set python &#x2F;path&#x2F;to&#x2F;executable&#x2F;python否则会调用默认版本（环境变量Path中指向的版本）\nbinding.gyp&#123;  &quot;targets&quot;: [    &#123;      &quot;target_name&quot;: &quot;hello&quot;,      &quot;sources&quot;: [ &quot;src&#x2F;hello.cc&quot; ]    &#125;  ]&#125;关于gyp配置，但凡要比hello world走的远，都需要阅读下列文档\n\n“Going Native” a nodeschool.io tutorial\n“Hello World” node addon example\ngyp user documentation\ngyp input format reference\n“binding.gyp” files out in the wild wiki page执行配置和构建node-gyp configure\n为当前平台生成相应的项目构建文件。 这会在 build/ 目录下生成一个 Makefile 文件（Unix 平台）或 vcxproj 文件（Windows平台）。node-gyp build\n生成编译后的 *.node 的文件。 它会被放进 build/Release/ 目录。Electron-rebuild开源社区提供，基于node-gyp进一步封装的工具，用于Electron原生模块的编译，不需要node-gyp的一些额外配置（头文件下载地址、版本映射等）npm i electron-rebuild --save-dev\npackage.json&quot;scripts&quot;: &#123;    ...    &quot;rebuild&quot;: &quot;electron-rebuild -f -w yourmodule&quot;  &#125;\n\n\nnode-pre-gyp\nnode-pre-gyp makes it easy to publish and install Node.js C++ addons from binaries.node-pre-gyp stands between npm and node-gyp and offers a cross-platform method of binary deployment.\n\nFeatures :\n\n使用node-pre-gyp命令行工具安装依赖二进制C++模块（install your package’s C++ module from a binary）\n使用node-pre-gyp模块动态引入js模块 require(‘node-pre-gyp’).find\n其他开发命令如 test, publish (详见—help)\n\n配置package.json\n\n依赖 + node-pre-gyp\n开发依赖 + aws-sdk\ninstall命令脚本 node-pre-gyp install —fallback-to-build\n声明需要的二进制模块&quot;dependencies&quot;  : &#123;    &quot;node-pre-gyp&quot;: &quot;0.6.x&quot;&#125;,&quot;devDependencies&quot;: &#123;    &quot;aws-sdk&quot;: &quot;2.x&quot;&#125;&quot;scripts&quot;: &#123;    &quot;install&quot;: &quot;node-pre-gyp install --fallback-to-build&quot;&#125;,&quot;binary&quot;: &#123;    &quot;module_name&quot;: &quot;your_module&quot;,    &quot;module_path&quot;: &quot;.&#x2F;lib&#x2F;binding&#x2F;&quot;,    &quot;host&quot;: &quot;https:&#x2F;&#x2F;your_module.s3-us-west-1.amazonaws.com&quot;&#125;\n这就是为什么英国人的项目使用npm install —build-from-source来打包addon的原理\n\n导学列表：\n\n编译一个hello QQs C++ Addon的实践\n可以交互的manager插件\n为什么CSActivation可以用 npm install —build-from-source 打包插件\n\n参考 Electron-利用DLL实现不可能\n编译方法官方example\n\nnan: C++-based abstraction between Node and direct V8 APIs.\nnapi: C-based API guaranteeing ABI stability across different node versions as well as JavaScript engines.\nnode-addon-api: header-only C++ wrapper classes which simplify the use of the C-based N-API.\n\n文件结构\nhello.ccbinding.gyppackage.json\n编译后的二进制插件的文件扩展名是 .node\n所有的 Node.js 插件必须导出一个如下模式的初始化函数：void Initialize(Local&lt;Object&gt; exports);NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)使用 node-gyp 构建插件时，使用宏 NODE_GYP_MODULE_NAME 作为 NODE_MODULE() 的第一个参数将确保会将最终二进制文件的名称传给 NODE_MODULE()。\nnode-gyp configure\n为当前平台生成相应的项目构建文件。 这会在 build/ 目录下生成一个 Makefile 文件（Unix 平台）或 vcxproj 文件（Windows平台）。node-gyp build生成编译后的 *.node 的文件。 它会被放进 build/Release/ 目录。\n关于VS2019 找不到C++ build tool的问题私以为比较好的workaround是创建一个用2017替代2019的shim,详见node-gyp issue#1663经实践可行\n关于rebuild ffi error的问题electron-rebuild issue#308\n需求：使用Crypt32加密（编码/解码）npm i ffi-napi ref ref-struct\n后面两个包是映射C语言类型的接口const fs &#x3D; require(&quot;fs&quot;);const ref &#x3D; require(&quot;ref&quot;);const ffi &#x3D; require(&quot;ffi-napi&quot;);const Struct &#x3D; require(&quot;ref-struct&quot;);const DATA_BLOB &#x3D; Struct(&#123;    cbData: ref.types.uint32,    pbData: ref.refType(ref.types.byte)&#125;);const PDATA_BLOB &#x3D; new ref.refType(DATA_BLOB);const Crypto &#x3D; new ffi.Library(&#39;Crypt32&#39;, &#123;    &quot;CryptUnprotectData&quot;: [&#39;bool&#39;, [PDATA_BLOB, &#39;string&#39;, &#39;string&#39;, &#39;void *&#39;, &#39;string&#39;, &#39;int&#39;, PDATA_BLOB]],    &quot;CryptProtectData&quot; : [&#39;bool&#39;, [PDATA_BLOB, &#39;string&#39;, &#39;string&#39;, &#39;void *&#39;, &#39;string&#39;, &#39;int&#39;, PDATA_BLOB]]&#125;);function encrypt(plaintext) &#123;    let buf &#x3D; Buffer.from(plaintext, &#39;utf16le&#39;);    let dataBlobInput &#x3D; new DATA_BLOB();    dataBlobInput.pbData &#x3D; buf;    dataBlobInput.cbData &#x3D; buf.length;    let dataBlobOutput &#x3D; ref.alloc(DATA_BLOB);    let result &#x3D; Crypto.CryptProtectData(dataBlobInput.ref(), null, null, null, null, 0, dataBlobOutput);        let outputDeref &#x3D; dataBlobOutput.deref();    let ciphertext &#x3D; ref.reinterpret(outputDeref.pbData, outputDeref.cbData, 0);    return ciphertext.toString(&#39;base64&#39;);&#125;;function decrypt(ciphertext) &#123;    let buf &#x3D; Buffer.from(ciphertext, &#39;base64&#39;);    let dataBlobInput &#x3D; new DATA_BLOB();    dataBlobInput.pbData &#x3D; buf;    dataBlobInput.cbData &#x3D; buf.length;    let dataBlobOutput &#x3D; ref.alloc(DATA_BLOB);    let result &#x3D; Crypto.CryptUnprotectData(dataBlobInput.ref(), null, null, null, null, 0, dataBlobOutput);    let outputDeref &#x3D; dataBlobOutput.deref();    let plaintext &#x3D; ref.reinterpret(outputDeref.pbData, outputDeref.cbData, 0);    return plaintext.toString(&#39;utf16le&#39;);&#125;;let text &#x3D; &quot;有死之荣，无生之耻&quot;;let ciphertext &#x3D; encrypt(text);let plaintext &#x3D; decrypt(ciphertext);console.log(&quot;text:&quot;, text);console.log(&quot;ciphertext:&quot;, ciphertext);console.log(&quot;plaintext:&quot;, plaintext);以上代码白嫖自Github node-ffi Issue#355 comments from Wackerberg 侵删\n","categories":["前端技术"],"tags":["Electron"]},{"title":"ElementUI","url":"/qqsnote/2020/03/04/ElementUI/","content":"\nElementUI, a Vue 2.0 based component library\nCaution! 限定的引入顺序：UI.css —&gt; template —&gt; vue.js —&gt; UI.js —&gt; vue controller 其中 template 和 vue.js 交换没有影响\n响应式栅格布局基础栅格，基于24划分。&lt;el-row&gt;  &lt;el-col :span&#x3D;&quot;6&quot;&gt;    &lt;div class&#x3D;&quot;grid-content bg-purple&quot;&gt;&lt;&#x2F;div&gt;  &lt;&#x2F;el-col&gt;  &lt;el-col :span&#x3D;&quot;6&quot;&gt;    &lt;div class&#x3D;&quot;grid-content bg-purple-light&quot;&gt;&lt;&#x2F;div&gt;  &lt;&#x2F;el-col&gt;  &lt;el-col :span&#x3D;&quot;6&quot;&gt;    &lt;div class&#x3D;&quot;grid-content bg-purple&quot;&gt;&lt;&#x2F;div&gt;  &lt;&#x2F;el-col&gt;  &lt;el-col :span&#x3D;&quot;6&quot;&gt;    &lt;div class&#x3D;&quot;grid-content bg-purple-light&quot;&gt;&lt;&#x2F;div&gt;  &lt;&#x2F;el-col&gt;&lt;&#x2F;el-row&gt;间隔（ :gutter ）栅格之间的水平间距&lt;el-row :gutter&#x3D;&quot;20&quot;&gt;  ...&lt;&#x2F;el-col&gt;偏移（ :offset ）&lt;el-col :span&#x3D;&quot;6&quot; :offset&#x3D;&quot;6&quot;&gt;&lt;div class&#x3D;&quot;grid-content&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;el-col&gt;弹性盒子（ flex ）&lt;el-row type&#x3D;&quot;flex&quot; justify&#x3D;&quot;center&quot; align&#x3D;&quot;center&quot;&gt;    ...&lt;&#x2F;el-row&gt;水平值：start, center, end, space-between, space-around垂直值：top, middle, bottom\n\n响应式( Responsive )&lt;el-col :xs&#x3D;&quot;4&quot; :sm&#x3D;&quot;6&quot; :md&#x3D;&quot;8&quot; :lg&#x3D;&quot;9&quot; :xl&#x3D;&quot;11&quot;&gt;    &lt;div class&#x3D;&quot;grid-content&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;el-col&gt;隐藏\n\nhidden-xs-only - 当视口在 xs 尺寸时隐藏\nhidden-sm-only - 当视口在 sm 尺寸时隐藏\nhidden-sm-and-down - 当视口在 sm 及以下尺寸时隐藏\nhidden-sm-and-up - 当视口在 sm 及以上尺寸时隐藏Form表单&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;el-form ref&#x3D;&quot;form&quot; :model&#x3D;&quot;formData&quot; :rules&#x3D;&quot;formValidators&quot; label-width&#x3D;&quot;80px&quot;&gt;        &lt;el-form-item label&#x3D;&quot;title&quot; prop&#x3D;&quot;title&quot;&gt;            &lt;el-input v-model&#x3D;&quot;formData.title&quot;&gt;&lt;&#x2F;el-input&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item label&#x3D;&quot;Date&quot;&gt;            &lt;el-col :span&#x3D;&quot;11&quot;&gt;                &lt;el-date-picker type&#x3D;&quot;date&quot; placeholder&#x3D;&quot;Pick a date&quot; v-model&#x3D;&quot;formData.date1&quot; style&#x3D;&quot;width: 100%;&quot;&gt;                &lt;&#x2F;el-date-picker&gt;            &lt;&#x2F;el-col&gt;            &lt;el-col class&#x3D;&quot;line&quot; :span&#x3D;&quot;2&quot;&gt;-&lt;&#x2F;el-col&gt;            &lt;el-col :span&#x3D;&quot;11&quot;&gt;                &lt;el-time-picker placeholder&#x3D;&quot;Pick a time&quot; v-model&#x3D;&quot;formData.date2&quot; style&#x3D;&quot;width: 100%;&quot;&gt;                &lt;&#x2F;el-time-picker&gt;            &lt;&#x2F;el-col&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item label&#x3D;&quot;Subscribe&quot;&gt;            &lt;el-switch v-model&#x3D;&quot;formData.isSubscribe&quot;&gt;&lt;&#x2F;el-switch&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item label&#x3D;&quot;TAG&quot;&gt;            &lt;el-checkbox-group v-model&#x3D;&quot;formData.tags&quot;&gt;                &lt;el-checkbox label&#x3D;&quot;Activity&quot; name&#x3D;&quot;type&quot;&gt;&lt;&#x2F;el-checkbox&gt;                &lt;el-checkbox label&#x3D;&quot;Bonus&quot; name&#x3D;&quot;type&quot;&gt;&lt;&#x2F;el-checkbox&gt;                &lt;el-checkbox label&#x3D;&quot;Online&quot; name&#x3D;&quot;type&quot;&gt;&lt;&#x2F;el-checkbox&gt;            &lt;&#x2F;el-checkbox-group&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item label&#x3D;&quot;Comments&quot;&gt;            &lt;el-input type&#x3D;&quot;textarea&quot; v-model&#x3D;&quot;formData.Comments&quot;&gt;&lt;&#x2F;el-input&gt;        &lt;&#x2F;el-form-item&gt;        &lt;el-form-item&gt;            &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;onSubmit&quot;&gt;Create&lt;&#x2F;el-button&gt;            &lt;el-button&gt;Cancel&lt;&#x2F;el-button&gt;        &lt;&#x2F;el-form-item&gt;    &lt;&#x2F;el-form&gt;&lt;&#x2F;div&gt;\nvar Main &#x3D; &#123;    data() &#123;        return &#123;            formData: &#123;                title: &#39;&#39;,                date1: &#39;&#39;,                date2: &#39;&#39;,                isSubscribe: false,                tags: [],                Comments: &#39;&#39;            &#125;,            formValidators: &#123;                title: [&#123;                        required: true,                        message: &#39;请输入标题&#39;,                        trigger: &#39;blur&#39;                    &#125;,                    &#123;                        min: 3,                        max: 5,                        message: &#39;长度在 3 到 5 个字符&#39;,                        trigger: &#39;blur&#39;                    &#125;                ]            &#125;        &#125;    &#125;,    methods: &#123;        onSubmit(event) &#123;            this.$refs[formName].validate((valid) &#x3D;&gt; &#123;                if (valid) &#123;                    console.log(event);                    console.log(this.formData)                &#125; else &#123;                    console.log(&#39;validate fail&#39;);                    return false;                &#125;            &#125;);        &#125;    &#125;&#125;var Ctor &#x3D; Vue.extend(Main)new Ctor().$mount(&#39;#app&#39;)\n以上几乎就是官网的example，官方文档未给出submit事件触发form action的表单提交方式，api文档中未提及action属性。有资料表示存在“ this.$refs.formName.submit ”（QQs未验证）\n这种方式也造成了做表单校验时，要在提交方法中调用form.validate，form.validate又是个异步操作，后续动作（一般是http post）要放在其回调函数中而在我大Angular的响应式表单中，ngSubmit监听FormGroup当前值，在校验不通过时将禁用type=”submit”提交按钮\n\n\n\n如上例所示，表单验证需添加表单的:rules属性，表单项的prop属性（注意在label，值同name），提交方法中调用form.validate\nTable&lt;template&gt;    &lt;el-table :data&#x3D;&quot;tableData&quot; border style&#x3D;&quot;width: 100%&quot;&gt;        &lt;el-table-column fixed prop&#x3D;&quot;date&quot; label&#x3D;&quot;日期&quot; width&#x3D;&quot;150&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column prop&#x3D;&quot;name&quot; label&#x3D;&quot;姓名&quot; width&#x3D;&quot;120&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column prop&#x3D;&quot;address&quot; label&#x3D;&quot;地址&quot; width&#x3D;&quot;300&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column prop&#x3D;&quot;zip&quot; label&#x3D;&quot;邮编&quot; width&#x3D;&quot;120&quot;&gt;        &lt;&#x2F;el-table-column&gt;        &lt;el-table-column fixed&#x3D;&quot;right&quot; label&#x3D;&quot;操作&quot; width&#x3D;&quot;100&quot;&gt;            &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;                &lt;el-button @click&#x3D;&quot;handleClick(scope.row)&quot; type&#x3D;&quot;text&quot; size&#x3D;&quot;small&quot;&gt;查看&lt;&#x2F;el-button&gt;                &lt;el-button type&#x3D;&quot;text&quot; size&#x3D;&quot;small&quot;&gt;编辑&lt;&#x2F;el-button&gt;            &lt;&#x2F;template&gt;        &lt;&#x2F;el-table-column&gt;    &lt;&#x2F;el-table&gt;&lt;&#x2F;template&gt;\nvar Main &#x3D; &#123;    data() &#123;        return &#123;            tableData: [&#123;                date: &#39;2016-05-02&#39;,                name: &#39;王小虎&#39;,                address: &#39;上海市普陀区金沙江路 1518 弄&#39;,                zip: 200333            &#125;, &#123;                date: &#39;2016-05-04&#39;,                name: &#39;王大虎&#39;,                address: &#39;上海市普陀区金沙江路 1517 弄&#39;,                zip: 200333            &#125;]        &#125;    &#125;,    methods: &#123;        handleClick(row) &#123;            console.log(row);        &#125;    &#125;&#125;var Ctor &#x3D; Vue.extend(Main)new Ctor().$mount(&#39;#app&#39;)\n比较有意思的是这个el-table-column label可以设置 多级表头\n","tags":["ElementUI"]},{"title":"加密","url":"/qqsnote/2019/07/19/Encryption/","content":"对称加密 Symmetric Encryption共享密钥加密 私钥加密算法。加密和解密时使用相同密钥，或是使用两个可以简单相互推算的密钥。事实上，这组密钥成为双方或多个成员之间的共同秘密，以便维持专属的通讯联系。\n要求雙方取得相同的密鑰是對稱密鑰加密的主要缺點之一对称加密的速度比公钥加密快很多，在很多场合都需要对称加密。\n進階加密标准（Advanced Encryption Standard，AES），对称加密中最流行的算法之一。\n非对称加密公开密钥密码，公钥加密算法。要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密，另一个则用作解密。使用其中一个密钥拿明文加密后所得密文，只能用相对应个另一个密钥才能解密得到原本明文；甚至连最初用来加密个密钥也不能解。\nRSA是最具影响力的非对称加密算法，三个字母是三位创始人的姓氏首字母。RSA算法基于一个十分简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。\n阮一峰的文章\nRSA算法原理1\nRSA算法原理2\n非对称加密另有一个用途是数字签名\nDigital Signature网站对敏感内容使用私钥生成摘要信息，该信息使用公钥解密后可以证实为由私钥所生成（?），且反映内容是否已被篡改，故可作为数字签名\n为避免不怀好意的第三方冒充网站，提供公钥并发送密文给客户，应运而生”证书中心”（certificate authority，CA）。CA使用其私钥为官方公钥及其他信息加密，生成数字证书（Digital Certificate）。客户使用CA提供的公钥从数字证书中获取真实的网站公钥。\nhttps协议客户端向服务器发出加密请求。\n服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。\n客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。\n如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告”此网站的安全证书有问题 单击此处关闭该网页 继续浏览此网站（不推荐）”。\n","categories":["算法"],"tags":["加密"]},{"title":"EventBus","url":"/qqsnote/2025/08/25/EventBus/","content":"以发布订阅实现的消息中转 如\n\neventbus = new Vue()\nng emit on…常称事件总线\n\nclass EventBus &#123;  constructor() &#123;    this.events &#x3D; &#123;&#125;; &#x2F;&#x2F; 存储事件和对应的回调函数列表 eventKey - Array&lt;callback&gt;  &#125;  &#x2F;&#x2F; 订阅事件  on(eventName, callback) &#123;    if (!this.events[eventName]) &#123;      this.events[eventName] &#x3D; [];    &#125;    this.events[eventName].push(callback);  &#125;  &#x2F;&#x2F; 发布事件  emit(eventName, data) &#123;    if (this.events[eventName]) &#123;      this.events[eventName].forEach(callback &#x3D;&gt; &#123;        callback(data);      &#125;);    &#125;  &#125;  &#x2F;&#x2F; 取消订阅  off(eventName, callback) &#123;    if (this.events[eventName]) &#123;      this.events[eventName] &#x3D; this.events[eventName].filter(        cb &#x3D;&gt; cb !&#x3D;&#x3D; callback      );    &#125;  &#125;  &#x2F;&#x2F; 只订阅一次  once(eventName, callback) &#123;    const wrapper &#x3D; (data) &#x3D;&gt; &#123;      callback(data);      this.off(eventName, wrapper);    &#125;;    this.on(eventName, wrapper);  &#125;&#125;&#x2F;&#x2F; 使用示例const bus &#x3D; new EventBus();&#x2F;&#x2F; 订阅事件bus.on(&#39;sayHello&#39;, (data) &#x3D;&gt; &#123;  console.log(&#39;Hello, &#39; + data.name);&#125;);&#x2F;&#x2F; 发布事件bus.emit(&#39;sayHello&#39;, &#123; name: &#39;Alice&#39; &#125;); &#x2F;&#x2F; 输出: Hello, Alice&#x2F;&#x2F; 取消订阅const handler &#x3D; (data) &#x3D;&gt; console.log(&#39;Goodbye, &#39; + data.name);bus.on(&#39;sayGoodbye&#39;, handler);bus.emit(&#39;sayGoodbye&#39;, &#123; name: &#39;Bob&#39; &#125;); &#x2F;&#x2F; 输出: Goodbye, Bobbus.off(&#39;sayGoodbye&#39;, handler);bus.emit(&#39;sayGoodbye&#39;, &#123; name: &#39;Bob&#39; &#125;); &#x2F;&#x2F; 无输出&#x2F;&#x2F; 只订阅一次bus.once(&#39;greet&#39;, (data) &#x3D;&gt; console.log(&#39;Greetings, &#39; + data.name));bus.emit(&#39;greet&#39;, &#123; name: &#39;Charlie&#39; &#125;); &#x2F;&#x2F; 输出: Greetings, Charliebus.emit(&#39;greet&#39;, &#123; name: &#39;Charlie&#39; &#125;); &#x2F;&#x2F; 无输出","categories":["设计模式"],"tags":["EventBus"]},{"title":"Excel_tips","url":"/qqsnote/2019/11/12/Excel-tips/","content":"随机数&#x3D;rand() &#x2F;&#x2F;生成随机数区间[0,1]&#x3D;randbetween(100,999)&#x2F;&#x2F;生成范围内随机整数\n随机字符&#x3D;CHAR(INT(RAND()*25+65))\n字符串拼接&#x3D;concat(&quot;id&quot;,&quot;0001&quot;)\n随机日期&#x3D;TEXT(RAND()*(&quot;2019-11-11&quot;-&quot;2018-11-11&quot;)+&quot;2018-11-11&quot;,&quot;e&#x2F;m&#x2F;d&quot;)\n批量取消科学计数法格式化单元格 Number—Custom—0\n进制转换 16进制—&gt;十进制： HEX2DEC\nVLOOKUPy=vlookup(x, source_table, column_index, boolean)在source_table中找到x所在行，返回第column_index列的对应结果，boolean：TRUE 模糊匹配 FALSE 严格匹配\n条件格式如 Home—&gt;Conditional Formatting—&gt;Highlight Cell Rules—&gt;Duplicate Values高亮显示所选区域中存在重复值的cell\n批量输入\nCtrl + D\nHome —&gt; Editing —&gt; Fill\n\n","categories":["工具"],"tags":["Excel"]},{"title":"Expo AuthSession","url":"/qqsnote/2024/12/09/Expo-Auth-Session/","content":"npx expo install expo-auth-session expo-crypto # expo-crypto 是 peer dependency 须与 expo-auth-session 一起安装\n基于web浏览器的认证\napp.json中配置用于重定向携带参数的scheme&#123;  &quot;expo&quot;: &#123;    &quot;name&quot;: &quot;My App&quot;,    &quot;slug&quot;: &quot;my-app&quot;,    &quot;scheme&quot;: &quot;myapp&quot;, &#x2F;&#x2F; 这里定义了应用的 scheme    ...  &#125;&#125;scheme 字段用于定义应用的 URL scheme。URL scheme 是一种协议，允许其他应用程序通过特定的 URL 格式打开你的应用，并传递数据给它。该协议是实现深度链接（deep linking）和通用链接（universal linking）的基础。\n\n深度链接（Deep Linking）和通用链接（Universal Links）是两种用于直接导航到移动应用内特定内容或功能的技术\n深度链接是一种允许应用程序内部特定页面或功能被直接访问的链接形式。通过使用自定义URL方案（Custom URL Scheme），开发者可以创建指向应用内任何位置的链接，形如myapp://product/12345\n通用链接是苹果公司在iOS 9中引入的一种技术，它使得HTTP/HTTPS链接可以直接打开已安装的应用程序中的相应内容，链接形式与传统网站链接相同，不需要特殊的URL scheme（不依赖是否安装，可避免不同应用程序使用相同的URL scheme的安全问题）import &#123; useState &#125; from &#39;react&#39;;import * as WebBrowser from &#39;expo-web-browser&#39;;import &#123;  exchangeCodeAsync,  makeRedirectUri,  useAuthRequest,  useAutoDiscovery,&#125; from &#39;expo-auth-session&#39;;import &#123; Button, Text, SafeAreaView &#125; from &#39;react-native&#39;;WebBrowser.maybeCompleteAuthSession();export default function App() &#123;  &#x2F;&#x2F; Endpoint  const discovery &#x3D; useAutoDiscovery(    &#39;https:&#x2F;&#x2F;login.microsoftonline.com&#x2F;&lt;TENANT_ID&gt;&#x2F;v2.0&#39;,  );  const redirectUri &#x3D; makeRedirectUri(&#123;    scheme: &#39;com.app&#39;,    path: &#39;auth&#39;,  &#125;);  &#x2F;&#x2F; 认证成功返回以下uri  &#x2F;&#x2F; Development Build: my-scheme:&#x2F;&#x2F;redirect  &#x2F;&#x2F; Expo Go: exp:&#x2F;&#x2F;127.0.0.1:8081&#x2F;--&#x2F;redirect  const clientId &#x3D; &#39;&lt;CLIENT_ID&gt;&#39;;  &#x2F;&#x2F; We store the JWT in here  const [token, setToken] &#x3D; useState&lt;string | null&gt;(null);  &#x2F;&#x2F; Request  const [request, , promptAsync] &#x3D; useAuthRequest(    &#123;      clientId,      scopes: [&#39;openid&#39;, &#39;profile&#39;, &#39;email&#39;, &#39;offline_access&#39;],      redirectUri,    &#125;,    discovery,  );  return (    &lt;SafeAreaView&gt;      &lt;Button        disabled&#x3D;&#123;!request&#125;        title&#x3D;&quot;Login&quot;        onPress&#x3D;&#123;() &#x3D;&gt; &#123;          promptAsync().then((codeResponse) &#x3D;&gt; &#123;            if (request &amp;&amp; codeResponse?.type &#x3D;&#x3D;&#x3D; &#39;success&#39; &amp;&amp; discovery) &#123;              exchangeCodeAsync(                &#123;                  clientId,                  code: codeResponse.params.code,                  extraParams: request.codeVerifier                    ? &#123; code_verifier: request.codeVerifier &#125;                    : undefined,                  redirectUri,                &#125;,                discovery,              ).then((res) &#x3D;&gt; &#123;                setToken(res.accessToken);              &#125;);            &#125;          &#125;);        &#125;&#125;      &#x2F;&gt;      &lt;Text&gt;&#123;token&#125;&lt;&#x2F;Text&gt;    &lt;&#x2F;SafeAreaView&gt;  );&#125;\n\nuseAutoDiscovery(‘[OpenId issuer URL]’) \n\n\n","categories":["移动端"],"tags":["Web开发"]},{"title":"Expo","url":"/qqsnote/2024/12/09/Expo/","content":"objectives orientation：\n\nwhat &amp; what benefits, defect(缺点)\n交互interact \n隐私和权限\n工具链\n\nwhat is ExpoExpo 是一个基于 React Native 的框架。其服务于简化和便于 React Native 开发方式，Expo框架包括Expo CLI（如 create-expo-app）Expo SDK （其封装了一些导航、设备、通知等功能和api）Expo Go（一个可以在 iOS 和 Android 上安装的应用程序，允许你通过扫描 QR 码或 URL 来即时预览和测试你的 Expo 项目，而不需要构建 APK 或 IPA 文件。）EAS (远程构建 一键推送Google Play和Apple Store)参考使用Expo开发应用\n缺点是对深度定制开发（甚至无法对接支付宝和微信支付功能）和涉及到原生模块的开发缺乏灵活性，需要Expo eject成纯React Native项目，此操作不可逆\n安装Expo：npx create-expo-app StickerSmash --template blank-typescriptcd StickerSmashnpx expo run:androidnpx expo start使用npx expo install而不是npm i或yarn add，以便提供兼容性提示\nExpo路由file-based router\n配置app.json 存放编译所需静态参数 如app名称、版本信息、OTA配置等如需动态配置应使用app.config.tsimport &#123; ExpoConfig, ConfigContext &#125; from &#39;expo&#x2F;config&#39;;export default (&#123; config &#125;: ConfigContext): ExpoConfig &#x3D;&gt; (&#123;  ...config,  slug: &#39;my-app&#39;,  name: &#39;My App&#39;,&#125;);\nExpo SDK库EASExpo Application Service, 构建安装包需要用eas服务，这是对墙内用户不友好的地方之一npm i -g eas-clieas logineas build --platform android --profile release默认打包成abb文件，生成apk需要在eas.json中某个profile中设置好类型如&quot;release&quot;: &#123;    &quot;android&quot;: &#123;        &quot;buildType&quot;: &quot;apk&quot;    &#125;&#125;\n","categories":["移动端"],"tags":["Web开发"]},{"title":"Figma","url":"/qqsnote/2021/12/14/Figma/","content":"11 个 Figma 技巧 英文版\nTODO导入素材 如material UI控件样例以及Icons\n","tags":["Figma"]},{"title":"ExtensionsAndPlugins","url":"/qqsnote/2023/11/24/ExtensionsAndPlugins/","content":"hovermxis tweaker"},{"title":"Python —— FastAPI","url":"/qqsnote/2025/07/28/FastAPI/","content":""},{"title":"弹性盒子布局","url":"/qqsnote/2018/08/17/FlexBox/","content":"知乎专栏：flexdisplay: flex&lt;style&gt;  #box-container &#123;    height: 500px;    display: flex;  &#125;    #box-1 &#123;    background-color: dodgerblue;    width: 50%;    height: 50%;  &#125;  #box-2 &#123;    background-color: orangered;    width: 50%;    height: 50%;  &#125;&lt;&#x2F;style&gt;&lt;div id&#x3D;&quot;box-container&quot;&gt;  &lt;div id&#x3D;&quot;box-1&quot;&gt;&lt;&#x2F;div&gt;  &lt;div id&#x3D;&quot;box-2&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;flex-directionvalue: row | column | row-reverse | column-reverse\njustify-contentvalue: flex-start | flex-end | space-between | space-around子元素不占满父元素时，在水平方向设置排列和空余的选项\nalign-itemsvalue: flex-start | flex-end | space-between | space-around子元素不占满父元素时，在垂直方向设置排列和空余的选项\nalign-contentvalue: flex-start | flex-end | center | strech | space-between | space-around\nflex-wrapvalue: nowrap | wrap | wrap-reverse当子元素宽度之和超过弹性布局容器时，设置换行\nflex-shrinkvalue:(number)设置子元素在弹性布局容器中的宽度压缩比例\nflex-growvalue:(number)设置子元素在弹性布局容器中的高度拉伸比例\nflex-basisvalue:(px, em, %)在进行flex-shrink和flex-grow前初始化子元素尺寸\n缩写flex: 1 0 10px;&#x2F;&#x2F; same asflex-grow: 1;flex-shrink: 0;flex-basis: 10px;ordervalue:(number)次序\nalign-selfvalue:auto | flex-start | flex-end | center | baseline | stretch | inherit设置在各子元素与父元素的align-item作用对应并覆盖align-item效果\n从原理出发标记为 display:flex | inline-flex 的块状元素（即flex container）获得控制其子元素（flex item）宽高或顺序的能力\n子元素沿main axis均匀排布（just-content）沿cross axis调整对齐（align-item）main axis未必是水平的 由flex-direction控制\n\njust-content控制沿主轴的排布\n\n所有子元素都沿主轴排布 所以是调整‘content’\n\nalign-item控制cross axis方向上的对齐\n\n每个子元素在其侧轴上 与其他子元素对其 所以是对其‘item’\n\nalign-content顾名思义 对其所有元素 应用于 超出一行 且未占满整个container的情形\n\n","categories":["前端技术"],"tags":["CSS"]},{"title":"Flip动画效果","url":"/qqsnote/2024/01/13/Flip/","content":"Flip\n\nFirst  元素的初始状态（比如位置、透明度等等）\nLast   元素的最终状态\nInvert\nPlay\n\nA 状态到 B 状态，不用手动计算每一帧的改变，而是计算从 B 到 A 的反向动画，然后下一帧直接切换 B 状态，在把反向动画应用在 B 上。其实真实元素是直接从 A-&gt;B，但是由于在 B 状态上加了反向动画，所以用户看起来像是过渡。\n不明白 暂时没看明白\n","categories":["前端技术"],"tags":["Web开发","CSS"]},{"title":"前端基础","url":"/qqsnote/2021/07/10/FrontEnd-Fundation/","content":"\nDOCTYPE 有什么作用？怎么写？&lt;!DOCTYPE html&gt;\nhtml5规范的文档声明，示意浏览器以相应的标准解析文档，使支持html5规范如新的标签等\n列出常见的标签，并简单介绍这些标签用在什么场景？canvas\n页面出现了乱码，是怎么回事？如何解决？&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; &#x2F;&gt; \n可能是即字符编码不匹配造成\ntitle 属性和 alt 属性分别有什么作用？\nHTML 的注释怎样写？\ndata- 属性的作用？自定义数据属性data-*var box &#x3D; document.getElementById(&quot;box&quot;); &#x2F;&#x2F; &lt;div id&#x3D;&quot;box&quot; data-user-name&#x3D;&quot;QQs&quot;&gt;&lt;&#x2F;div&gt;var username &#x3D; box.dataset.userName;\n\\ 的 title 和 alt 有什么区别？\nWeb 标准以及 W3C 标准是什么？ web标准\nHTML 全局属性（Global Attribute）有哪些？id class style title name data-* contenteditable translate\nmeta 有哪些常见的值？charset\nmeta viewport 是做什么用的，怎么写？\\\n列出常见的标签，并简单介绍这些标签用在什么场景？\n如何在 HTML 页面上展示  这几个字符？\n你是如何理解 HTML 语义化的？\n前端需要注意哪些 SEO?\n\n","categories":["前端技术"],"tags":["javascript"]},{"title":"博弈论","url":"/qqsnote/2020/11/02/GameTheory/","content":"零和博弈，非零和博弈非零和博弈表示在不同策略组合下各博弈方的得益之和是不确定的变量，故又称之为变和博弈。 如囚徒困境，中美关系，恋爱\n零和博弈表示所有博弈方的利益之和为零或一个常数，即一方有所得，其他方必有所失。如绝大多数竞技，竞选，炒股\n行业或社会环境成为存量市场，内卷是人们进行零和博弈的结果。\n\n摘自百度百科《非零和博弈》:烈日炎炎的一个下午，约翰·纳什教授给二十几个学生上课，教室窗外的楼下有几个工人正施工，机器的响声成了刺耳的噪音，于是纳什走到窗前狠狠地把窗户关上。马上有同学提出意见：“教授，请别关窗子，实在太热了！”而纳什教授一脸严肃地回答说：“课堂的安静比你舒不舒服重要得多！”然后转过身一边嘴里叨叨着“给你们来上课，在我看来不但耽误了你们的时间，也耽误了我的宝贵时间……”，一边在黑板上写着数学公式。正当教授一边自语一边在黑板上写公式之际，一位叫阿丽莎的漂亮女同学（这位女同学后来成了纳什的妻子）走到窗边打开了窗子，电影中纳什用责备的眼神看着阿丽莎：“小姐……”而阿丽莎对窗外的工人说道：“打扰一下，嗨！我们有点小小的问题，关上窗户，这里会很热；开着，却又太吵。我想能不能请你们先修别的地方，大约45分钟就好了。”正在干活的工人愉快地说：“没问题！”又回头对自己的伙伴们说：“伙计们，让我们先休息一下吧！”阿丽莎回过头来快活地看着纳什教授，纳什教授也微笑地看着阿丽莎，既像是讲课，又像是在评论她的做法似地对同学们说：“你们会发现在多变性的微积分中，往往一个难题会有多种解答。”而阿丽莎对“开窗难题”的解答，使得原本的一个零和博弈变成了另外一种结果：同学们既不必忍受室内的高温，教授也可以在安静的环境中讲课，结果不再是0，而成了+2。由此我们可以看到，很多看似无法调和的矛盾，其实并不一定是你死我活的僵局，那些看似零和博弈或者是负和博弈的问题，也会因为参与者的巧妙设计而转为正和博弈。\n\n内卷和博弈内卷是零和博弈的状态吗？参与者是直接地进行利益竞争吗，似乎并不是哦，内卷的起因是掌握话语权的一方——在社会生产的范畴上是资本家，在就学教育上是招生办——限制了规则，在既定的有限条件下，低阶层的参与者为了自己的收益做出与之不匹配的付出。博弈是影响决策的活动，当然就要有决策的权力和空间。\n","tags":["博弈论"]},{"title":"Git","url":"/qqsnote/2020/04/07/Git/","content":"日常git config --global user.email &quot;QQs@xxxx.xxx&quot;git config --global user.name &quot;QQs&quot;git initgit remote add origin git@xxxx.xxx:projectX.git&#x2F;&#x2F; 添加远程主机命名为origingit branch -r&#x2F;&#x2F; 查看远程分支git pull origin dev:develop&#x2F;&#x2F; 拉取origin上的dev分支 命名为developgit add .git commit -m &quot;blablabla&quot;git push origin dev&#x2F;&#x2F; 将修改推送到origin上的dev分支上&#x2F;&#x2F; clone and rename git clone git@xxxxxx YourFolderName\nclone指定分支git clone -b release git@xxxx.xxx:projectX.git\n创建分支git checkout -b bug&#x2F;fixXXXissue\n忽略本地修改拉取远程分支git fetch --allgit reset --hard origin&#x2F;master\n\n可以认为git pull是git fetch和git merge两个步骤的结合git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;//取回远程主机某个分支的更新，再与本地的指定分支合并。\n\ngit fetch origin master:temp &#x2F;&#x2F;在本地新建一个temp分支，并将远程origin仓库的master分支代码下载到本地temp分支git diff tmp &#x2F;&#x2F;来比较本地代码与刚刚从远程下载下来的代码的区别git merge tmp&#x2F;&#x2F;合并temp分支到本地的master分支git branch -d temp&#x2F;&#x2F;删除temp分支\n回退git reset --hard cd8462xxxx即将HEAD游标指向到之前的一次commit\ngit clean -fxd-f —force-x 移除包括被gitignore忽略的文件 支持-e参数（if have）-X 移除所有git ignore的文件 用于从头开始重建一切-d 递归并移除untrack目录\n部分检出git config core.sparsecheckout trueecho &#x2F;db&#x2F;* &gt;&gt; .git&#x2F;info&#x2F;sparse-checkout\nreset revertgit reset --soft &lt;commit&gt; &#x2F;&#x2F; 重置到&lt;commit&gt;版本，修改内容放入缓存区（unstage）git reset --hard &lt;commit&gt; &#x2F;&#x2F; 重置到&lt;commit&gt;版本，修改内容永久删除git revert &lt;commit-last&gt; .. &lt;commit-somewhere&gt; &#x2F;&#x2F; 提交一个记录来撤销所罗列出的&lt;commit&gt;\nrebasegit checkout feature&#x2F;new_featueXXXgit rebase develop&#x2F;&#x2F; resolve merge conflictgit rebase --continue\ngit rebase -i &lt;start-commit&gt; &lt;end-commit&gt; &#x2F;&#x2F;(start-commit, end-commit] 前开后闭区间，合并到当前分支，默认 end-commit 为当前 HEAD\n把 develop rebase 进 feature/new_featueXXX 分支，develop为上游(Upstream), checkout 的new_featueXXX 分支为Currnet Branch.\n每将一次develop的commit rebase进feature 都合并为一个中间版本commit，然后 git rebase —continue。实际中，rebase过程中可能产生冲突，如果两条分支都含有多次commit，且修改内容相互渗透，产生很多冲突，continue时是个中间版本 很难保证复合变基的逻辑吧 那将使这种”规范”失去意义 索性直接merge算了\nrebase的取消rebase完成后没有与该操作对应的commit记录，即不改变前后commit的个数（只调整顺序）但是git本身是有所有操作的记录的，因此任何操作都可以回退, 使用git reflog显示这些记录 并选择标记头进行回退git reflog---显示action历史---git reset --hard HEAD&#123;10&#125;git rebase 的撤销\n包括git reset到之前的版本，此时HEAD会指向到旧版本，较新的commit不在git log中可见了，可以通过git reflog查看 tip: git reflog —date=iso查看操作时间找到commit的SHA号码 git reset到它即可\ngit cherry-pickgit checkout developgit cherry-pick f2ef69d 9839b06\n例如f2ef69d 9839b06是release上刚修好的bug，可以使用上述命令将两处修改直接复制到develop分支\nrepository 迁移git clone --bare git@old-repo.git cd old-repogit remote add bitbucket git@bitbucket-repo.gitgit push --all bitbucketgit push --tags bitbucket\nstale branches 和 remote tracking branchremote tracking branch是一个引用(reference),表示是远端分支的状态，不应被修改\nstale branch是远端已经移除的remote tracking branchStackOverflow:What is a “stale” git branch?\ngit log退出日志文本是按q，同vim\n查看所有分支对当前目录的修改，并显示所修改文件:git log —stat —graph —all\nstagegit statusgit add/rm …git reset ./temp.txtgit checkout — …\ntag标签tag用于标记一个commitgit tag -a v1.0.3 -m &quot;bump version to v1.0.3&quot;使用git tag命令查看所有标签，使用git checkout检出指定标签版本移除尚未推送到远端的标签:git tag -d v1.0.3\ngit blamesubmodule为项目添加子模块git submodule add https:&#x2F;&#x2F;example.com&#x2F;demo&#x2F;lib1 lib1关联了子模块的项目含有.gitmoudles文件 形如[submodule &quot;lib1&quot;]    path &#x3D; lib1    url &#x3D; https:&#x2F;&#x2F;example.com&#x2F;demo&#x2F;lib1[submodule &quot;lib2&quot;]    path &#x3D; lib2    url &#x3D; https:&#x2F;&#x2F;example.com&#x2F;demo&#x2F;lib2[submodule &quot;lib3&quot;]    path &#x3D; lib3    url &#x3D; https:&#x2F;&#x2F;example.com&#x2F;demo&#x2F;lib3拉取项目后源码中不包含这些子项目 使用git submodule命令更新git submodule init lib1 lib2 #init命令可以按需初始化 lib1 lib2写入项目configgit submodule update大型项目递归拉取submodulegit submodule update --init --recursive\nssh协议改httpsgit remote add temp_remote_name https:&#x2F;&#x2F;xxxxxxx.gitgit remote remove origingit remote rename temp_remote_name origin\ntroubleshooting\nerror: object file .git/objects/61/9151e2619bc36c3c4f5f0c86432b2ca651706d is empty fatal: loose object 619151e2619bc36c3c4f5f0c86432b2ca651706d (stored in .git/objects/61/9151e2619bc36c3c4f5f0c86432b2ca651706d) is corrupt\n\n尝试用下列方法修复# 删除.git&#x2F;objects&#x2F;*&#x2F;目录下的空文件git fsck --full git gc --autogit fsck命令用于检查文件有效性和连贯性git gc 清理不必要的文件并优化本地存储库\n","categories":["工具"],"tags":["git"]},{"title":"GitFlow","url":"/qqsnote/2020/04/09/GitFlow/","content":"Branch\nmaster\ndev\nfeature/xxxx\nrelease/1.x.x\nhotfix/1.x.xTaghotfix 合并到master 以及 devgit checkout mastergit merge --no-ff hotfix&#x2F;1.x.x\n关于QA的讨论曾认为feature代码在开发确认功能，过静态检查、单元测试、code review后合并至dev，即feature所在的生命周期由开发团队维护，从dev做release交QA进行全量测试实际上在本团队，feature的DOD(defination of done)规定在合并到dev前需要通过QA测试，对合并后再发的’版本’也肯定要测的。对于本团队的实践，是否存在QA过早介入，测试是否重复的问题，fcc大佬如是说：多数情况下new feature的业务/逻辑上的确认只能人工进行，这里的人是QA的人是合理的，该‘确认’过程不包含在code review(主要针对编码质量)中，若无QA的确认，则存在合并后被QA拒绝的风险，而拆解合并后的代码可能代价颇高。另：了解gitlab\n\nchange main without","tags":["git"]},{"title":"阿里系前端编码规范","url":"/qqsnote/2023/08/17/FrontEndCodingSpecification/","content":"\n    \n        \n                            \n                                \n                                    \n                                        \n                                    \n                                \n                            \n                        \n        \n        前端规范体现在项目的\n            .prettierrc.js、.eslintrc.js、.stylelintrc.js、.editorconfig\n            文件中，项目的文件夹结构只要有项目模板或者最佳实践作为参考，都会按照已有的物料去组织逻辑去写业务代码。整体原则是减少需要主动去 review 和 check 的地方，尽量通过自动化解决大多数问题。\n        \n        一．编程规约\n        \n        (一) 命名规范\n        \n        项目命名\n        \n        全部采用小写方式，以中线分隔。\n        \n            \n                \n                    \n                        \n                            \n                                # 正例\ndata-management-system\n# 反例\ndata_management-system/dataManagementSystem\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        目录命名\n        全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法，\n            缩写不用复数。\n        \n            \n                \n                    \n                        \n                            \n                                # 正例\nsrc/styles/components/images/utils/layouts/demo-styles/\n# 反例\nsrc/styles/components/images/utils/layouts/demo_styles/\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n        JS、CSS、LESS、HTML、PNG 文件命名:\n        全部采用小写方式， 以中划线分隔。\n        \n        \n            \n                \n                    \n                        \n                            \n                                # 正例\nrender-dom.js/reset.css/company.png\n# 反例\nrenderDom.js/UserManager.html\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        (二) HTML 规范 （Vue Template 同样适用）\n        \n        缩进：缩进使用 2 个空格（一个 tab）；嵌套的节点应该缩进。 引号：使用双引号(\" \") 而不是单引号(’ ') 。\n        \n        \n            \n                \n                    \n                        \n                            \n                                &lt;!-- 正例 --&gt;\n&lt;div class=\"box\"&gt;&lt;/div&gt;\n&lt;!-- 反例 --&gt;\n&lt;div class='box'&gt;&lt;/div&gt;\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n        (三) CSS/LESS 规范\n        \n        命名\n        \n        类名使用小写、id用驼峰、变量用驼峰。名称反映元素目的和用途。\n        \n            \n                \n                    \n                        \n                            \n                                // 正例\n.heavy {\n  font-weight: 800;\n}\n.important { \n  color: red; \n}\n\n// 反例\n.fw-800 {\n  font-weight: 800;\n}\n.red {\n  color: red; \n}\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n        选择器\n        避免使用标签名、使用直接子选择器\n        \n            \n                \n                    \n                        \n                            \n                                // 正例\n.content &gt; .title {\n   font-size: 2rem;\n }\n\n// 反例\n.content .title {\n  font-size: 2rem;\n}\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        省略 0 后面的单位\n        \n        \n            \n                \n                    \n                        \n                            \n                                // 正例\ndiv {\n  padding-bottom: 0; \n  margin: 0; \n}\n// 反例\ndiv {\n  padding-bottom: 0px; \n  margin: 0em;\n}\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n        代码组织\n        将公共 less 文件放置在 style/less/common\n            文件夹，color.less，common.less。按以下顺序组织\n        \n            \n                \n                    \n                        \n                            \n                                @import \"mixins/size.less\"; \n\n@default-text-color: #333; \n\n.page {\n  width: 960px; \n  margin: 0 auto; \n}\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        避免嵌套层级过多:\n        \n        嵌套深度限制在 3 层。\n        \n        (四) Javascript 规范\n        \n            \n                \n                    \n                        \n                            \n                                // 方法名、参数名、成员变量、局部变量都统一使用小驼峰 lowerCamelCase 风格\nfunction getHttpMessage(inputUserId) {\n  let localValue = inputUserId;\n  return false\n}\n\n// 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚， 不要嫌名字长\nconst MAX_STOCK_COUNT = 0;\n\n// this 的转换命名\nconst _this = this;\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        JS 书写保持原则\n        \n            提炼函数\n            合并重复的条件片段\n            把条件分支语句提炼成函数\n            少用三目运算符\n            合理使用循环\n            提前让函数退出代替嵌套条件分支；用return退出多重循环\n            \n            传递对象参数代替过长的参数列表，尽量减少参数数量\n        \n        \n            \n                \n                    \n                        \n                            \n                                const fn = (name, age) =&gt; {\n  console.log('name=' + name);\n  console.log('age=' + age);\n}\n\n// 优化之后\n\nconst fn = ( obj ) =&gt; {\n  console.log('name=' + obj.name);\n  console.log('age=' + obj.age);\n}\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        方法命名必须是 动词 或者 动词+名词 形式\n        \n        正例： saveShopCarData /openShopCarInfoDialog 反例： save / open /\n            show / go 增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）\n        \n            \n                \n                    \n                        \n                            \n                                add / update / delete / detail / get \n附： 函数方法常用的动词: \nget 获取/set 设置, \nadd 增加/remove 删除, \ncreate 创建/destroy 销毁, \nstart 启动/stop 停止, \nopen 打开/close 关闭, \nread 读取/write 写入, \nload 载入/save 保存,\nbegin 开始/end 结束, \nbackup 备份/restore 恢复,\nimport 导入/export 导出, \nsplit 分割/merge 合并,\ninject 注入/extract 提取,\nattach 附着/detach 脱离, \nbind 绑定/separate 分离, \nview 查看/browse 浏览, \nedit 编辑/modify 修改,\nselect 选取/mark 标记, \ncopy 复制/paste 粘贴,\nundo 撤销/redo 重做, \ninsert 插入/delete 移除,\nadd 加入/append 添加, \nclean 清理/clear 清除,\nindex 索引/sort 排序,\nfind 查找/search 搜索, \nincrease 增加/decrease 减少, \nplay 播放/pause 暂停, \nlaunch 启动/run 运行, \ncompile 编译/execute 执行, \ndebug 调试/trace 跟踪, \nobserve 观察/listen 监听,\nbuild 构建/publish 发布,\ninput 输入/output 输出,\nencode 编码/decode 解码, \nencrypt 加密/decrypt 解密, \ncompress 压缩/decompress 解压缩, \npack 打包/unpack 解包,\nparse 解析/emit 生成,\nconnect 连接/disconnect 断开,\nsend 发送/receive 接收, \ndownload 下载/upload 上传, \nrefresh 刷新/synchronize 同步,\nupdate 更新/revert 复原, \nlock 锁定/unlock 解锁, \ncheck out 签出/check in 签入, \nsubmit 提交/commit 交付, \npush 推/pull 拉,\nexpand 展开/collapse 折叠, \nenter 进入/exit 退出,\nabort 放弃/quit 离开, \nobsolete 废弃/depreciate 废旧, \ncollect 收集/aggregate 聚集\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n            \n                \n                    \n                        \n                            \n                                // undefined 判断\nif (typeof person === 'undefined') {\n  doSomething();\n}\n\n// 字符串 统一使用单引号('')，不使用双引号(\"\")。\n// 这在创建 HTML 字符串非常有好处 vscode 配置 \n// settings.json 或者 .eslintrc.js 或者 .prettierrc.json\nlet str = 'foo';\nlet testDiv = '&lt;div id=\"test\"&gt;&lt;/div&gt;';\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n        (五) Vue 规范\n        \n            组件名为多个单词\n            组件文件名为 pascal-case 格式\n            基础组件文件名为 base 开头，使用完整单词而不是缩写。\n            \n            和父组件紧密耦合的子组件应该以父组件名作为前缀命名\n            \n        \n        \n        \n            \n                \n                    \n                        \n                            \n                                // components/base-input.vue\n\n// components/todo-list.vue\n// components/todo-list-item.vue\n\n// 正例\nexport default {\n  name: 'TodoItem'\n};\n\n// 反例\nexport default {\n  name: 'Todo',\n}\nexport default {\n  name: 'todo-item',\n}\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n            在 Template 模版中使用组件，应使用\n                PascalCase 模式，并且使用自闭合组件。\n        \n        \n            \n                \n                    \n                        \n                            \n                                &lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;\n&lt;MyComponent /&gt;\n&lt;Row&gt;&lt;table :column=\"data\"/&gt;&lt;/Row&gt;\n\n&lt;!-- 反例 --&gt;\n&lt;my-component /&gt; &lt;row&gt;&lt;table :column=\"data\"/&gt;&lt;/row&gt;\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n        \n            Prop 定义应该尽量详细\n        \n        \n            必须使用 camelCase 驼峰命名\n            必须指定类型\n            必须加上注释，表明其含义\n            必须加上 required 或者\n                default，两者二选其一\n            如果有业务需要，必须加上 validator 验证\n            \n        \n        \n            \n                \n                    \n                        \n                            \n                                props: {\n  // 组件状态，用于控制组件的颜色\n  status: {\n    type: String,\n    required: true,\n    validator: function (value) {\n      return [\n        'succ',\n        'info',\n        'error'\n      ].indexOf(value) !== -1\n    }\n  },\n  // 用户级别，用于显示皇冠个数\n  userLevel: {\n    type: String,\n    required: true\n  }\n}\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n            模板中使用简单的表达式\n        \n        \n            组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。\n        \n            \n                \n                    \n                        \n                            \n                                &lt;template&gt;\n  &lt;p&gt;&lt;/p&gt;\n&lt;/template&gt;\n// 复杂表达式已经移入一个计算属性\ncomputed: {\n  normalizedFullName: function () {\n    return this.fullName.split(' ').map(function (word) {\n      return word[0].toUpperCase() + word.slice(1)\n    }).join(' ')\n  }\n}\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n        涉及的插件与配置文件\n        默认使用开发工具 VScode\n        \n            Prettier\n        \n        代码美化，自动格式化成规范格式\n        \n            Stylelint\n        \n        样式代码规范 .vscode/settings.json\n        \n            eslint\n            vetur\n        \n        配置文件 .editorconfig\n        \n        \n            \n                \n                    \n                        \n                            \n                                # @see: http://editorconfig.org\n\nroot = true\n\n[*] # 表示所有文件适用\ncharset = utf-8 # 设置文件字符集为 utf-8\nend_of_line = lf # 控制换行类型(lf | cr | crlf)\ninsert_final_newline = true # 始终在文件末尾插入一个新行\nindent_style = tab # 缩进风格（tab | space）\nindent_size = 2 # 缩进大小\nmax_line_length = 130 # 最大行长度\n\n[*.md] # 表示仅 md 文件适用以下规则\nmax_line_length = off # 关闭最大行长度限制\ntrim_trailing_whitespace = false # 关闭末尾空格修剪\n\n                            \n                        \n                    \n                \n                \n                    \n                            \n                                \n                            \n                        \n                \n            \n        \n        \n        参考资料\n        阿里代码规范（前端篇）\n    \n","tags":["编码规范"]},{"title":"Github-Tips","url":"/qqsnote/2024/01/05/Github-Tips/","content":"search for topic: Awesome xxx\n"},{"title":"Grid","url":"/qqsnote/2021/03/11/Grid/","content":"如果说flex适合做一维(水平或竖直放向)元素的布局，那么grid就是做二维布局的，如字面意思，grid布局将平面划分成 m*n 的网格，子元素分布其中，以所处/所占的行和列的控制实现页面layout的划分&lt;div class&#x3D;&quot;wrapper&quot;&gt;  &lt;div class&#x3D;&quot;one&quot;&gt;One&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;two&quot;&gt;Two&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;three&quot;&gt;Three&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;four&quot;&gt;Four&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;five&quot;&gt;Five&lt;&#x2F;div&gt;  &lt;div class&#x3D;&quot;six&quot;&gt;Six&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;style&gt;.wrapper &#123;  display: grid;  grid-template-columns: repeat(3, 1fr);  grid-gap: 10px;  grid-auto-rows: minmax(100px, auto);&#125;.one &#123;  grid-column: 1 &#x2F; 3;  grid-row: 1;&#125;.two &#123;  grid-column: 2 &#x2F; 4;  grid-row: 1 &#x2F; 3;&#125;.three &#123;  grid-row: 2 &#x2F; 5;  grid-column: 1;&#125;.four &#123;  grid-column: 3;  grid-row: 3;&#125;.five &#123;  grid-column: 2;  grid-row: 4;&#125;.six &#123;  grid-column: 3;  grid-row: 4;&#125;&lt;&#x2F;style&gt;display: grid 或 inline-grid区分整个区域是否作为行内元素插入，不影响区域内的grid\n列划分：grid-template-columns: 200px 500px 100px;grid-template-columns: repeat(4, 25%);grid-template-columns: 200px repeat(3, 1fr) 100px;注：fr是grid的特殊单位，可以从总分列去掉固定宽度列后均分剩余列行划分grid-template-rows类似，也可以按比例划分剩余宽度\n间距：grid-gap: 5px;grid-row-gap: 5px;grid-column-gap: 5px;\n填充:grid-template-columns: repeat(auto-fill, 200px);以200px为一列，根据区域宽度调整列数（响应式）\n区间：grid-template-columns: 1fr 1fr minmax(300px, 2fr)第三个列宽最少也是要 300px，但是最大不能大于第一第二列宽的两倍。\n区域定义：（略）\n流：grid-auto-flow: row;grid-auto-flow: row dense;grid-auto-flow: column;填充单元格的横纵顺序，如果遇到尺寸不够而挤到下一行的情况，dense可以使用合适的子元素填充前面的空余单元格\n对齐：justify-item, align-item:父容器配置，分别控制子元素在所处单元格空间的对齐方向，两者默认是stretch撑满空间可选值：start center end stretch\njustify-content, align-content:父容器配置，分别控制整个grid(父容器)在上层容器中的对齐方向，两者默认是start\njustify-self, align-self:子元素配置，控制自身在所处单元格空间的对齐方向与*-item一致\n隐式网格：在超出grid-template-columns和grid-template-rows的定义之后应用的网格划分grid-template-columns: 200px 500px 100px;grid-template-rows: 100px 100px;grid-auto-rows: 50px;\n指定坐标：.item &#123;  grid-column-start: 3;  grid-column-end: 4;  grid-row-start: 1;  grid-row-end: 4;&#125;\n","categories":["前端技术"],"tags":["CSS"]},{"title":"Godot","url":"/qqsnote/2025/05/15/Godot/","content":"Godot是C++开发的基于opengl的游戏引擎，MIT开源协议，完全免费。支持一键导出到多个平台，包括主流的桌面平台（Linux、macOS、Windows）、移动平台（Android、iOS）、基于 Web 的平台以及主机平台。\nGodot Docs\n"},{"title":"Halcon","url":"/qqsnote/2024/06/27/Halcon/","content":"\n\n\n\n\n\nOpenCV\nHalcon\n\n\n\n\n开发语言\nC++、C#（emgu）、Python、Ruby、MATLAB等语言\nC，C++，C#，Visual basic和Delphi等语言\n\n\n应用场合\n侧重计算机视觉领域，侧重研究领域\n侧重机器视觉领域，侧重应用领域\n\n\n费用\n免费\n收费\n\n\n开放性及版本更新速度\n开源（可看底层源码），版本和功能更新慢\n商业软件（底层代码封装），版本和功能更新快\n\n\n对使用者的门槛\n偏科研，有难度，有深度，完全从底层开发，对使用者门槛高，开发效率低，开发慢\n偏工程应用，使用封装好的功能函数，对使用者门槛低，开发效率高，开发快\n\n\n资料及技术支持\n资料少。遇到问题，难以获得技术支持\n资料多。遇到问题，可以及时、有效的获得技术支持\n\n\n\n\n硕士研究生学习机器视觉，halcon显然比opencv强太多，那么还有学习opencv的必要吗？ - mwwz的回答 - 知乎https://www.zhihu.com/question/447956881/answer/2782307466\n","categories":["图像处理"],"tags":["图像处理"]},{"title":"GrowthMindset","url":"/qqsnote/2024/03/20/GrowthMindset/","content":"Growth Mindset 成长思维, 是一个重要的心理学概念。斯坦福大学的行为心理学教授Carol S. Dweck是这一概念的提出者。她认为人的思维模式主要分为两种：成长型思维和固定型思维。\n拥有固定型思维的人认为，人的特质和能力是天生的，后天无法改变。而拥有成长型思维的人则认为，任何能力和技能都可以通过后天努力而得到发展。他们更乐于接受挑战，并且积极提升自己的能力和技能。这种成长型思维的人更加坚韧，对挑战持积极态度，并相信自己的能力可以通过持续努力而提升。\n相较于固定型思维模式公司的主管，成长型思维模式公司主管对员工的评价明显更为正面。他们更倾向相信其雇员有管理潜能，并赞扬员工富有创新精神，善于与人合作，并且笃实好学，努力成长。\n总之，Growth mindset是一个积极的概念，它鼓励人们以开放和发展的眼光看待自己和他人，相信能力和技能是可以通过努力和学习来提升的。这种心态对于个人的成长和发展，以及组织的繁荣和成功都具有重要意义。\n","tags":["成长思维"]},{"title":"HelmetJS","url":"/qqsnote/2019/12/26/HelmetJS/","content":""},{"title":"Hilo","url":"/qqsnote/2023/09/12/Hilo/","content":"阿里开源的H5互动游戏SDK Hilo TutorialGithub: Hilo\n"},{"title":"高性能SQL-索引","url":"/qqsnote/2018/08/31/HighPerformanceSQL-Index/","content":"","categories":["数据库"],"tags":["SQL"]},{"title":"http缓存","url":"/qqsnote/2022/08/12/HttpCache/","content":"http缓存区别于浏览器缓存,浏览器缓存指localStorage(max 5Mb)、sessionStorage和cookies(max 4kb)。这些功能主要用于缓存一些必要的数据，比如用户信息，有些数据则是传到后端的参数.http缓存是当发送http请求时，与本地副本比对，如果本地已缓存则从本地副本读取而不是服务器端。\n目的：\n\n减少不必要的网络传输\n减少不必要的服务器负载\n提高加载速度\n\n分类\n\n强制缓存\n协商缓存强制/协商指的是与服务器交互与否, Cache-Control:max-age=N 有效期内从缓存读取 不需与服务器交互，即强制缓存；&#x2F;&#x2F;服务端往响应头中写入需要缓存的时间res.writeHead(200,&#123;    &#39;Cache-Control&#39;:&#39;max-age&#x3D;10&#39;&#125;);\n参数：\nmax-age 决定客户端资源被缓存多久。\ns-maxage 决定代理服务器缓存的时长。\nno-cache 强制进行协商缓存。\nno-store 禁止任何缓存策略。\npublic 资源即可以被浏览器缓存也可以被代理服务器缓存。\nprivate 资源只能被浏览器缓存。\n\n协商缓存工作流中，Cache-Control须设置 no-cache 以进行协商缓存，其响应header中要携带资源的修改时间res.setHeader(&#39;last-modified&#39;, modifiedTime.toUTCString());res.serHeader(&#39;Cache-Control&#39;, &#39;no-cache&#39;);客户端读取到last-modified，则下次请求标头中须携带该修改时间以请求服务端确认资源是否已发生修改accept:image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,image&#x2F;svg+xml,image&#x2F;*,*&#x2F;*;q&#x3D;0.8accept-encoding:gzip, deflate, br, zstdaccept-language:en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7cache-control: no-cacheIf-Modified-Since: Tue, 18 Jan 2022 01:30:00 GMT服务端收到请求还需核对该时间if(req.headers.ifModifiedSince &#x3D;&#x3D;&#x3D; modifiedTime.toUTCString())&#123;    res.statusCode &#x3D; 304;    res.end();&#125;else&#123;    res.setHeader(&#39;last-modified&#39;, modifiedTime.toUTCString());    res.serHeader(&#39;Cache-Control&#39;, &#39;no-cache&#39;);    res.end(data);&#125;此外，为防止时间精度或其他因素使资源修改后，拿到的ModifiedTime相同，可使用Etag携带文件指纹(hash code) 前端收到Etag会携带If-None-Match到下次请求中确认\n用户刷新/访问资源行为的不同方式，会采用不同的缓存策略\n\n地址栏/链接访问url  强制缓存 在缓存数据未失效（max-age范围内）的情况下，可以直接使用缓存数据，不需要再请求服务器\nF5/刷新/右键菜单重新加载\nCtl+F5 （完全不使用HTTP缓存）\n\n对比缓存: 浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给浏览器，浏览器将二者备份至缓存数据库中。当浏览器再次请求数据时，浏览器将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。\n对于对比缓存，响应 header 中会有两个字段来标明规则：Last-Modified / If-Modified-Since服务器响应请求时，会告诉浏览器资源的最后修改时间：Last-Modified，浏览器之后再请求的时候，会带上一个头：If-Modified-Since，这个值就是服务器上一次给的 Last-Modified 的时间，服务器会比对资源当前最后的修改时间，如果大于If-Modified-Since，则说明资源修改过了，浏览器不能再使用缓存，否则浏览器可以继续使用缓存，并返回304状态码。Etag  /  If-None-Match（优先级高于Last-Modified  /  If-Modified-Since）\n\n私有缓存和共享缓存私有缓存通常存在浏览器端，只存在本地，不会与其他客户端共享，因此可以保存个性化设置，部分资料中区分“浏览器缓存”和私有Http缓存的概念，“浏览器缓存”指localstorage sessionstorage cookies等Cache-Control: private共享缓存可细分为代理缓存和托管缓存，代理缓存是网络中间代理提供的缓存，在Https普及的现状下应用收到局限，托管缓存由服务开发人员明确部署，以降低源服务器负载并有效地交付内容。如反向代理、CDN 和 service worker 与缓存 API 的组合。\n开发对前端来说，缓存是缓存在前端，但实际上代码是后端的同学来写的。如果你需要实现前端缓存的话啊，通知后端的同学加响应头就好了。\n以node.js为例 对于需要强缓存的资源res.setHeader(&#39;Cache-Control&#39;, &#39;public, max-age&#x3D;xxx&#39;);协商缓存res.setHeader(&#39;Cache-Control&#39;, &#39;public, max-age&#x3D;0&#39;);res.setHeader(&#39;Last-Modified&#39;, xxx);res.setHeader(&#39;ETag&#39;, xxx);npmjs: fresh\n","categories":["前端技术"],"tags":["性能"]},{"title":"HomeAssistant","url":"/qqsnote/2025/11/17/HomeAssistant/","content":"HA发送指令直接控制小度音箱\n","categories":["物联网"]},{"title":"Https","url":"/qqsnote/2019/12/20/Https/","content":"\nhttps本身没有端口限制\nhttps支持传输ssl证书以避免服务端仿冒\nhttps报文使用对称加密 密钥包含在证书中\n\npostman的”验证ssl证书”开关： settings -&gt; General -&gt; SSL certificate verification \nssl certificate warning\n\nSSL证书不是来自公认的证书颁发机构(CA)\n数字证书信任链配置错误\n证书的域名匹配程度不完整\n证书已经过了有效期\n客户端不支持SNI协议由于第一条，开发环境的带自签名的https服务仅被本地认证，远程访问就会出现warning\n\n生成自签名证书信任证书实现局域网访问HTTPS\n","categories":["前端技术"],"tags":["https"]},{"title":"图像分割","url":"/qqsnote/2022/09/08/ImageSegmentation/","content":"\n基于阈值的图像分割\n边缘检测\n分离背景\nK-Means聚类\n均值漂移算法\n分水岭算法\n图像漫水填充分割\n\n阈值图像分割的效果取决于临界值的选取\n边缘检测根据像素值变化的特点 根据梯度值确定边界\nfindContours 和 drawContours是基于边缘检测的统计方法\n查找轮廓GrabCut算法 设置掩码矩阵（蒙版）分离前景和背景\nK-Means聚类\n第一步 确定K值 即将数据集分为K个族类\n第二部 从数据集中随机选择K个数据点作为质心（Centroid）\n\n","categories":["图像处理"],"tags":["OpenCV"]},{"title":"Identity Server","url":"/qqsnote/2021/09/24/IdentityServer/","content":"背景公司Legacy SSO使用场景已经很少， 逐步转向Azure ADB2C，员工常遗忘其Legacy SSO的密码，由于企业Azure ADB2C申请比较麻烦，而且资产系统需求未必符合普适性，故自行搭建SSO服务参考CNBlog:从零搭建一个IdentityServer\n需求对于从未接触过Legacy SSO的员工以及未来Legacy SSO废止的风险下，允许员工使用其工号或邮箱+密码或邮件验证码通过认证\n\n跳转到Identity Server使用工号或邮箱+密码认证\nNG Client APP使用Identity Server授予的access token访问后台\n忘记密码跳转到Identity Server使用邮箱验证码重置进阶\n将角色权限迁移至Identity Serveris4identity server4 是作为OpenID Connect provider中间件 \n\n有限的免费： free for dev/testing/personal projects and companies or individuals making less than 1M USD gross annnual revenue\n首先安装dotnet cli提供的identityserver模板dotnet new -i IdentityServer4.Templates提供了以下模板IdentityServer4 with AdminUI                          is4adminIdentityServer4 with ASP.NET Core Identity            is4aspidIdentityServer4 Empty                                 is4emptyIdentityServer4 with Entity Framework Stores          is4efIdentityServer4 with In-Memory Stores and Test Users  is4inmemIdentityServer4 Quickstart UI (UI assets only)        is4ui入门：入门项目包含三个部分，身份认证服务(https://localhost:5001), API(https://localhost:44323/identity), Client(一个console program)\n\n创建身份认证服务\ndotnet new is4empty -n IdentityServercd ..dotnet new sln -n Quickstartdotnet sln add .\\src\\IdentityServer\\IdentityServer.csproj\n在Config.cs中定义API scope\npublic static IEnumerable&lt;ApiScope&gt; ApiScopes &#x3D;&gt;        new ApiScope[]        &#123;            new ApiScope(&quot;api1&quot;, &quot;My API&quot;)        &#125;;\n在Config.cs中定义访问API的client\npublic static IEnumerable&lt;Client&gt; Clients &#x3D;&gt;        new Client[]         &#123;            new Client            &#123;                ClientId &#x3D; &quot;client&quot;,                ClientSecrets &#x3D;                &#123;                    new Secret(&quot;secrec&quot;.Sha256())                &#125;,                AllowedGrantTypes &#x3D; GrantTypes.ClientCredentials,                AllowedScopes &#x3D; &#123; &quot;api1&quot; &#125;            &#125;        &#125;;\n该client使用clientCredential(id+secret)认证 允许访问名为api1的scope在startup.cs中载入资源以及client\npublic void ConfigureServices(IServiceCollection services)&#123;    var builder &#x3D; services.AddIdentityServer()        .AddDeveloperSigningCredential()          .AddInMemoryApiScopes(Config.ApiScopes)        .AddInMemoryClients(Config.Clients);&#125;\n启动项目 导航到 https://localhost:5001/.well-known/openid-configuration\n\n创建一个API, 并使用上面的IdentityServer作认证\ndotnet new webapi -n Apidotnet sln add .\\Api\\Api.csproj\n受保护的接口(protected interface)\n[Route(&quot;identity&quot;)][ApiController][Authorize]public class IdentityController : ControllerBase&#123;    [HttpGet]    public IActionResult Get()    &#123;        return new JsonResult(from c in User.Claims select new &#123; c.Type, c.Value &#125;);    &#125;&#125;\n在startup.cs配置认证\npublic void ConfigureServices(IServiceCollection services)&#123;    ...    services.AddAuthentication(&quot;Bearer&quot;)    .AddJwtBearer(&quot;Bearer&quot;, options &#x3D;&gt; &#123;        options.Authority &#x3D; &quot;https:&#x2F;&#x2F;localhost:5001&quot;;        options.TokenValidationParameters &#x3D; new Microsoft.IdentityModel.Tokens.TokenValidationParameters        &#123;            ValidateAudience &#x3D; false        &#125;;    &#125;);&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123;    ...    app.UseAuthentication();    app.UseAuthorization();&#125;\n写一个发请求的console programdotnet new console -n Clientdotnet sln add .\\Client\\Client.csproj\n\n\nclass Program&#123;    public static async Task Main(string[] args)    &#123;        var client &#x3D; new HttpClient();        var disco &#x3D; await client.GetDiscoveryDocumentAsync(&quot;https:&#x2F;&#x2F;localhost:5001&quot;);        if (disco.IsError)        &#123;            Console.WriteLine(disco.Error);            return;        &#125;        var tokenResponse &#x3D; await client.RequestClientCredentialsTokenAsync(new ClientCredentialsTokenRequest        &#123;            Address &#x3D; disco.TokenEndpoint,            ClientId &#x3D; &quot;client&quot;,            ClientSecret &#x3D; &quot;secret&quot;,            Scope &#x3D; &quot;api1&quot;        &#125;);;        if (tokenResponse.IsError)        &#123;            Console.WriteLine(tokenResponse.Error);            return;        &#125;        Console.WriteLine(tokenResponse.Json);        &#x2F;&#x2F; call api        var apiClient &#x3D; new HttpClient();        apiClient.SetBearerToken(tokenResponse.AccessToken);        var response &#x3D; await apiClient.GetAsync(&quot;https:&#x2F;&#x2F;localhost:44323&#x2F;identity&quot;);        if (!response.IsSuccessStatusCode)        &#123;            Console.WriteLine(response.StatusCode);        &#125;        else        &#123;            var content &#x3D; await response.Content.ReadAsStringAsync();            Console.WriteLine(JArray.Parse(content));        &#125;    &#125;&#125;\n在vs中右键solution在Properties中配置Multiple startup projects，确认后开始运行(F5)右键Client project —&gt; Debug —&gt; start new instance 因为控制台程序执行后关闭 在Program中打断点\n\n认证之后是授权配置API使用Policypublic void ConfigureServices(IServiceCollection services)&#123;    ...    services.AddAuthorization(options&#x3D;&gt; &#123;        options.AddPolicy(&quot;ApiScope&quot;, policy &#x3D;&gt;        &#123;            policy.RequireAuthenticatedUser();            policy.RequireClaim(&quot;scope&quot;, &quot;api1&quot;);        &#125;);    &#125;);&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123;    ...    app.UseEndpoints(endpoints &#x3D;&gt;    &#123;        endpoints.MapControllers()        .RequireAuthorization(&quot;ApiScope&quot;);    &#125;);&#125;\n进阶：\n以上是使用写死的id+secret通过认证，下面加入交互UI创建Mvc Client\n配置认证\n配置OpenId Connect\n\nSimilar to OAuth 2.0, OpenID Connect also uses the scopes concept. Again, scopes represent something you want to protect and that clients want to access. In contrast to OAuth, scopes in OIDC don’t represent APIs, but identity data like user id, name or email address. \n\n\n在Identity Server注册Mvc Client\n\n\n使用entity framework库保存配置以及运行中数据官方文档中基于上述Quickstart项目扩展，使前者In Memery的配置以及运行数据可以保存到数据库github上的sample与使用is4ef模板生成的项目有差别download sample源码 在此基础上开发自己的需求 加入IConfiguration并从appsettings.json读取connectionstring\n源码在startup中定义了一个InitializeDatabase方法 在第一次启动时执行以初始化SQL Server数据库 之后就把它注释掉\n将我们的client写入到数据库配置INSERT INTO [dbo].[Clients]           ([Enabled]           ,[ClientId]           ,[ProtocolType]           ,[RequireClientSecret]           ,[ClientName]           ,[Description]           ,[ClientUri]           ,[LogoUri]           ,[RequireConsent]           ,[AllowRememberConsent]           ,[AlwaysIncludeUserClaimsInIdToken]           ,[RequirePkce]           ,[AllowPlainTextPkce]           ,[RequireRequestObject]           ,[AllowAccessTokensViaBrowser]           ,[FrontChannelLogoutUri]           ,[FrontChannelLogoutSessionRequired]           ,[BackChannelLogoutUri]           ,[BackChannelLogoutSessionRequired]           ,[AllowOfflineAccess]           ,[IdentityTokenLifetime]           ,[AllowedIdentityTokenSigningAlgorithms]           ,[AccessTokenLifetime]           ,[AuthorizationCodeLifetime]           ,[ConsentLifetime]           ,[AbsoluteRefreshTokenLifetime]           ,[SlidingRefreshTokenLifetime]           ,[RefreshTokenUsage]           ,[UpdateAccessTokenClaimsOnRefresh]           ,[RefreshTokenExpiration]           ,[AccessTokenType]           ,[EnableLocalLogin]           ,[IncludeJwtId]           ,[AlwaysSendClientClaims]           ,[ClientClaimsPrefix]           ,[PairWiseSubjectSalt]           ,[Created]           ,[Updated]           ,[LastAccessed]           ,[UserSsoLifetime]           ,[UserCodeType]           ,[DeviceCodeLifetime]           ,[NonEditable])     VALUES           (1           ,&#39;angular_spa&#39;           ,&#39;oidc&#39;           ,0           ,null           ,null           ,null           ,null           ,0           ,1           ,0           ,1           ,0           ,0           ,0           ,null           ,1           ,null           ,1           ,0           ,300           ,null           ,3600           ,300           ,null           ,2592000           ,1296000           ,1           ,0           ,1           ,0           ,1           ,1           ,0           ,&#39;client_&#39;           ,null           ,SYSDATETIME()           ,null           ,null           ,null           ,null           ,300           ,0)写入client scopeINSERT INTO [dbo].[ClientScopes]           ([Scope]           ,[ClientId])     VALUES           (&#39;openid&#39;           ,3);\t\t   INSERT INTO [dbo].[ClientScopes]           ([Scope]           ,[ClientId])     VALUES           (&#39;profile&#39;           ,3);\t\t   INSERT INTO [dbo].[ClientScopes]           ([Scope]           ,[ClientId])     VALUES           (&#39;api1&#39;           ,3)\nclient cors配置INSERT INTO [dbo].[ClientCorsOrigins]           ([Origin]           ,[ClientId])     VALUES           (&#39;http:&#x2F;&#x2F;localhost:4200&#39;           ,3)到这一步 angular spa 可以完成到identity server的跳转但是显示授权错误“Sorry, there was an error : unauthorized_clientUnknown client or client not enabled”INSERT INTO [dbo].[ClientGrantTypes]           ([GrantType]           ,[ClientId])     VALUES           (&#39;implicit&#39;           ,3)GOINSERT INTO [dbo].[ApiResources]           ([Enabled]           ,[Name]           ,[DisplayName]           ,[Description]           ,[AllowedAccessTokenSigningAlgorithms]           ,[ShowInDiscoveryDocument]           ,[Created]           ,[Updated]           ,[LastAccessed]           ,[NonEditable])     VALUES           (1           ,&#39;api1&#39;           ,&#39;AMS API&#39;           ,null           ,null           ,1           ,SYSDATETIME()           ,null           ,null           ,0)GO安装entityframework sqlserver依赖dotnet add package IdentityServer4.EntityFrameworkdotnet add package Microsoft.EntityFrameworkCore.SqlServer\n模板使用的是sqlitedb 见startup.csservices..AddConfigurationStore(options &#x3D;&gt;&#123;    options.ConfigureDbContext &#x3D; builder &#x3D;&gt; builder.UseSqlite(connectionString);&#125;)\n\nConfigurationDbContext  - 配置数据如 clients, resources, scopes\nPersistedGrantDbContext - 临时处理数据如 authorization codes, refresh tokens\n\n用户数据库上下文dotnet ef migrations add InitUserContext -c AMSIS.Data.UserContext -o Data&#x2F;Migrations&#x2F;UserDbUpdate-Database -c AMSIS.Data.UserContext\nlogin/logout workflow 和 重定向当token无效时（比如后台校验jwt返回前台401）前台spa应跳转至登录页如 http://localhost:44365/account/login?returnUri=http%3A//localhost%3A4200/passport/callback\nspa应在路由到callback时从url中取得token存localstorage\nregistry workflow跳转到注册页 填表单 保存profile应在业务领域分离出用户/账户信息 使用从identityserver取得的openid关联本业务领域数据\n返回包含自定义Claim的Profile为自己的用户体系实现认证接口部署到httplax cookie policy\n","tags":[".Net","认证&授权"]},{"title":"八股文-手写Promise","url":"/qqsnote/2024/11/19/InterviewQuestions-Promise/","content":"Promise的调用形如function asyncFunc(data)&#123;    return new Promise((resolve, reject)&#x3D;&gt;&#123;        execute(data)        if(flag) &#123;            resolve(res)        &#125;else&#123;            reject(err)        &#125;    &#125;)&#125;asyncFunc(data).then(res&#x3D;&gt;&#123;return asyncFunc(res.data)&#125;, err&#x3D;&gt;&#123;console.log(&quot;step1 error&quot;)&#125;).then(res&#x3D;&gt;&#123;return asyncFunc(res.data)&#125;, err&#x3D;&gt;&#123;console.log(&quot;step2 error&quot;)&#125;).then(res&#x3D;&gt;&#123;return asyncFunc(res.data)&#125;, err&#x3D;&gt;&#123;console.log(&quot;step3 error&quot;)&#125;).catch(err&#x3D;&gt;&#123;console.log(&quot;mission defeated&quot;)&#125;)Promise意在解决异步函数嵌套时产生的回调地狱，使得异步操作可控以及可组合\n\nMyPromise应该是一个构造函数，参数是以两个回调方法为形参的函数体 函数体内执行若干异步操作，根据异步状态选择执行上述回调方法\nMyPromise内部须有一个state 待定(pending)成功(fulfilled)/失败(rejected)\n从asyncFunc定义可知resolve，reject用于改变state状态(state后不再改变)而且分别将参数result赋给onFulfilled,参数error赋给onRejected回调. 注意onFulfilled、onRejected是then的两个参数(函数调用的实参)并不是resolve、reject\n成员函数then函数根据state状态，成功则执行onFulfilled回调，失败则执行onRejected回调\nthen返回另一个MyPromise(从而可进行链式调用) 新的MyPromise中的异步操作将成为等待前面的onFulfilled、onRejected执行结果， 如何resolve/reject由onFulfilled、onRejected的函数体控制以此类推\ncatch与then类似 只注册失败的回调函数class MyPromise&#123;    state &#x3D; &#39;pending&#39;    result &#x3D; undefined    error &#x3D; undefined    constructor(executor)&#123;        const resolve &#x3D; &#123;            if(this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;                this.state &#x3D; &#39;fulfilled&#39;            &#125;        &#125;        const reject &#x3D; &#123;            if(this.state &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;                this.state &#x3D; &#39;rejected&#39;            &#125;        &#125;        executor(resolve, reject)    &#125;    function then(onFulfilled, onRejected)&#123;        return new MyPromise((resolve, reject)&#x3D;&gt;&#123;            if(this.state &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;                const result &#x3D; onFulfilled(this.result)                resolve(result)            &#125;            if(this.state &#x3D;&#x3D;&#x3D; &#39;rejected&#39;)&#123;                const error &#x3D; onRejected(this.error)                reject(error)            &#125;        &#125;)    &#125;    function catch(onRejected)&#123;        return this.then(null, onRejected);    &#125;&#125;\n注意：代码尚缺少形参类型判断及异常处理(try catch throw) 且Promise还有其他API如resolve all finally…\n\n精进参考-&gt; 掘金：你能手写一个Promise吗\n\n如何获取promise多个then之后的值\n\nPromise.all vs Promise.racePromise.all “要么全部成功 要么全部失败” 异步过程全部成功返回各结果组成的数组 任一个reject会立即返回失败不等待其他异步结果\nPromise.race 赛跑 返回最先完成的结果 可用于请求超时返回的逻辑\n返回各异步api的成功状态可以用Promise.allSettled 结果数组的项封装为：{state: ‘fulfilled’|’rejected’, value, reason}\n手写这三个语法糖 遍历参数集合(异步方法数组)即可 区别在于是否提前返回 亦或结果集项数等于参数长度时返回\nPromise.all:\n\n用计数器跟踪完成数量\n保持结果顺序与输入顺序一致\n任一失败立即 reject，不等待其他\n\nPromise.race:\n\n最简单，只需要监听第一个完成的事件\n空数组永远 pending（这是标准行为）\n\nPromise.allSettled:\n\n永远 resolve，不会 reject\n每个结果都包装成 &#123;status, value/reason&#125; 格式\n无论成功失败都要计数\n\n","categories":["前端技术"],"tags":["javascript","Web开发"]},{"title":"八股文-树","url":"/qqsnote/2024/11/20/InterviewQuestions-Tree/","content":"树是具有分层数据功能的抽象模型，前端中常见的应用场景如Dom树，级联菜单，treeview控件等\n","categories":["前端技术"],"tags":["javascript","Web开发"]},{"title":"自我介绍","url":"/qqsnote/2019/05/14/IntroduceYourself/","content":"面试自我介绍五句话公式：我是谁+从哪里来+我做过什么+有什么成绩+为什么能胜任\n","categories":["职场经验"],"tags":["面试"]},{"title":"Interview Questions","url":"/qqsnote/2019/05/14/InterviewQuestions/","content":"该职位期望招聘高级软件开发人员 以完成基础软件开发 具备独立搭建框架能力和较丰富的前后端开发经验\n1介绍一下原型链2变量提升\njs中变量和函数的声明都会被提升到函数最顶部\n这使得变量和函数在coding时可以先调用在声明\n\n2属性绑定实现视图更新的原理Angular的双向绑定原理：\nReact的虚拟dom和diff算法虚拟dom是轻量化的js对象 用于描述真实的dom 当状态改变时 react通过比较虚拟dom的差异 最小化改动真实dom 从而提升性能\n3编写单元测试用例4只执行一次的生命周期钩子 constructor init之间进行了什么\n\n\n\n钩子\n目的\n\n\n\n\n\n\n\n\n\nngAfterContentInit | 在Angular将外部内容放到视图内之后。ngAfterContentChecked | 在Angular检测放到视图内的外部内容的绑定后。ngAfterViewInit | 在Angular创建了组件视图之后。ngAfterViewChecked | 在Angular检测了组件视图的绑定之后。\n\nconstructor 依赖注入\n5依赖注入 反射\n6面向对象的核心——抽象封装 继承 多态是面向对象的三个核心特征 对应的目的性是是代码具备可重用性、可扩展性，即可减少重复代码，进而使程序增加可维护性\n面向对象未必是先进的，编程模式要根据需求而定，避免脱裤子放屁，近年流行的函数式编程就是与面向对象相斥的，在函数式编程中减少使用保存状态的‘对象’\n7docker8持续集成前端表格1000w行数据流畅渲染deepseek —— 前端一、技术深度扩展能力核心原理掌握\n深入解释DOM树渲染机制（参考论文提及的节点树形结构抽象能力）\n阐述AJAX异步通信的底层实现（如XHR对象与Fetch API差异）\n展示CSS渲染层合成原理（如重排/重绘优化策略）\n性能优化体系\n优化维度 具体措施 考核要点网络层面 HTTP/2协议应用、CDN加速策略 减少RTT时间资源加载 按需加载、Tree Shaking 首屏加载时间优化代码执行 Web Workers多线程优化 主线程阻塞规避\n二、工程化实践能力架构设计思维\n展现B/S架构系统设计经验（参考论文的三层架构设计）\n演示模块化开发能力（如Web Components应用）\n数据库优化方案（MySQL索引策略、NoSQL选型）\n质量保障体系\n单元测试覆盖率（Jest/Mocha）\nE2E测试实施（Cypress/Puppeteer）\n持续集成部署（Jenkins/Travis CI）\n三、软性能力表现沟通演示技巧\n使用语音模拟系统进行技术方案阐述（参考论文的语音面试模块）\n白板编码时标注关键路径时间复杂度\n职业形象管理\nVR试衣系统准备的职业着装认知（参考论文的虚拟试衣功能）\n简历制作突出开源项目贡献（GitHub Star/Fork数据）\n四、前沿技术敏感度新兴技术栈\nWebAssembly在性能敏感场景的应用\nServerless架构的BFF层实践\nWebGL/WebXR三维交互开发经验\n标准演进跟踪\nCSS Houdini底层API实践\nECMAScript提案阶段特性预研\nW3C新规范解读（如WebGPU）\n建议候选人准备3-5个典型优化案例，量化展示性能提升指标（如首屏加载从2.1s优化至780ms），并携带移动端适配、跨平台框架（Electron/Flutter）等扩展能力的实证材料。\n","categories":["职场经验"],"tags":["面试"]},{"title":"Inventing JavaScript","url":"/qqsnote/2020/02/20/JSInventingLang/","content":"\n关于0.1+0.2==0.3 false0.1 + 0.2不等于0.3？为什么JavaScript有这种“骚”操作？关于浮点数的二进制表示，js浮点数精度(存目)\n保留2位小数Number.prototype.toFixed 返回指定小数位数的字符串 必要时四舍五入 且必要时以0补足位数返回number的方法不如用类似 Math.round(num * 100) / 100 保留两位小数\n动态语言Dynamic Programming Language 动态语言或动态编程语言，程序在运行时可以改变其结构：新的函数可以被引进，已有的函数可以被删除等在结构上的变化。动态语言如Javascript Python Ruby等 C/C++ Jave则不是\n另外 图灵完备\nJS TipsCaps lock sensitivevar input &#x3D; document.getElementsByTag(&#39;input&#39;)[0];input.addEventListener(&#39;keyup&#39;,function(event)&#123;console.log(event.getModifierState(&#39;CapsLock&#39;))&#125;);\ngetModifierState方法挂在KeyboardEvent或者MouseEvent上，可获取的键盘状态见MDN:KeyboardEvent.getModifierState()\n运算符\n幂运算 2**10=1024\n\nthis\nthis的设计目的是在函数体内部，指代函数当前的运行环境var f &#x3D; function () &#123;  console.log(this.x);&#125;var x &#x3D; 1;var obj &#x3D; &#123;  f: f,  x: 2,&#125;;&#x2F;&#x2F; 全局环境执行f() &#x2F;&#x2F; 1&#x2F;&#x2F; obj 环境执行obj.f() &#x2F;&#x2F; 2另外，严格模式(‘use strict’)下，全局环境下运行时，this不会自动绑定到‘全局对象’上，将变量绑定到全局对象需要显式调用形如global.name = ‘Global’\n\n常用处理\n\n\n\n应用场景标题\n描述\n补充1\n补充2\n\n\n\n\n数组去重\nArray.from(new Set(array))\n通过内置数据解构特性进行去重  [] =&gt; set =&gt; []\n通过遍历并判断是否存在进行去重[many items].forEach(item =&gt; (item &lt;不存在于&gt; uniqueArr) &amp;&amp; uniqueArr.push(item))\n\n\n数组的最后一个元素\n获取数组中位置最后的一个元素\n使用array.at(-1)\n略\n\n\n数组对象的相关转换\n略\n对象到数组：Object.entries()\n数组到对象：Obecjt.fromEntries()\n\n\n短路操作\n通过短路操作避免后续表达式的执行\na或b：a真b不执行\na且b：a假b不执行\n\n\n基于默认值的对象赋值\n通过对象解构合并进行带有默认值的对象赋值操作\n&#123;...defaultData, ...data&#125;\n略\n\n\n多重条件判断优化\n单个值与多个值进行对比判断时，使用includes进行优化\n[404,400,403].includes\n略\n\n\n交换两个值\n通过对象解构操作进行简洁的双值交换\n[a, b] = [b, a]\n略\n\n\n位运算\n通过位运算提高性能和简洁程度\n按位与(&amp;)或(\\\n)按位取反(~) 取整~~、&lt;&lt;、&gt;&gt;\n&gt;&gt;&gt;移位\n\n\nreplace()的回调\n通过传入回调进行更加细粒度的操作\n略\n略\n\n\nsort()的回调\n通过传入回调进行更加细粒度的操作\n根据字母顺序排序\n根据真假值进行排序\n\n\n\n\ncall 和 apply&#x2F;&#x2F; 已有构造函数function Product(name, price) &#123;  this.name &#x3D; name;  this.price &#x3D; price;&#125;&#x2F;&#x2F; 在新函数中复用已有逻辑function Food(name, price) &#123;  Product.call(this, name, price); &#x2F;&#x2F; 实际上相当于将构造函数Product的两行拿过来  this.category &#x3D; &#39;food&#39;;&#125;&#x2F;&#x2F; testconst bread &#x3D; new Food(&#39;bread&#39;, 0.8) &#x2F;&#x2F; Food &#123;name: &quot;bread&quot;, price: 0.8, category: &quot;food&quot;&#125;\nFunctionX.call(thisArg,…args)中的第一个参数也可以是对象，函数相当于将剩余参数以FunctionX的实现方式应用到该对象内返回一个结果apply与call的区别仅在：剩余参数是数组，即FunctionX.call(thisArg,[…args])\nbindbind是基于call或apply实现的函数原型方法 FunctionX.bind(thisArg,…args)返回一个新的函数，该函数套用FunctionX的样子，但以thisArg代替FunctionX的this，剩余参数填补FunctionX所需参数(即结果函数所需参数为FunctionX所需参数减去…args)模拟实现Function.prototype.bind &#x3D; function (context) &#123;    &#x2F;&#x2F; 调用 bind 的不是函数，需要抛出异常    if (typeof this !&#x3D;&#x3D; &quot;function&quot;) &#123;      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);    &#125;        &#x2F;&#x2F; this 指向调用者    var self &#x3D; this;    &#x2F;&#x2F; 实现第2点，因为第1个参数是指定的this,所以只截取第1个之后的参数    var args &#x3D; Array.prototype.slice.call(arguments, 1);        &#x2F;&#x2F; 创建一个空对象    var fNOP &#x3D; function () &#123;&#125;;        &#x2F;&#x2F; 实现第3点,返回一个函数    var fBound &#x3D; function () &#123;        &#x2F;&#x2F; 实现第4点，获取 bind 返回函数的参数        var bindArgs &#x3D; Array.prototype.slice.call(arguments);        &#x2F;&#x2F; 然后同传入参数合并成一个参数数组，并作为 self.apply() 的第二个参数        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));        &#x2F;&#x2F; 注释1    &#125;        &#x2F;&#x2F; 注释2    &#x2F;&#x2F; 空对象的原型指向绑定函数的原型    fNOP.prototype &#x3D; this.prototype;    &#x2F;&#x2F; 空对象的实例赋值给 fBound.prototype    fBound.prototype &#x3D; new fNOP();    return fBound;&#125;关于替换this的操作可用于回调函数调用类函数, 如下类型A中定义回调函数，该回调函数会作为目标对象B的函数形参，process是类A的函数，但如果在目标对象B中调用callback函数，函数中的this会指向到Bcallback &#x3D; (response)&#x3D;&gt;&#123;  this.process(response) &#x2F;&#x2F; 这里的this指向当前运行环境&#125;B.getDataAsync(this.callback)应使用bindB.getDataAsync(this.callback.bind(this))\n柯里化Curryingstyle&#x3D;function()&#123;this.x&#x3D;&quot;&quot;;this.y&#x3D;&quot;&quot;;&#125; &#x2F;&#x2F; 构造函数stylestyle.prototype.addA&#x3D;function()&#123;  this.A&#x3D;&#39;A&#39;  return this &#125;style.prototype.addB&#x3D;function()&#123;  this.B&#x3D;&#39;B&#39;  return this&#125;style.prototype.addC&#x3D;function()&#123;  this.C&#x3D;&#39;C&#39;  return this&#125;&#x2F;&#x2F; testxxx&#x3D;new style()xxx.addA()xxx.addB().addC()\nGarbage Collection\n游离dom\n  let root&#x3D;document.getElementById(&quot;root&quot;)for(let i&#x3D;0;i&lt;2000;i++)&#123;    let div&#x3D;document.createElement(&quot;div&quot;)    root.appendChild(div)&#125;document.body.removeChild(root)\n  此时document中移除了dom，但内存中root还在，而且上千个子元素仍然被root对象引用，应设root=null解除引用\n\nclearInterval和clearTimeOut\n\n\n关于严格模式strict mode\n通知浏览器以严格模式运行脚本，严格模式下会将一些在非严格模式下被忽略的错位识别为异常，一些静默行为（无效但非异常操作）会被禁止\n\n防止无意添加全局变量，声明全局变量必须用global关键字\n静默行为被禁止 抛出TypeError&#x2F;&#x2F; 如无效的赋值 NaN&#x3D;0&#x2F;&#x2F; 写入不可写属性var obj&#x3D;&#123;&#125;Object.defineProperty(obj, &#39;x&#39;, &#123;value:0, writable:false&#125;)&#x2F;&#x2F; 写入只读var obj&#x3D;&#123;  get x()&#123;    return 0;  &#125;&#125;obj.x &#x3D; 2&#x2F;&#x2F; 扩展不可扩展对象var fixed &#x3D; &#123;&#125;Object.preventExtensions(fixed)fixed.newProp &#x3D; 0\nvanilla.jsit’s a joke. 这是一个空的js，用以提醒其他开发者使用plain JavaScript实现，而不要引入任何library\n\njavascript 手写面试题\ntask 和 microtaskTasks, microtasks, queues and schedulesconsole.log(&#39;script start&#39;); &#x2F;&#x2F; tasksetTimeout(function () &#123;  console.log(&#39;setTimeout&#39;); &#x2F;&#x2F; scheduled task&#125;, 0);Promise.resolve()  .then(function () &#123;    console.log(&#39;promise1&#39;); &#x2F;&#x2F; microtask  &#125;)  .then(function () &#123;    console.log(&#39;promise2&#39;);  &#125;);&#x2F;&#x2F; 结果：&#x2F;&#x2F; script start&#x2F;&#x2F; promise1&#x2F;&#x2F; promise2&#x2F;&#x2F; setTimeout至少Chrome中, Promise.resolve().then()中的回调作为microtask会立即排队等待当前任务执行完， 而setTimeout的回调则在给定延迟之后，排队任务队列中。\n节流和防抖防抖，全时间内后面的覆盖前面的function debounce(fn, wait)&#123;  let timeout  return function(...args)&#123;    clearTimeout(timeout)    timeout &#x3D; setTimeout(()&#x3D;&gt; &#123;      fn.apply(this, args)    &#125;, wait)  &#125;&#125;事实上带有 this 的函数在使用生命周期钩子的vue/react组件中可能并不好用，应在组件范围声明timer, 在响应函数中clear并重新赋值\n注意组件unmount时清理timer避免泄露\n节流var throttle &#x3D; function(delay, action)&#123;  &#x2F;&#x2F; 这里是个全局变量  var last &#x3D; 0  return function()&#123;    var curr &#x3D; new Date()    if (curr - last &gt; delay)&#123;      action.apply(this, arguments)      last &#x3D; curr     &#125;  &#125;&#125;\n禁用文字选中document.onmousemove &#x3D; window.getSelection    ? window.getSelection().removeAllRanges()    : document.selection.empty();\n","categories":["前端技术"],"tags":["javascript"]},{"title":"Jasmine","url":"/qqsnote/2020/12/11/Jasmine/","content":"测试驱动开发(Test Driven Development, TDD)和行为驱动开发(Behavior Driven Development, BDD)Jasmine 通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法, 行为驱动开发人员使用混合了领域中统一的语言的母语语言来描述他们的代码的目的\n被测系统(System under test, SUT)\n\n单测不负责检查跨类或者跨系统的交互逻辑，那都是集成测试的范围\n单测不能受到外界环境的影响, 依赖需要用本地实现注入，或者提供一个mock(桩对象)\n单测需要能快速执行，有必要在每次修改代码时运行单测\n单测应随编码进行，补单测是没有意义的\n\n├───lib│   └───jasmine-3.4.0│           boot.js│           jasmine-html.js│           jasmine.css│           jasmine.js│           jasmine_favicon.png├───spec│       PlayerSpec.js│       SpecHelper.js└───src        Player.js        Song.js\nspec + src文件夹是栗子\n笔记目的导向：\n\nspec.ts写的啥(Jasmine 单元测试的书写语法)\n组件声明周期中应该存在哪些用例(如实例化，输入/输出，方法，释放)\n依赖项的处理describe(&quot;Player&quot;, function() &#123;  var player;  var song;  beforeEach(function() &#123;    player &#x3D; new Player();    song &#x3D; new Song();  &#125;);  it(&quot;should be able to play a Song&quot;, function() &#123;    player.play(song);    expect(player.currentlyPlayingSong).toEqual(song);    &#x2F;&#x2F;demonstrates use of custom matcher    expect(player).toBePlaying(song);  &#125;);  describe(&quot;when song has been paused&quot;, function() &#123;    beforeEach(function() &#123;      player.play(song);      player.pause();    &#125;);    it(&quot;should indicate that the song is currently paused&quot;, function() &#123;      expect(player.isPlaying).toBeFalsy();      &#x2F;&#x2F; demonstrates use of &#39;not&#39; with a custom matcher      expect(player).not.toBePlaying(song);    &#125;);    it(&quot;should be possible to resume&quot;, function() &#123;      player.resume();      expect(player.isPlaying).toBeTruthy();      expect(player.currentlyPlayingSong).toEqual(song);    &#125;);  &#125;);  &#x2F;&#x2F; demonstrates use of spies to intercept and test method calls  it(&quot;tells the current song if the user has made it a favorite&quot;, function() &#123;    spyOn(song, &#39;persistFavoriteStatus&#39;);    player.play(song);    player.makeFavorite();    expect(song.persistFavoriteStatus).toHaveBeenCalledWith(true);  &#125;);  &#x2F;&#x2F;demonstrates use of expected exceptions  describe(&quot;#resume&quot;, function() &#123;    it(&quot;should throw an exception if song is already playing&quot;, function() &#123;      player.play(song);      expect(function() &#123;        player.resume();      &#125;).toThrowError(&quot;song is already playing&quot;);    &#125;);  &#125;);&#125;);\ninit with Node.jsnpm install --save-dev jasminenpx jasmine init\ndescribe以describe分组specs,它代表一组相似的测试用例,通常有 2 个参数：字符串和方法。字符串作为特定 Suite 的名字和标题。方法是包含实现的代码。describe (&#39;HeroesService (with spies)&#39;, () &#x3D;&gt; &#123;    ...&#125;);describe(&#39;HeroesService (with mocks)&#39;, () &#x3D;&gt; &#123;    ...&#125;);\nwaitForAsync TestBedimport &#123; ComponentFixture, fakeAsync, TestBed, waitForAsync &#125; from &#39;@angular&#x2F;core&#x2F;testing&#39;;describe(&#39;nz-table&#39;, () &#x3D;&gt; &#123;  let injector: Injector;  beforeEach(    waitForAsync(() &#x3D;&gt; &#123;          &#x2F;&#x2F;       injector &#x3D; TestBed.configureTestingModule(&#123;        imports: [BidiModule, NzTableModule],        declarations: [NzTestTableBasicComponent, NzTestTableScrollComponent, NzTableSpecCrashComponent, NzTestTableRtlComponent]      &#125;);      TestBed.compileComponents();    &#125;)  );  ...&#125;)\nit 和 specsspecs即specification(规则)，它们是一个个断言，可以是 true 或者 false。当每个 Spec 中的所有 expectations 都是 true，则通过测试。以it函数定义，与describe类似的，有 2 个参数：标题和方法。expect tobeexpect(true).toBe(true);expect(false).not.toBe(true); \n断言\ntoBe 和 toEqual 前者相当于比较运算符=== 后者比较字面量的值(对于对象进行属性的比较)\ntoMatch\ntoBeDefined 和 toBeNull\ntoContain\ntoBeGreaterThan 和 toBeLessThan\ntoBeCloseTo\ntoThrowbeforeEach和afterEach分别在每个it断言测试前/后调用spy存根(stub)和跟踪(track)任意函数spyOn(foo, &#39;setBar&#39;);  foo.setBar(123);  foo.setBar(456, &#39;another param&#39;);&#125;);it(&quot;tracks that the spy was called&quot;, function() &#123;  expect(foo.setBar).toHaveBeenCalled();&#125;);it(&quot;tracks that the spy was called x times&quot;, function() &#123;  expect(foo.setBar).toHaveBeenCalledTimes(2);&#125;);it(&quot;tracks all the arguments of its calls&quot;, function() &#123;  expect(foo.setBar).toHaveBeenCalledWith(123);  expect(foo.setBar).toHaveBeenCalledWith(456, &#39;another param&#39;);&#125;);\nspy一个foo对象上的setBar方法，分别断言该方法被调用、被调用若干次、被以某某参数调用很多时候用spy对应模拟对象\n\n用例","categories":["工具"],"tags":["Jasmine"]},{"title":"JMS","url":"/qqsnote/2019/04/10/JMS/","content":"","categories":["编程语言"],"tags":["Java"]},{"title":"Jfrog","url":"/qqsnote/2021/10/18/Jfrog/","content":""},{"title":"Kubernetes","url":"/qqsnote/2020/12/17/Kubernetes/","content":"《What is kubernetes》\nKubernetes 也称为 K8s，是用于自动部署、扩缩和管理容器化应用程序的开源系统。\n","categories":["容器"],"tags":["k8s"]},{"title":"Java流库","url":"/qqsnote/2019/01/28/JavaSteam/","content":"","categories":["编程语言"],"tags":["Java"]},{"title":"Law Of Attraction","url":"/qqsnote/2024/08/13/LawOfAttraction/","content":"“生活不会在你都准备好了以后才开始”。面试也一样，面试考验的不是那几轮的面试表现，而是你在长期生活、工作中积累的硬技能和软技能这些包括：你的专业能力，框架能力，思维能力，性格和心态，沟通能力，价值观等等。你只是刚好在这几轮的面试里表现出了你的这些积累，吸引到了对方，最后拿到了Offer。如果临时抱佛脚，光背概念和知识点，没有结合项目深入思考，那么面试的时候会表现的很空洞，给人的印象只是在堆砌一些关键词，这样面试挂掉的可能性就很高。———— Keraun https://zhuanlan.zhihu.com/p/145079928\n“费曼学习法”\n\n“有结果检验的导向 + 功利 + 逻辑”\n“现学现卖，消化最快”：刚学的知识教别人，消化最快\n“即时反馈”：学习可以达到即时反馈，这是游戏引人入胜的原理之一\n“简洁”：简洁不是真相的表现形式，而是真相本身\n\n"},{"title":"LLM","url":"/qqsnote/2025/03/05/LLM/","content":"TokenToken 是大型语言模型处理文本的基本单位。不同模型采用不同的分词方式(分词器)，当我们将一段文字输入模型时，模型会先将其拆解成 Token 序列，然后通过这些序列进行预测。\n分词器的具体执行原理较为复杂。我们可以简化地将分词器视为一个字典，对于字典中存在的内容，按照字典进行切分并替换为对应的数字Hello 你好呀 —&gt; Hello | _ | 你好 | 呀 (character: 9, token: 4)\n神经网络结构经典的卷积神经网络(CNN)结构包括以下层：\n输入层→卷积层→池化层→全连接层\n例如，假设要对0-9十个数字的图片进行分类，则全连接层的输出维度通常要设置为10，与输出分类一一对应。最后通过Softmax层，程序就可以将输出转换为每个类别的概率，概率最高的类别即为预测结果\n理解了CNN的输出层维度与分类任务的关系，我们也可以将这个概念迁移到对Transformer语言模型的理解上。尽管二者架构迥异，但是它们在输出层维度及分类任务的原理上仍有共性。\n语言模型本质上仍然是一种预测模型，它的核心目标，就是预测给定上下文的下一token。输入层在复杂的网络中传播，最终到达输出层，并且形成 N 个维度的输出。而每个维度正对应着分词表中的一个token。\n例如，如果分词表包含50000个token，那么Transformer模型的输出层将输出一个50000维的向量，向量中的每个元素代表对应token的概率。模型会选择概率最高的token作为预测的下一个token。\n\n早期llm的词表(Vocabulary)规模非常小，对应的输出维度也很小，因此相同环境下的理论计算性能更优。但是词表中没有出现的罕见词，有可能被拆分成子词甚至字符。就如ChatGPT 4.0及以前的Vocabulary，大部分中文字符，都会被拆分为2-3个子词token。显然，小规模的Vocabulary有更低的信息密度，相同的输入输出会占据更大的序列长度，这对于输入与输出都有很大的负面影响。\n以Llama2-7B模型为例，当词表从32k扩展至64k时，理论的嵌入矩阵参数量从32,000×4096增至65,536×4096，但平均序列长度缩短约30%，实际运行中的整体推理速度提升了15%。\n\nTransformerTransformer语言模型是基于自注意力机制构建的深度学习架构，已在自然语言处理领域引发革命性变革。核心架构：\n\n自注意力机制：通过计算序列中每个元素与其他元素的相关性权重（Q/K/V矩阵），捕捉长距离依赖关系。相比RNN/CNN，并行计算效率提升3-8倍（论文7、10）。\n\n多头注意力：将输入切分为多个子空间并行处理，可同时学习语法、语义等不同特征维度（论文3、12）。\n\n位置编码：采用正弦函数生成绝对位置编码（论文1）或相对位置编码（论文18），解决序列顺序建模问题。\n\n\n它的核心目标，就是预测给定上下文的下一token。\n这意味着，Transformer语言模型每输出一个token，输入数据便在神经网络经过了一次完整的传播。最终从词表查询到token string，展示在你眼前的，无论是一个字母，一个单词，甚至一个短语，从模型的角度来看，它们都是“平等的”——从模型角度来看，它们都是一个独立的预测单元，最终对应到词表中的一个 token。\n从输入角度上看，正如我们之前提到的，transformer的自注意力模型会将上下文加载到注意力矩阵中，上下文token数直接决定了矩阵的规模，由于O(n²)的时间复杂度，以及O(n²d)的空间复杂度（d为隐藏层维度），小规模词表所带来的低密度信息，可能反而削弱计算性能，增加资源消耗。\n从输出角度上看，更小的词表同样意味着单位token包含的信息更少，完成同样的一句输出将会经过更多的推理次数。\n"},{"title":"惰性函数","url":"/qqsnote/2018/12/20/LazyFunction/","content":"编写方法时，考虑到不同的业务需求（如首次加载配置项js片段，甚至是为了兼容不同内核浏览器）需要用多个if语句加以区分，这将使每次调用都回进行判断，然而往往在具体的情景下是不必要的，比如已经以chrome载入了该页面。一种思路是覆盖方法定义function addEvent (type, element, fun) &#123;    if (element.addEventListener) &#123;        addEvent &#x3D; function (type, element, fun) &#123;            element.addEventListener(type, fun, false);        &#125;    &#125;    else if(element.attachEvent)&#123;        addEvent &#x3D; function (type, element, fun) &#123;            element.attachEvent(&#39;on&#39; + type, fun);        &#125;    &#125;    else&#123;        addEvent &#x3D; function (type, element, fun) &#123;            element[&#39;on&#39; + type] &#x3D; fun;        &#125;    &#125;    return addEvent(type, element, fun);&#125;另一种思想是将函数定义引用一个自执行匿名函数var addEvent &#x3D; (function () &#123;    if (document.addEventListener) &#123;        return function (type, element, fun) &#123;            element.addEventListener(type, fun, false);        &#125;    &#125;    else if (document.attachEvent) &#123;        return function (type, element, fun) &#123;            element.attachEvent(&#39;on&#39; + type, fun);        &#125;    &#125;    else &#123;        return function (type, element, fun) &#123;            element[&#39;on&#39; + type] &#x3D; fun;        &#125;    &#125;&#125;)();第二种方式不会给第一次调用增加额外开销，而是在定义时进行了判断\n","categories":["前端技术"],"tags":["javascript"]},{"title":"线性代数","url":"/qqsnote/2025/07/26/LinearAlgebra/","content":"向量点乘内积 数量积\n$\\vec{a}$·$\\vec{b}$ = $x_1 x_2$ + $y_1y_2$ + $z_1z_2$= |$\\vec{a}$||$\\vec{b}$|cosθ\n标量结果 一个向量在另一个向量方向的投影与被投影向量模的乘积\n几何意义 对于单位向量 点乘结果取决于向量方向夹角 反映了方向的一致性\n向量叉乘外积 向量积\n名字由来是坐标分量做交叉相乘然后相减的操作\n\n\\vec{a} × \\vec{b} = \n\\left[\n \\begin{matrix}\n   x_1 \\\\\n   y_1 \\\\\n   z_1 \n  \\end{matrix}\n  \\right] \n  ×\n  \\left[\n \\begin{matrix}\n   x_2 \\\\\n   y_2 \\\\\n   z_2 \n  \\end{matrix}\n  \\right]\n  =\n   \\left[\n \\begin{matrix}\n   y_1z_2 - z_1y_2 \\\\\n   z_1x_2 - x_1z_2 \\\\\n   x_1y_2 - x_2y_1\n  \\end{matrix}\n  \\right]方向垂直与向量所在平面 符合右手法则\n几何意义 叉乘结果的正负可以反映方向关系$\\vec{a}$ × $\\vec{b}$ &gt; 0 ，$\\vec{a}$ 在 $\\vec{b}$ 右侧\n$\\vec{a}$ × $\\vec{b}$ &lt; 0 ，$\\vec{a}$ 在 $\\vec{b}$ 左侧\n","tags":["图形学"]},{"title":"LinuxResetPassword","url":"/qqsnote/2019/11/07/LinuxResetPassword/","content":"c.f. How do I reset a lost administrative password?\n","categories":["Linux"],"tags":["Linux"]},{"title":"Linux网卡重命名","url":"/qqsnote/2019/04/20/Linux-rename-networkdevice/","content":"查看RedHat版本cat &#x2F;etc&#x2F;redhat-releaseyum install nginxerror:cannot find a valid baseurl\npingconnect:network is unreachable\nls /etc/sysconfig/network-scripts/\nifcfg-enp0s3 ifcfg-lo ….其中ifcfg-lo是localhost配置将第一个配置文件重命名mv ifcfg-enp0s3 ifcfg-eth0查看网卡ip add显示了lo和enp0s3修改默认网卡设置编辑/etc/default/grub文件，在GRUB_CMD_LINE_LINUX=””项中，插入”net.ifnames=0 biosdevname=0”修改ip配置注意DEVICE&#x3D;eth0ONBOOT&#x3D;no &#x2F;&#x2F;设置开机启动网卡，将值修改为“yes”BOOTPROTO&#x3D;static &#x2F;&#x2F;默认为no，修改为static重启service network restart\nreboot\n","categories":["Linux"],"tags":["Linux"]},{"title":"安装Linux服务器","url":"/qqsnote/2019/12/29/LinuxServerSetUp/","content":"\n关于使用ubuntu发行版和centos发行版的倾向（存目）\n简单的ubuntu\n镜像实践日期：2019-12-29 ubuntu-18.04.3-live-server-amd64.iso\n安装和分区（存目）安装ssl配置网卡不知道怎么就安装了cloud image参考Configure Ubuntu Server 18.04 to use a static IP address\n在线安装Applications配置apache启用端口 /etc/apache2/ports.conf\n配置/etc/sites-availiable/yoursite.conf栗子：&lt;VirtualHost *:90&gt;\tServerName www.example.com\tDirectoryIndex index.html\tDocumentRoot &#x2F;home&#x2F;qqs&#x2F;Workspace&#x2F;csc_simulate&#x2F;\t&lt;Directory &#x2F;home&#x2F;qqs&#x2F;Workspace&#x2F;csc_simulate&gt;\t\tRequire all granted\t&lt;&#x2F;Directory&gt;\tAlias &#x2F;viewer &#x2F;home&#x2F;qqs&#x2F;Workspace&#x2F;cs_meshviewer&#x2F;build\t&lt;Directory &#x2F;home&#x2F;qqs&#x2F;Workspace&#x2F;cs_meshviewer&#x2F;build&gt;\t\tRequire all granted\t&lt;&#x2F;Directory&gt;\t&lt;Location &#x2F;viewer&gt;        \tDirectoryIndex index.html    &lt;&#x2F;Location&gt;\tErrorLog $&#123;APACHE_LOG_DIR&#125;&#x2F;error.log\tCustomLog $&#123;APACHE_LOG_DIR&#125;&#x2F;access.log combined\tProxyPreserveHost On\tProxyPass &#x2F;download http:&#x2F;&#x2F;10.196.98.58:3000&#x2F;download\tProxyPassReverse &#x2F;download http:&#x2F;&#x2F;10.196.98.58:3000&#x2F;download&lt;&#x2F;VirtualHost&gt;注意  并不是唯一的，应根据需要定义路径的访问控制，Difference between Directory and Location启用和禁用sitea2ensite yoursite.confa2dissite yoursite.conf\n启用和禁用模块&#x2F;&#x2F; 关于反向代理a2enmod proxya2enmod proxy_httpa2enmod proxy_balancera2enmod lbmethod_byrequests&#x2F;&#x2F; 关于虚拟路径a2enmod alias&#x2F;&#x2F; 禁用：a2dismod启用、停用和重启服务systemctl start|stop|reload apache2\nIssue 403 You don’t have permission to access this resource.令人发狂的CentOS（Selinux）镜像实践日期：2019-12-29 CentOS-8-x86_64-1905-dvd1.iso\n网卡设置ip addnmcli device shownmcli device statusnmcli connection down enp0s3nmcli connection up enp0s3nmcli c reload\n静态IP/etc/sysconfig/network-scripts/ifcfg-enp0s3TYPE&#x3D;EthernetPROXY_METHOD&#x3D;noneBROWSER_ONLY&#x3D;noBOOTPROTO&#x3D;none # 默认是dhcp，根据dhcp分配 改为none或staticNAME&#x3D;enp0s3DEFROUTE&#x3D;yesIPV4_FAILURE_FATAL&#x3D;noIPV6INIT&#x3D;yesIPV6_AUTOCONF&#x3D;yesIPV6_DEFROUTE&#x3D;yesIPV6_FAILURE_FATAL&#x3D;noIPV6_ADDR_GEN_MODE&#x3D;stable-privacyNAME&#x3D;enp0s3UUID&#x3D;0b813e18-6008-485c-ba8c-d19e259a847aDEVICE&#x3D;enp0s3ONBOOT&#x3D;yes # 开机启用该配置IPADDR&#x3D;10.196.98.99GATEWAY&#x3D;10.196.98.1NETMASK&#x3D;255.255.254.0DNS1&#x3D;10.192.0.100PREFIX&#x3D;24\n防火墙systemctl stop firewalld.service #关闭systemctl start firewalld.service #启动firewall-cmd --zone&#x3D;public --permanent --add-port 22&#x2F;tcp #开启端口systemctl restart firewalld.service #重启\n关闭selinuxsestatus &#x2F;&#x2F; 查看状态setenforce 0 &#x2F;&#x2F; 临时关闭\n禁用selinux编辑/etc/selinux/config, set SELINUX=disabled。\n","categories":["Linux"],"tags":["Linux","Apache"]},{"title":"Linux命令行工具","url":"/qqsnote/2019/07/28/LinuxTools/","content":"Please keep learning —&gt; Linux工具快速教程\n测试网络连接linux 上一般是不装ping的telnet 8.8.8.8 80curl 8.8.8.8:80ssh -v -p qqs@8.8.8.8wget 8.8.8.8:80\n拷贝目录将工作空间目录下的test文件夹拷到labhome下面cp -ri &#x2F;home&#x2F;Workspace&#x2F;test &#x2F;var&#x2F;labhome&#x2F;\n\n-r 递归\n-i 询问是否覆盖查找文件find [path] -name [filename]find &#x2F; -name filename\ntailtail -f filename\ntail命令读取文件内容到标准输出，-f 循环读取，上述命令查找文件中最尾部的内容显示在屏幕上,并且不断刷新,使你看到最新的文件内容filename 可以是多个文件 以空格分隔即可\n\ntartar 通常是GNU tar，而libarchive库集成了bsdtar，不知道为什么我的windows默认的tar.exe是后者执行下述脚本tar -c * | gzip &gt; Agt.tgz报异常：tar.exe: Failed to open ‘\\.\\tape0’该路径是缺省的设备起始位置（?），因为bsdtar要求不能缺省输出参数 应为tar -cf - * | gzip &gt; Agt.tgz\n后台运行后台运行命令anycommand $将前台命令放到挂起（stopped）Ctrl + Z查看后台工作项目jobs -l操作后台工作项目\n\n终止后台工作项目 kill jobNumber\n调至前台继续运行 fg jobNumber\n在后台执行挂起的工作项目 bg jobNumbervi查找在命令模式下敲斜杆( / )这时在状态栏（也就是屏幕左下脚）就出现了 “/” 然后输入你要查找的关键字敲回车就可以了。如果你要继续查找此关键字，敲字符 n 就可以继续查找了。敲字符N（大写N）就会向前查询； 重命名rename个人理解： 语法其一  rename 原字符串 新值 范围将run.sh重命名为run_bak.shrename run.sh run_bak.sh run.sh\n语法其二 rename ‘option/原字符串模式/新字符串模式/‘ 搜索范围统一删除.bak后缀名:rename &#39;s&#x2F;\\.bak$&#x2F;&#x2F;&#39; *.bak\n其中/ /之间是正则表达式，后缀名中的.需要转义批量修改文件名为全部小写rename &#39;y&#x2F;A-Z&#x2F;a-z&#x2F;&#39; *\n软件sudo npm cache clean -f #----- 先清除 npm cachesudo apt-get update #------ 更新源sudo apt-get upgrade #------ 更新已安装的包\n对于nodejs npm需要使用n模块升级到最新稳定版本sudo apt-get install nodejs npmnpm install -g n sudo n stable \nNov 25th 遭遇 issue 27711 需将nodejs从v12降至v10sudo n 10.16.0\nRPMwget https:&#x2F;&#x2F;example.com&#x2F;file.rpmsudo yum localinstall file.rpmsudo rpm –ivh file.rpmsudo rpm –ivh https:&#x2F;&#x2F;example.com&#x2F;file.rpm\n查看系统版本cat &#x2F;etc&#x2F;issue 查看发行版cat &#x2F;etc&#x2F;redhat-release 查看CentOS版本uname -r 查看内核版本\n查看硬件信息cat &#x2F;proc&#x2F;cpuinfo |morecat &#x2F;proc&#x2F;meminfo |more&#x2F;&#x2F; 磁盘cat &#x2F;proc&#x2F;partitions fdisk -l \n查看服务列表service --status-all\n异常：键入命令不显示（回显关闭）&#x2F;&#x2F; 回显关闭stty -echo&#x2F;&#x2F; 回显打开stty echo\n定时任务查看服务状态service cron status\ncrontab&#x2F;&#x2F; 列出该用户的计时器设置crontab -l&#x2F;&#x2F; 编辑该用户的计时器设置crontab -u username -e\n不指定username 则以root用户身份执行\n计划任务分为系统任务调度和用户任务调度两类系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等 见/etc/crontab时日周月计划。用户任务调度：用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在/var/spool/cron目录中。其文件名与用户名一致\n\n\n\n实际上，crontab文件被设计为不允许(存疑)用户直接编辑，而是通过crontab -e管理计划的格式如下SHELL&#x3D;&#x2F;bin&#x2F;bashPATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;binMAILTO&#x3D;root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# |  .------------- hour (0 - 23)# |  |  .---------- day of month (1 - 31)# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...# |  |  |  |  .---- day of week (0 - 6) (Sunday&#x3D;0 or 7) OR sun,mon,tue,wed,thu,fri,sat# |  |  |  |  |# *  *  *  *  * user-name  command to be executed\n\n* 表示匹配该域的任意值。假如在Minutes域使用*, 即表示每分钟都会触发事件。\n/ 表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次.\n- 表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次\n, 表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。\n\n? 只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20  ?, 其中最后一位只能用？，而不能使用，如果使用*表示不管星期几都会触发，实际上并不是这样。\n\nL 表示最后，只能出现在DayofWeek和DayofMonth域。如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。\n\nW 表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 。\n\nLW 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。\n\n# 用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。\n\n\n例子：20 6    pwd 每天的 6:20 执行pwd命令20 6 8 6  pwd 每年的6月8日6:20执行pwd命令20 6   0 pwd 每星期日的6:20执行pwd命令20 3 10,20   pwd 每月10号及20号的3：20执行pwd命令25 8-10    pwd 每天8-10点的第25分钟执行pwd命令\n/15     pwd 每15分钟执行一次pwd命令 20 6 /10  * pwd 每个月中，每隔10天6:20执行一次pwd命令\n开启系统cron日志sudo vim /etc/rsyslog.d/50-default.conf 取消注释cron.log即可在/var/log/syslog中看到关于CRON的log\n\nISSUE: No MTA installed, discarding output \n\ncron默认将console output用邮件发送，task有控制台输出但未配置邮件则记如上日志，可以将console output重定向到文件echo &quot;&quot; &gt; &#x2F;home&#x2F;QQs&#x2F;corn.log若task执行中间过程有报错，报错信息仍会以Email形式发送，非安装邮件服务器不能解决安装postfix\n注意，crontab task 若以root权限执行（syslog中可以看到），root若无重定向日志文件的写权限，仍然会报 “No MTA installed, discarding output”\n重载CRON服务sudo service cron reload启动/关闭sudo service cron start&#x2F;stop\nUbuntu timezone显示时间:date -R某年月日，测试scheduled tasks，总是无法在期望时间触发，经查系统时间为‘Universal Time’（即格林威治时间时间）输入tzselect 选择本地时间(shanghai)永久覆盖本地时间设置cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai  &#x2F;etc&#x2F;localtime设置时间date -s &#39;2020&#x2F;3&#x2F;1 18:20:30&#39;Linux 以一定时间间隔更新内核时间，做上述调整后立即重启，可以将设置写入内核，否则会被更新回来（QQs尚未验证重启操作）\n异常：刚启动正常，很短时间后，所有端口无法连接事实证明，Linux与Windows发生IP冲突，Linux无法竞争过Windows，（反之未验证），现象是刚刚启动时连接正常，很短时间后无法连接。再次遭遇此问题，Linux虚拟机IP被抢，virtualbox桥接，宿主计算机访问虚拟机无碍，其他计算机可以ping通，telnet不通（目标ip实际上是windows机器）\nusersu -l USERNAME\nchmodLinux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。例如 owner - RWX， group - RX, other - R_如上，u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。chmod [ugoa...][[+-&#x3D;][rwxX]栗子chmod ugo+r file1.txt &#x2F;&#x2F;将文件 file1.txt 设为所有人皆可读chmod a+r file1.txt &#x2F;&#x2F; 同上其他参数\n\n-R 对目录递归变更权限查看端口使用sudo lsof -i:8080\ncurl即client url tool curl 的用法指南\n\ndos2unixwindows&amp;linux交叉编译环境下脚本结尾标记可能出错\n\nBash syntax error: unexpected end of file\n\n使用dos2unix工具转换脚本文件dos2unix task.sh\n","categories":["Linux"],"tags":["Linux"]},{"title":"MQ中间件","url":"/qqsnote/2019/12/12/MQ/","content":"B站教程 RabbitMQ\n意义\n异步处理例如 注册—保存成功—发送邮件 的流程，MQ接管非必要操作，拓展并行处理能力\n应用解耦使用发布订阅模式，消息上下游之间解除依赖关系\n流量削峰秒杀业务，前端请求塞到MQ，将筛选过的action选择性地交给biz层(业务层)\n日志处理Message Queue\nRabbitMQ is one of the most popular open source message brokers. RabbitMQ is lightweight and easy to deploy on premises and in the cloud. It supports multiple messaging protocols.\n\n\n\nErlang，具备函數語言特色的程序设计语言\ninstallationRPM Manual：(Erlang依赖 + RabbitMQ)参考官网 Tutorials\n\nBefore installing RabbitMQ, you must install a supported version of Erlang/OTP. Zero-dependency Erlang RPM for RabbitMQ : this is a (virtually) zero dependency 64-bit Erlang RPM package that provides just enough to run RabbitMQ. It may be easier to install than other Erlang RPMs in most environments. It may or may not be suitable for running other Erlang-based software or 3rd party RabbitMQ plugins.\nother dependencies : socat, logrotate\ndownload and install rabbit-server.rpm(https://www.rabbitmq.com/install-rpm.html#downloads)\n\ncd &#x2F;usr&#x2F;local&#x2F;src&#x2F;mkdir rabbitmqcd rabbitmq\n在ubuntu#!&#x2F;bin&#x2F;shsudo apt-get install curl gnupg debian-keyring debian-archive-keyring apt-transport-https -y## Team RabbitMQ&#39;s main signing keysudo apt-key adv --keyserver &quot;hkps:&#x2F;&#x2F;keys.openpgp.org&quot; --recv-keys &quot;0x0A9AF2115F4687BD29803A206B73A36E6026DFCA&quot;## Cloudsmith: modern Erlang repositorycurl -1sLf https:&#x2F;&#x2F;dl.cloudsmith.io&#x2F;public&#x2F;rabbitmq&#x2F;rabbitmq-erlang&#x2F;gpg.E495BB49CC4BBE5B.key | sudo apt-key add -## Cloudsmith: RabbitMQ repositorycurl -1sLf https:&#x2F;&#x2F;dl.cloudsmith.io&#x2F;public&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;gpg.9F4587F226208342.key | sudo apt-key add -## Add apt repositories maintained by Team RabbitMQsudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;rabbitmq.list &lt;&lt;EOF## Provides modern Erlang&#x2F;OTP releases##deb https:&#x2F;&#x2F;dl.cloudsmith.io&#x2F;public&#x2F;rabbitmq&#x2F;rabbitmq-erlang&#x2F;deb&#x2F;ubuntu bionic maindeb-src https:&#x2F;&#x2F;dl.cloudsmith.io&#x2F;public&#x2F;rabbitmq&#x2F;rabbitmq-erlang&#x2F;deb&#x2F;ubuntu bionic main## Provides RabbitMQ##deb https:&#x2F;&#x2F;dl.cloudsmith.io&#x2F;public&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;deb&#x2F;ubuntu bionic maindeb-src https:&#x2F;&#x2F;dl.cloudsmith.io&#x2F;public&#x2F;rabbitmq&#x2F;rabbitmq-server&#x2F;deb&#x2F;ubuntu bionic mainEOF## Update package indicessudo apt-get update -y## Install Erlang packagessudo apt-get install -y erlang-base \\                        erlang-asn1 erlang-crypto erlang-eldap erlang-ftp erlang-inets \\                        erlang-mnesia erlang-os-mon erlang-parsetools erlang-public-key \\                        erlang-runtime-tools erlang-snmp erlang-ssl \\                        erlang-syntax-tools erlang-tftp erlang-tools erlang-xmerl## Install rabbitmq-server and its dependenciessudo apt-get install rabbitmq-server -y --fix-missing\n\n启动/关闭 /sbin/service rabbitmq-server start/stop\n开机启动 chkconfig rabbitmq-server on\n\nDocker Imagedocker pull rabbitmqdocker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management启用Management Plugin (网页管理界面)sudo rabbitmq-plugins enable rabbitmq_managementsudo service rabbitmq-server restart# 创建网页管理用户sudo rabbitmqctl add_user QQs 123456sudo rabbitmqctl set_user_tags QQs administrator访问 http://{node-hostname}:15672/ 对RabbitMQ-Server进行可视化管理 \n授权，认证 以及 Access Control参考官网 Tutorials\n默认用户guest/guest只被允许本地登录&#x2F;&#x2F; 创建用户qqs&#x2F;pass1234sudo rabbitmqctl add_user qqs pass1234&#x2F;&#x2F; 用户列表sudo rabbitmqctl list_users&#x2F;&#x2F; 授权管理员sudo rabbitmqctl set_user_tags qqs administratorvhost 是 RabbitMQ 控制权限的最小粒度注意，/是默认的vhost，缺省了名称。rabbitmqctl list_vhostsrabbitmqctl add_vhost test_vhost&#x2F;&#x2F; set_permissions [-p &lt;vhost&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;rabbitmqctl set_permissions -p &#x2F;          qqs &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;rabbitmqctl set_permissions -p test_host  qqs &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;\nclient demos见 Github rabbitmq tutorials\njavascript client demo：packagenpm i amqplibsend.jsnodevar amqp &#x3D; require(&#39;amqplib&#x2F;callback_api&#39;);amqp.connect(&#39;amqp:&#x2F;&#x2F;qqs:pass1234@111.111.111.111:5672&#x2F;&#39;, function(error0, connection) &#123;    if (error0) &#123;        throw error0;    &#125;    connection.createChannel(function(error1, channel) &#123;        if (error1) &#123;            throw error1;        &#125;        var queue &#x3D; &#39;hello&#39;;        var msg &#x3D; &#39;Hello World!&#39;;        &#x2F;&#x2F; 订阅        channel.assertQueue(queue, &#123;            durable: false        &#125;);        &#x2F;&#x2F; 发布        channel.sendToQueue(queue, Buffer.from(msg));        console.log(&quot; [x] Sent %s&quot;, msg);    &#125;);    setTimeout(function() &#123;        connection.close();        process.exit(0);    &#125;, 500);&#125;);receive.js#!&#x2F;usr&#x2F;bin&#x2F;env nodevar amqp &#x3D; require(&#39;amqplib&#x2F;callback_api&#39;);amqp.connect(&#39;amqp:&#x2F;&#x2F;qqs:pass1234@111.111.111.111:5672&#x2F;&#39;, function(error0, connection) &#123;    if (error0) &#123;        throw error0;    &#125;    connection.createChannel(function(error1, channel) &#123;        if (error1) &#123;            throw error1;        &#125;        var queue &#x3D; &#39;hello&#39;;        channel.assertQueue(queue, &#123;            durable: false        &#125;);        console.log(&quot; [*] Waiting for messages in %s. To exit press CTRL+C&quot;, queue);        channel.consume(queue, function(msg) &#123;            console.log(&quot; [x] Received %s&quot;, msg.content.toString());        &#125;, &#123;            noAck: true        &#125;);    &#125;);&#125;);\n定时任务原理是：消息设置过期时间放入队列1，过期移入队列2，订阅者监听队列2\nAMQP高级消息队列协议(Advanced Message Queue Protocol) AMQP实体：队列、交换机、绑定\n\n默认交换机 根据消息携带的route key直接路由到同名的队列\n\n","categories":["中间件"],"tags":["MQ"]},{"title":"机器视觉","url":"/qqsnote/2025/03/05/MachineVision/","content":"机器视觉是人工智能除LLM外的另一个分支\n一、传统机器学习模型支持向量机(SVM)\n应用案例：近红外光谱识别（6个特征波长输入，95.3%准确率）\n优势：小样本表现优异，适合光谱数据\n缺陷：依赖特征工程，需人工提取菌盖颜色、形状等特征\n随机森林(RF)\n应用案例：15特征（形态+颜色+纹理）分类，全特征建模最优\n效果：预测精度超SVM，适合结构化特征数据\n二、深度学习模型基础CNN架构\n典型表现：传统CNN在3,100张测试集上首图命中率48.7%\n改进方案：降梯度卷积（扩大感受野），命中率提升至81.7%\n经典网络改进\nResNet50：迁移学习+图像增强后，测试集平均识别时间0.985秒\nEfficientNet：在49,958张自建数据集上，宏F值提升0.75%\nMobileNetV2：配合权重衰减策略(YWeight)，top-1准确率提升0.87%\n细粒度识别专用\n双线性CNN：结合Inception-ResNet-v2，在菌盖纹理相似度&gt;85%的数据集上，细粒度分类准确率超95%\nXception模型：迁移学习+多场景数据增强，野外复杂背景识别率达96.67%\n轻量化模型\nMicro V2：苹果M1 CPU训练142秒达88%准确率，模型体积仅3.5MB\nShuffleNetV2：在8,375张增强数据上，识别速度较VGG16提升3倍\n"},{"title":"Markdown UML","url":"/qqsnote/2023/04/10/MarkdownUML/","content":"plantumlpreview in vscode：\n\n安装PlantUML插件 PlantUML Previewer插件\n配置 PlantUML Server按Alt + D打开PlantUML Previewgenerate through Hexo流程图\n\nstartif(account cache exist?) then (no)     :return null;     stopelse (yes)      :start silent request;    :get result or exceptions;    :return result;stop\n\nstart:declare timer; CancellationTokenSource;:declare TaskComplationSource;if(account cache exist?) then (no)     :return null;     stopelse (yes)      :declare silentRequestTask,     input cancellation token;    :parallel execuate silentRequestTask    and TaskComplationSource.Task;    fork    :execuate silentRequestTask;    fork again    :TaskComplationSource.Task;    end fork    :when any task returns;    if(silentRequestTask complete?) then(yes)        :get result or exceptions;        :return result;        :release timer;        :close error dialog if opened;        stop    else (no)        :throw OperationCancelException;        :set isAuthenticationCancel flag to true;        :return null;        stop\n\n时序图Main -&gt; PubClientApplicationMain -&gt; TimerLoop loop description    FileDialog -&gt; FileManager: exportFile selectPath    FileManager -&gt; FileManager: CopyFileTo(exportFile, selectPath)end\n\n思维导图@startmindmap*[#409EFF] vue3-auth    **[#79bbff] 登陆认证        ***_ 登陆和登出        ***_ 用户注册        ***_ 用户状态和信息保存    **[#79bbff] 权限鉴定        ***_ 用户权限获取        ***_ 页面访问权限（菜单权限）        ***_ 页面功能权限（按钮权限）    **[#79bbff] 角色管理        ***_ 角色新增        ***_ 角色修改        ***_ 角色删除        ***_ 角色绑定权限        ***_ 角色绑定维度    **[#79bbff] 用户管理        ***_ 用户新增        ***_ 用户修改        ***_ 用户删除@endmindmap\n","categories":["工具"],"tags":["Markdown","UML"]},{"title":"Markdown 语法","url":"/qqsnote/2018/07/31/Markdown_Grammar/","content":"标题11.11.1.11.1.11.1.1 avar a&#x3D;&quot;1&quot;;a+&#x3D;2;print a;\n\n这一段，\n引言叫区块引用\n\n斜体加粗删除线下划线\n\n第一教条\n第二条\n\n\n首先\n然后\n最后\n\n\nLorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.\nDonec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing.\n\n这个是百度链接 可以使用相对路径\nQQstone笔记\n根据某某某考证，见[该刊]1。\n站内超链接：关于websockt 详见 WebSocket篇&#123;% post_link 文章文件名 显示文字 %&#125;反引号``取消自动超链接： https://www.baidu.com 但是有个高亮背景，或者用\\\n\n\n\n\n\n左对齐\n居中\n右对齐\n\n\n\n\n内容\n内容\n内容\n\n\n内容\n内容\n内容\n\n\n\n\nconsole.log(&#39;code here&#39;)\nconsole.log(&#39;code here&#39;)\n矩阵\n\n\\left[\n \\begin{matrix}\n   x_{ii}^2 \\\\\n   y_{ij}^2\n  \\end{matrix}\n  \\right]=\n \\left[\n \\begin{matrix}\n   cosθ & -sinθ \\\\\n   sinθ & cosθ \n  \\end{matrix}\n  \\right]·\n  \\left[\n \\begin{matrix}\n   x \\\\\n   y \n  \\end{matrix}\n  \\right]更多数学表示—&gt; CSDN: nuoyanli公式的语法是mathjax的规范 hexo-js-next渲染公式需用hexo-renderer-kramed(默认是hexo-renderer-marked)配置theme\\next_config.yml   mathjax: enable: true同时在文章title下使能 mathjax: true详见hexo-theme-next doc:数学公式\nPlantUML绘图\n安装VS Code插件： Markdown Preview Enhanced, PlantUML\n&#x3D;&#x3D; Initialization &#x3D;&#x3D;Alice -&gt; Bob: : Can you solve: &lt;math&gt;ax^2+bx+c&#x3D;0&lt;&#x2F;math&gt;Bob --&gt; Alice: &lt;math&gt;x &#x3D; (-b+-sqrt(b^2-4ac))&#x2F;(2a)&lt;&#x2F;math&gt;activate Alice #FFBBBBnote left: this is a first noteAlice -&gt; Bob: Another dialoguedeactivate AliceAlice &lt;-- Bob: Another dialogue","categories":["工具"],"tags":["Markdown"]},{"title":"MaterialDesign","url":"/qqsnote/2021/03/23/MaterialDesign/","content":"Material UI SystemSystem是Material UI 自定义主题、样式的一套方法依赖npm install @material-ui&#x2F;system@next @emotion&#x2F;react @emotion&#x2F;styled\n\n直接就可以在你需要的组件上面进行样式定制\n避免定义一些列的样式（className）或带样式组件（styled-component）\n制定统一的标准 如字体 字号 色系\n\n关于使用sx系统样式与定义styled-component的书写差异styled-componentconst StatHeader &#x3D; styled(&#39;div&#39;)(z  (&#123; theme &#125;) &#x3D;&gt; &#96;  color: blue;&#96;,);...return (  &lt;StatHeader&gt;font color is blue here&lt;&#x2F;StatHeader&gt;)‘轻’组件(Box, Stack, Typography, and Grid) 和 sx属性return (   &lt;Box sx&#x3D;&#123;&#123; color: &#39;text.secondary&#39; &#125;&#125;&gt;this color is blue here&lt;&#x2F;Box&gt;)\nMaterial DesignMaterial Design\nColor Palette tool一套以上述工具生成的颜色模板(基于#36b0c9)👇$qqs-design:(    50: #e7f6f9,    100: #c3e7ef,    200: #9bd8e4,    300: #72c8d9,    400: #54bcd1,    500: #36b0c9,    600: #30a9c3,    700: #29a0bc,    800: #2297b5,    900: #1687a9,    A100: #dcf6ff,    A200: #a9e9ff,    A400: #76ddff,    A700: #5dd6ff,    contrast: (      50: #262626,      100: #262626,      200: #262626,      300: white,      400: white,      500: white,      600: white,      A100: #262626,      A200: white,      A400: white,      A700: white    ));material套用自定义颜色模板&#x2F;&#x2F; Custom Theming for Angular Material&#x2F;&#x2F; For more information: https:&#x2F;&#x2F;material.angular.io&#x2F;guide&#x2F;theming@import &#39;~@angular&#x2F;material&#x2F;theming&#39;;&#x2F;&#x2F; Plus imports for other components in your app.@import &#39;theme.scss&#39;;&#x2F;&#x2F; Include the common styles for Angular Material. We include this here so that you only&#x2F;&#x2F; have to load a single css file for Angular Material in your app.&#x2F;&#x2F; Be sure that you only ever include this mixin once!@include mat-core();&#x2F;&#x2F; Define the palettes for your theme using the Material Design palettes available in palette.scss&#x2F;&#x2F; (imported above). For each palette, you can optionally specify a default, lighter, and darker&#x2F;&#x2F; hue. Available color palettes: https:&#x2F;&#x2F;material.io&#x2F;design&#x2F;color&#x2F;$CSDPartnerPortal-primary: mat-palette($csd2021);$CSDPartnerPortal-accent: mat-palette($csd2021, 500, A100, A400);&#x2F;&#x2F; The warn palette is optional (defaults to red).$CSDPartnerPortal-warn: mat-palette($mat-red);&#x2F;&#x2F; Create the theme object. A theme consists of configurations for individual&#x2F;&#x2F; theming systems such as &quot;color&quot; or &quot;typography&quot;.$CSDPartnerPortal-theme: mat-light-theme((  color: (    primary: $CSDPartnerPortal-primary,    accent: $CSDPartnerPortal-accent,    warn: $CSDPartnerPortal-warn,  )));&#x2F;&#x2F; Include theme styles for core and each component used in your app.&#x2F;&#x2F; Alternatively, you can import and @include the theme mixins for each component&#x2F;&#x2F; that you are using.@include angular-material-theme($CSDPartnerPortal-theme);\n "},{"title":"医学图像格式","url":"/qqsnote/2019/08/08/MedicalImageFormat/","content":"图像格式Images(or voxel)dcm (DICOM Image): DICOM的全称是 Digital Imaging and Communications in Medicine (医疗数位影像和传输协定)它是一组通用的标准协定，可以整合不同厂商的医疗影像仪器、伺服器、工作站、列印机和网络设备和其他格式不同的是它統合了所有的資訊在同一個資料內，也就是說，如果有一張胸腔X光影像在你的病人個人資料內，這個影像決不可能意外地再從你的病人資料中分離。\nMeshesstl (STereoLithography, 立體光刻),用于表示三角形网格的一种文件格式。它的文件格式非常简单，只能描述三维物体的几何信息，不支持颜色材质等信息。以二进制.stl文件为例，文件起始的80个字节是文件头，用于存贮文件名；紧接着用 4 个字节的整数来描述模型的三角面片个数，后面逐个给出每个三角面片的几何信息。每个三角面片占用固定的50个字节UINT8&#x2F;&#x2F;Header&#x2F;&#x2F;文件头UINT32&#x2F;&#x2F;Numberoftriangles&#x2F;&#x2F;三角面片数量&#x2F;&#x2F;foreachtriangle（每个三角面片中）REAL32[3]&#x2F;&#x2F;Normalvector&#x2F;&#x2F;法线矢量REAL32[3]&#x2F;&#x2F;Vertex1&#x2F;&#x2F;顶点1坐标REAL32[3]&#x2F;&#x2F;Vertex2&#x2F;&#x2F;顶点2坐标REAL32[3]&#x2F;&#x2F;Vertex3&#x2F;&#x2F;顶点3坐标UINT16&#x2F;&#x2F;Attributebytecountend&#x2F;&#x2F;文件属性统计ply (Polygon File Format, 多边形档案),该格式主要用以储存立体扫描结果的三维数值，透过多边形片面的集合描述三维物体,是相较stl更丰富的方式plyformat ascii 1.0             ...&#123; 文件类型：ascii或binary，版本号 &#125;comment made by anonymous    ... &#123; 注释行 &#125;comment this file is a cube  ...&#123; 注释行 &#125;comment texture file             &#123;纹理贴图文件&#125;element vertex 8             ...&#123; 定义“顶点”元素，其数量为8个 &#125;property float32 x           ...&#123; 顶点的x属性，数据类型为float32 &#125;property float32 y           ...&#123; 顶点的y属性，数据类型为float32 &#125;property float32 z           ...&#123; 顶点的z属性，数据类型为float32 &#125;property float32 textureu       &#123;纹理坐标&#125;property float32 texturevelement face 6               ...&#123; 定义“面”元素，其数量为6个 &#125;property list uint8 int32 vertex_index ...&#123; 面的顶点索引属性，类型为uint8的列表 &#125;end_header                   ...&#123; 文件头结束标志 &#125;0 0 0                        ...&#123; 顶点元素列表 &#125;0 0 10 1 10 1 01 0 01 0 11 1 11 1 04 0 1 2 3                    ...&#123; 面元素列表 顶点数 顶点编号 &#125;4 7 6 5 44 0 4 5 14 1 5 6 24 2 6 7 34 3 7 4 0\nMarching Cubes Algorithm维基百科\nSurface Extraction: Creating a mesh from pixel-data using Python and VTK\n图像处理工具库pydicomimport pydicomds &#x3D; pydicom.dcmread(file)\nvtk三维计算机图形学、图像处理和可视化软件，内核C++构建，具备多种转换界面，支持Java、Python等方式调用render: camera actor lightdata set:\nitkITK 是一个开放源码、面向对象的软件系统，提供一个医学图像处理、图像分割与配准的算法平台\nxsltPACS医学影像存档与通信系统（英语：Picture archiving and communication system，PACS）\n","categories":["图形学"],"tags":["医学图像"]},{"title":"微前端 - Micro App","url":"/qqsnote/2025/08/08/MicroFrontEnd-MicroApp/","content":"Web ComponentWeb API Doc: Web Component\nw3c提出浏览器原生支持的组件规范 通过扩展HTMLElement定义html标签 嵌入内容和逻辑（shadow dom隔离）\n\n接入简单不需要子应用改造\n不支持ie\nWeb Component沙箱隔离 性能较好\n\n集成npm i @micro-zoe&#x2F;micro-app -S\n主应用入口&#x2F;&#x2F; src&#x2F;index.jsimport microApp from &#39;@micro-zoe&#x2F;micro-app&#39;microApp.start()contianer组件&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;子应用&lt;&#x2F;h1&gt;    &lt;!--      name(必传)：应用名称      url(必传)：应用地址，会被自动补全为http:&#x2F;&#x2F;localhost:3000&#x2F;index.html      baseroute(可选)：基座应用分配给子应用的基础路由，就是上面的 &#96;&#x2F;my-page&#96;     --&gt;    &lt;micro-app name&#x3D;&#39;learnvue&#39; url&#x3D;&#39;http:&#x2F;&#x2F;localhost:8081&#x2F;&#39; baseroute&#x3D;&quot;&#x2F;dentition&quot;&gt;&lt;&#x2F;micro-app&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;\n","categories":["前端技术"],"tags":["Web开发"]},{"title":"微服务","url":"/qqsnote/2020/11/10/Microservices/","content":"知乎：什么是微服务\n参考 微服务的演进单体服务垂直分层架构\n\n微服务是一种小型的SOA架构（Service Oriented Architecture 面向服务的架构），其理念是将业务系统彻底地组件化和服务化，形成多个可以独立开发、部署和维护的服务或者应用的集合，以应对更快的需求变更和更短的开发迭代周期。\n\n\n拓展：传统SOA使用ESB(Enterprise Service Bus 企业服务总线)进行各业务系统间的通信\n目的或优点：\n\n服务模块解耦\n团队分工更容易，更明确, 技术栈异构\n独立部署，可针对独立模块进行发布 更快的迭代\n扩展能力强 不至于牵一发动全身相应的缺点是服务划分的困扰，系统复杂化，实施部署、纠错的难度增大等\n\n“无非是业务拆分和基架体系搭建”\nSOAService Oriented Ambiguity 即面向服务架构\nSOAP(web service) http+xmlREST http+jsonRPC socket\n"},{"title":"微前端-qiankun","url":"/qqsnote/2025/08/08/MicroFrontEnd/","content":"微前端场景\n老系统架构陈旧 重构难度大 部分需要与时俱进的功能得不到升级\n不同模块需要多个团队参与 尤其专业和技术栈有差异\nA系统若干功能或页面被B系统引用\n\n\nTechniques, strategies and recipes for building a modern web app with multiple teams that can ship features independently. — Micro Frontends\n\n微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。\nqiankun方案缺点\n\n改造和适配成本高 如微应用打包、入口生命周期，以及router问题\njs沙箱性能问题\n不支持激活多个微应用 不支持微应用保活\n\n工作流父应用：安装微前端组件 —&gt; 预留容器dom —&gt; 用组件提供的方法注册子系统子应用：暴露生命周期钩子\nnpm i qiankun -S\nregister和start都在container的组件层级上 不一定是在顶级组件上 尤其在使用router和模块懒加载的应用中&lt;template&gt;  &lt;div id&#x3D;&quot;viewport&quot;&gt;    &lt;div id&#x3D;&quot;subapp-root&quot;&gt;&lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123; registerMicroApps, start &#125; from &#39;qiankun&#39;export default &#123;  name: &#39;&#39;,  data () &#123;    return &#123;&#125;  &#125;,  mounted () &#123;    &#x2F;&#x2F; 注册微应用    registerMicroApps([      &#123;        name: &#39;learnvue&#39;, &#x2F;&#x2F; app name registered        entry: &#39;&#x2F;&#x2F;localhost:8081&#39;,        container: &#39;#viewport&#39;,        activeRule: &#39;&#x2F;dentition&#39;      &#125;    ])    if (!window.qiankunStarted) &#123;      window.qiankunStarted &#x3D; true      start()    &#125;  &#125;&#125;&lt;&#x2F;script&gt;当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。\n如果微应用不是直接跟路由关联的时候，你也可以选择手动加载微应用的方式：import &#123; loadMicroApp &#125; from &#39;qiankun&#39;;loadMicroApp(&#123;  name: &#39;app&#39;,  entry: &#39;&#x2F;&#x2F;localhost:7100&#39;,  container: &#39;#yourContainer&#39;,&#125;);\n微应用webpack设置const &#123; defineConfig &#125; &#x3D; require(&#39;@vue&#x2F;cli-service&#39;)const packageName &#x3D; require(&#39;.&#x2F;package.json&#39;).name;module.exports &#x3D; defineConfig(&#123;  transpileDependencies: true,    devServer: &#123;    port: 8081,    headers: &#123;      &#x2F;&#x2F; 微前端需要跨域      &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;    &#125;  &#125;,  configureWebpack: &#123;    output: &#123;      library: &#96;$&#123;packageName&#125;-[name]&#96;, &#x2F;&#x2F; [name]是打包时trunk名称的占位符      libraryTarget: &#39;umd&#39;, &#x2F;&#x2F; Universal Module Definition通用模块定义      chunkLoadingGlobal: &#96;webpackJsonp_$&#123;packageName&#125;&#96;,    &#125;  &#125;&#125;)暴露声明周期&#x2F;&#x2F;main.jsimport Vue from &#39;vue&#39;import App from &#39;.&#x2F;App.vue&#39;import &#39;.&#x2F;public-path&#39;import router from &#39;.&#x2F;router&#39;Vue.config.productionTip &#x3D; falselet instance &#x3D; null;function render(props &#x3D; &#123;&#125;) &#123;  const &#123; container &#125; &#x3D; props;  instance &#x3D; new Vue(&#123;    router,    render: h &#x3D;&gt; h(App)  &#125;).$mount(container ? container.querySelector(&#39;#app&#39;) : &#39;#app&#39;)&#125;&#x2F;&#x2F; Running in qiankun&#x2F;* eslint-disable no-undef *&#x2F;if (window.__POWERED_BY_QIANKUN__) &#123;  __webpack_public_path__ &#x3D; window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;&#125;&#x2F;&#x2F; Running standaloneif (!window.__POWERED_BY_QIANKUN__) &#123;  render();&#125;export async function bootstrap() &#123;  console.log(&#39;[vue] vue app bootstraped&#39;);&#125;export async function mount(props) &#123;  console.log(&#39;[vue] props from main framework&#39;, props);  render(props);&#125;export async function unmount() &#123;  instance.$destroy();  instance.$el.innerHTML &#x3D; &#39;&#39;;  instance &#x3D; null;&#125;export async function update(props) &#123;  console.log(&#39;update props&#39;, props)&#125;\n应用间通信部署troubleshootingUncaught TypeError: Cannot redefine property: $router官网解决方法是将主应用window.Vue对象换个名字\n我的选择是 微应用最好不要用router\n","categories":["前端技术"],"tags":["Web开发"]},{"title":"移动端开发","url":"/qqsnote/2024/09/12/MobileDevelopment/","content":"\nRN和Ionic是相似的，基于js/ts的UI桥接原生组件 而Flutter（Dart语言）使用自己的渲染引擎\n\n发布到ios需要ios系统\n\n\n20250106 Apple Store Top Paid App:\n\n75 Hard 自律\nhotschedules 员工排班考勤，可能是国外版钉钉\nProcreate Pocket 绘图动画 图像处理\nPaprika Recipe Manager 3 菜谱\n\n"},{"title":"MongoDB","url":"/qqsnote/2019/07/31/MongoDB/","content":"“NoSQL” database非关系型数据库，不适用SQL作为查询语言，不使用数据表格存放数据。\n优势：\n\nScalability 可扩展性: by default, non-relational databases are split (or “shared”) across many systems instead of only one. This makes it easier to improve performance at a lower cost.\nFlexibility 灵活性: new datasets and properties can be added to a document without the need to make a new table for that data.\nReplication 备用性: copies of the database run in parallel so if one goes down, one of the copies becomes the new primary data source.\n\nMongoDB Atlasa cloud MongoDB servicemongodb+srv:&#x2F;&#x2F;qqs:&lt;password&gt;@clusteraws-vcbnj.mongodb.net&#x2F;test?retryWrites&#x3D;true&amp;w&#x3D;majority\nProject with MongoDBpackage:\n\nmongodb\nmongoose  var mongoose &#x3D; require(&#39;mongoose&#39;);mongoose.connect(process.env.MONGO_URI);\nMongoose Docs\nSchema：  一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力\nModel：  由Schema发布生成的模型，具有抽象属性和行为的数据库操作对\nEntity ：  由Model创建的实体，他的操作也会影响数据库\n\nmongoose.connect(process.env.MONGO_URI);           &#x2F;&#x2F;数据库连接var Schema &#x3D; mongoose.Schema;var personSchema &#x3D; new Schema(&#123;                    &#x2F;&#x2F;定义Schema  name: String,  age: Number,  favoriteFoods: Array&#125;)var Person &#x3D; mongoose.model(&#39;Person&#39;,personSchema); &#x2F;&#x2F;发布Modelvar document &#x3D; new Person(&#123;                         &#x2F;&#x2F;创建Entity  name:&#39;David&#39;,  age:18,  favoriteFoods:&#39;ice cream&#39;，&#125;)document.save(function(error,data)&#123;                           &#x2F;&#x2F;调用实例save方法  console.log(&#39;Person document saved&#39;)              &#x2F;&#x2F;以回调函数作为最后一个参数&#125;)\n如果是Entity，使用save方法，如果是Model，使用create方法，参数是json + 回调函数Person.create(&#123;    name:&#39;Ellar&#39;,    age:18,    favoriteFoods:&#39;banana&#39;&#125;,callback)Person.create(arrayOfPeople,callback);              &#x2F;&#x2F;批量创建Model.find()&#x2F;&#x2F; example find all documents whose name is DavidPerson.find(&#123;name:&#39;David&#39;&#125;,function(error,data)&#123;  if(!error)&#123;    console.log(data)  &#125;else&#123;    console.log(error)  &#125;&#125;)&#x2F;&#x2F; find方法在非完全匹配情况下的应用，会复杂很多，需要借助不同的方法及其选项，这些方法以$开头&#x2F;&#x2F; example find whose name contains &#39;White&#39;Person.find(  &#123;    name:    &#123;      &#39;$regex&#39;:&#39;White&#39;,      &#39;$options&#39;:&#39;i&#39;    &#125;  &#125;,findcallback)&#x2F;&#x2F; example find whose favoriteFood Array contains &#39;ice creame&#39;Person.find(  &#123;    favoriteFood:&#123;      $in:[&#39;ice cream&#39;]    &#125;,  &#125;,findcallback)// updatevar findAndUpdate &#x3D; function(personName, done) &#123;  var ageToSet &#x3D; 20;  Person.findOneAndUpdate(    &#123;name:personName&#125;,              &#x2F;* find filter*&#x2F;    &#123;$set:&#123;age:ageToSet&#125;&#125;,          &#x2F;* set options*&#x2F;    &#123;new:true&#125;,                     &#x2F;* return option*&#x2F;    (error,data)&#x3D;&gt;&#123;      if(error)        done(error);      done(null,data)    &#125;  )  &#x2F;&#x2F;done(null&#x2F;*, data*&#x2F;);&#125;;// findByIdAndRemovePerson.findByIdAndRemove(&#39;5d4a500e994a2154010dc67f&#39;,function()&#123;&#125;)\n实现自增长字段var WebSiteSchema &#x3D; mongoose.Schema(&#123;  &quot;original_url&quot;:String,  &quot;short_url&quot;:Number&#125;)&#x2F;&#x2F; modelvar Website &#x3D; mongoose.model(&#39;Website&#39;, CounterSchema)&#x2F;&#x2F; countervar CounterSchema &#x3D; Schema(&#123;    _id: &#123;type: String, required: true&#125;,    seq: &#123; type: Number, default: 0 &#125;&#125;);var counter &#x3D; mongoose.model(&#39;counter&#39;, CounterSchema);WebSiteSchema.pre(&#39;save&#39;, function()&#123;  var self &#x3D; this;  counter.findByIdAndUpdate(    &#123;_id: &#39;entityId&#39;&#125;,    &#123;$inc:&#123;req:1&#125;&#125;,    function(err,data)&#123;      if(err)&#123;        return next(err)      &#125;      self.short_url &#x3D; data.seq;      next();    &#125;  )&#125;)\npre是前置中间件操作，相当于其他语境的拦截器，在保存WebSite实例前调用计数器counter的findByIdAndUpdate。pre作用在Schema级别上，因此要在使用Schema生成model前定义才会生效。\n区间条件&#x2F;** collection&#123;*    userId:String,*    from:Date,*    to:Date,*    limit:Number*&#125;*&#x2F;var getLog &#x3D; function(collection,callback)&#123;  let queryCondition &#x3D; &#123;userId:collection.userId&#125;  if(collection.from)&#123;    queryCondition.date &#x3D; (queryCondition.date || &#123;&#125;);    queryCondition.date[&#39;$gte&#39;] &#x3D; collection.from;  &#125;  if(collection.to)&#123;    queryCondition.date &#x3D; (queryCondition.date || &#123;&#125;);    queryCondition.date[&#39;$lt&#39;] &#x3D; collection.to;  &#125;  console.log(&#39;query conditions:&#39;,queryCondition)  let query &#x3D; Exercise.find(queryCondition)  if(collection.limit)&#123;    query &#x3D; query.sort(&#123;&#39;date&#39;: -1&#125;).limit(collection.limit)  &#125;  query.exec(callback)&#125;\n关联查询 population （存目）","categories":["数据库"],"tags":["MongoDB"]},{"title":"Microsoft Teams 小程序","url":"/qqsnote/2021/11/16/MsTeamsDev/","content":"Microsoft Teams开发人员文档\nTeams App 实质是托管在Azure等服务端上的web app，Teams客户端类似于浏览器，打包部署直接用插件完成 此外微软提供sdk使之支持sso及授权访问功能\n\nMicrosoft 365 Developer Program部署及发布Teams App需要Talent的管理员权限 加入Microsoft 365 Developer Program 创建开发者账号使用免费沙盒—&gt; Microsoft 365计划\n\n安装vs code extraction：Teams Toolkit （preview）创建项目\ncreate a new Teams app\nselect capability: Tab\nselect hosting type: Azure\nselect language: JavaScript\ninput app name以上设置保存在.fx/settings.json├───.fx│       settings.json│   package.json│   permissions.json├───appPackage│       color.png│       manifest.source.json│       outline.png│└───tabs  │   .env  │   .gitignore  │   package.json  │   README.md  │  ├───public  │       auth-end.html  │       auth-start.html  │       deploy.png  │       favicon.ico  │       hello.png  │       index.html  │       publish.png  │  └───src  │   index.css\n  │   index.jsx\n  │\n  └───components\n      │   App.css\n      │   App.jsx\n      │   Privacy.jsx\n      │   Tab.jsx\n      │   TabConfig.jsx\n      │   TermsOfUse.jsx\nTab其实就是个React App运行和调试press F5调试host为 https://localhost:3000偶见 localhost refused to connect. 查看Teams Toolkit的Accounts中side loading是否处于disabled状态\nYour Microsoft 365 tenant admin hasn’t enabled sideloading permission for your account. You can’t install your app to Teams! \n\n\n\n出于种种原因造成的side loading disabled 应进入Microsoft365 Admin Center设置Show all —&gt; Admin centers —&gt; Teams Apps —&gt; Setup policies —&gt; Global打开 Upload custom apps\n部署到Azure先执行Teams Toolkit提供的DEPLOYMENT—&gt;Provision in the Cloud功能，toolkit将以项目名称自行创建App Service、Storage Account及Vitual Network等Rescource\n事实上，Teams Tab App的前端静态文件使用Azure Storage Account托管，访问控制通过托管标识(Managed Identity), 关于Provision时创建哪种资源见Provision cloud resources\n使用Deploy to the Cloud 将当前项目作为Web App部署到前面Provision预备的资源上\n记得配置Api的Endpoint 比如写/public/config.json\nZip Teams metadata package可获得该Web App的配置信息 包括名称及地址 以用于添加到Organization的Teams中\n上传到teams编译产生 build\\appPackage.local.zip 即项目的应用包，该目录下还有应用部件清单 manifest.json\n将应用包上传到teams中测试：Teams 左边栏点击Apps —&gt; Manage your apps —&gt; Upload an app to your org’s app catalog上传后图标显示在Apps列表中 可将其添加到team的chat中\n发布到组织Todo List Sample (SPFx)npm i -g teamsfx-cli &#x2F;&#x2F; 安装脚手架teamsfx new template list &#x2F;&#x2F; 查看可用的sample\n使用如下命令创建sample APP并基于这些sample作为模板开发自己的应用teamsfx new template todo-list-SPFx在teams中打开sharepoint站点配置一个list 见Microsoft Doc:代码中/SPFx/src/webparts/todoList/components/SharePointListManager.ts line17 设置为sharepoint上list的名字用vscode的Teams Toolkit打开项目选择项目目录打开在teams toolkit中选择Provision in the cloud 在Cloud端创建app**点击Deploy to the cloud部署点击Publish to the cloud发布访问Microsoft Teams admin center查找已发布的app登录Teams添加appTODO 主动从外部系统向 Teams 发送信息，允许用户从 Teams 客户端内部处理该信息。TODO 允许用户在另一个系统中快速查找信息，并将结果添加到 Teams 中的对话。\n身份认证\nMicrosoft 或 Microsoft 365 帐户登录 Teams 后，应用用户可以使用你的应用，而无需再次登录。如上图示，App添加到Teams，切换到该tab时 确认授权App访问Azure AD\n\n步骤：首先 在AzureAD注册app\ntrouble shooting\nTeams Toolkit issue: Your Microsoft 365 tenant admin hasn’t enabled sideloading permission for your account. You can’t install your app to Teams\n\nMicrosoft Doc: Prepare Your M365 Tenant\nTab Appde的身份验证流程\n"},{"title":"MySQL","url":"/qqsnote/2019/10/28/MySQL/","content":"前提select version()\n返回8.0.16\nroot 初始密码mysql安装时为root用户创建初始密码，可以在日志中找到/var/log/mysqld.log\n登录之后会勒令重设密码\n\nYou must reset your password using ALTER USRE statement before executing this statement.alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;A_Za_z0_9&#39;\n修改密码级别mysql&gt; set global validate_password.policy&#x3D;0;mysql&gt; set global validate_password.length&#x3D;3;\n现在可以设密码123了 \n\n新建管理员mysql&gt; create user &#39;admin&#39;@&#39;%&#39; identified by &#39;admin&#39;;mysql&gt; grant all privileges on *.* to &#39;admin&#39;@&#39;%&#39;;mysql&gt; flush privileges;\nnative password异常：\n\nClient does not support authentication protocol requested by server; consider upgrading MySQL client\n\n由于MySQL8 默认用编码口令代替了之前版本的native password，在使用第三方（如应用后台服务）连接数据库时，不符合协议\nALTER USER &#39;admin&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;admin&#39;;FLUSH PRIVILEGES;\n配置远程连接Ubuntu :/etc/mysql/mysqld.cnfbind-address &#x3D; 0.0.0.0可以注释掉（未验证）CentOS见/etc/my.conf指定了配置目录曾修改主机ip时mysql启动失败（查看状态:service mysqld status），现象是在本地登录mysql -u xxx -p验证密码后报异常:ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/run/mysqld/mysqld.sock’\n数据库时间select now();&#x2F;&#x2F; yyyy-MM-dd hh24:mi:ssselect sysdate();&#x2F;&#x2F; yyyy-MM-dd hh24:mi:ssselect current_date;&#x2F;&#x2F; yyyy-MM-dd 带()结果相同\n使用自增int作为主键mysql为什么建议使用自增主键\n关于删除表数据后重置auto increment:delete from table1;alter table1 AUTO_INCREMENT&#x3D;1;trancate table1;\n使用时间戳ALTER TABLE mytable CHANGE COLUMN ptime ptime TIMESTAMP  ON UPDATE CURRENT_TIMESTAMP\n联合唯一alter table all_user add unique key(employeeid, isvalid)\nCAUTION ! 上述语句是为了能在记录标记删除后，原纪录的唯一字段可以重新使用，但是如果isvalid是boolean(0-1)类型的，再次删除会造成违反联合唯一约束，解决方法是将isvalid以自增值标记，或以时间戳标记\n数据导入MySQL Workbench工具，支持csv，json格式的import wizard，其实可以直接用命令方式导入工具提供了直观图形界面和字段映射。然而csv的支持是个大坑。\n\nExcel在读取csv的时候是通过读取文件头上的bom来识别编码的，如果文件头无bom信息，则默认按照unicode编码读取。\nMySQL读取csv数据不能识别bom头，遇到utf8bom报“Can’t analyze file. Please try to change encoding type. If that doesn’t help, maybe the file is not: csv, or the file is empty.\n\n应如下操作：\n\n在Excel中整理待导入数据的格式，特别提示MySQL datetime类型字段数据源应调整为yyyy-mm-dd hh:mm:ss格式\n第一行列头会作为导入field的标识，这一行不能为中文（此坑已踩）\n保存为CSV UTF-8(Comma delimited) 在Excel365的SAVE AS选项中是这样。\n用Notepad++打开保存的文件，可见此时默认为Encoding in UTF8-BOM，需Convert to UTF8 （此时再使用Excel打开，会发现出现中文乱码，原因如上所述，找不到BOM将以Unicode解码,应该打开Excel，使用数据导入向导，from text/csv）\n使用Workbench Import Wizard导入\n\n关于utf8 和 utf8mb4记住，永远不要在MySQL中使用“utf8”\n大致是说，，别人utf-8都是四个字节编码，就MySQL所谓的utf-8是3字节，为与标准对应，又出了utf8mb4，请在MySQL中使用utf8mb4\n数据库备份mysqldump -u$&#123;username&#125; -p$&#123;password&#125; schemaName tableName1 tableName2 tableName3 &gt; backup.sql\n\n关于使用git实现快捷数据备份的实践cd ~&#x2F;Workspacegit clone git@projectX.gitmkdir ~&#x2F;Workspace&#x2F;projectX&#x2F;db mysqldump -u admin -padmin schemaName tableName &gt; backup.sqlgit commitgit push///思考：我要是不在本地跑源码(node server.js),是否可以省略拉本地仓库的步骤？是否可以直接将备份文件“push”到远程仓库？编辑文件在上图的workspace范畴中，我想，问题答案应该是否定的。\n常用查询show databases;create database csc;use csc;show tables;\n联合更新update asset a inner join department d on a.depart_id&#x3D;d.depart_id set a.department&#x3D;d.depart_name where a.department &lt;&gt; d.depart_name \nkey, primary key, unique key\n分组取第一条MySQl 8 之前的版本不支持partition byselect * from(select *,row_number() over(partition by Grade order by Score desc) as Sequence from Student)T where T.Sequence&lt;&#x3D;1workaroundSELECT         t1.*    FROM        action_history t1    INNER JOIN (SELECT         MAX(timestramp) AS newest, process_id    FROM        action_history    GROUP BY process_id) t2 ON t2.process_id &#x3D; t1.process_id        AND t2.newest &#x3D; t1.timestramp\n加/减后缀UPDATE all_user SET     email &#x3D; CONCAT(email, &#39;_disabled&#39;)WHERE    email NOT LIKE &#39;%yopmail.com&#39;        AND user_id &lt; 108\n去后缀，即取该字段的左起（总长度-后缀长度）个字符UPDATE all_user SET     email &#x3D; LEFT(email, LENGTH(email) - 9)WHERE    email NOT LIKE &#39;%yopmail.com&#39;        AND user_id &lt; 108\n查询各表数据条数USE information_schema;SELECT table_name,table_rows FROM TABLES WHERE TABLE_SCHEMA &#x3D; &#39;ams&#39; \nMySQL Utilities数据库更新工具$ mysqldbcompare --server1&#x3D;admin:admin@10.196.98.83:3306 --server2&#x3D;admin:admin@10.196.98.107:3306 ams:ams --run-all-tests --changes-for&#x3D;server1 --difftype&#x3D;sql &gt;&gt; d:\\temp\\diff.sql该工具依赖表mysql.proc, mysql.event已在mysql8以上版本移除，如有需要宜寻5.7等版本数据库导出\n","categories":["数据库"],"tags":["MySQL"]},{"title":"MySQL 存储过程","url":"/qqsnote/2019/12/23/MySQLStoredProcedure/","content":"概念\n存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。\n\n\n存储过程可封装，并隐藏复杂的商业逻辑。当dba与后台开发分离时，代码将以call xStoredProcedure 的形式访问数据库\n存储过程可以回传值，并可以接受参数。\n存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。使用存储过程 or 使用 DAO SQLStored Procedure|DAO SQL:——-|:——数据操作与底层业务解耦，以提供多方使用|不同服务做类似查询需要各自实现版本控制与代码分离|一致地版本控制仅需开发select和execuate权限|底层应用掌握较高地数据库权限增加了数据库运算压力|无法应对分表等业务扩展|扩展灵活数据库层面拼接查询或无法使用到索引|法国人说，使用存储过程封装数据操作主要是因为第一条地目的，然而私以为解耦数据操作和业务的话添加基础服务或中间件更好一些语法0 语句结构修改语句结束符，从分号 ; 临时改为两个 $$，使得过程体中使用的分号被直接传递到服务器，而不会被客户端（如mysql）解释。DELIMITER $$或DELIMITER &#x2F;&#x2F;\n过程体，类似其他变成语言中{语句块}BEGIN .... END    \n1 变量-- 存储过程变量，只能在存储过程定义中使用DECLARE l_int int unsigned default 4000000; -- 用户变量，可以在会话任意位置使用SET @p_in&#x3D;1  SELECT &#39;Hello World&#39; into @x;\n赋值多个变量select col1, col2, col3 into a, b, c from t limit 1;\n2 函数\n3 入参出参CREATE PROCEDURE 存储过程名([[IN |OUT |INOUT ] 参数名 数据类形...])set @p_in&#x3D;1;-- 假设STOREDPROCEDURE1是带一个入参的存储过程call STOREDPROCEDURE1(@p_in);-- 入参可以是字面量call STOREDPROCEDURE1(1); \n条件分支if a&gt;b thenselect a;elseselect b;end if;\ncase typewhen 0 theninsert into t values(101);when 1 theninsert into t values(11);elseinsert into t values(1);end case\n循环while i&lt;10 doinsert into t values(i)end while\nset v&#x3D;0;  LOOP_LABLE:loop  insert into t values(v);  set v&#x3D;v+1;  if v &gt;&#x3D;5 then leave LOOP_LABLE;  end if;  end loop;  \n游标create procedure asset_owner_clean()begindeclare _id int; -- asset list primary keydeclare targetid int; -- target user employee IDdeclare asset_owner varchar(80);declare asset_ownerid int;declare done int default false;-- set cursor traverse asset list whose owner is not nulldeclare asset cursor for (select asset_id,owner,owner_id from all_asset where (owner is not null and owner &lt;&gt;&#39;&#39;) or (owner_id is not null and owner_id &lt;&gt;&#39;&#39;));declare continue handler for not found set done &#x3D; true;open asset;checkloop: loopfetch asset into _id,asset_owner,asset_ownerid;SELECT _id, asset_owner, asset_ownerid;if done thenleave checkloop;end if;-- loop body start&lt;insert statements&gt;-- loop body endend loop checkloop;close asset;commit;end\n注意：跳出循环的句柄是not found，意味着循环体中将empty set赋值给变量会跳出loop如 selete * into _list where 1=2;\n\nSQL Server中调用存储过程的语法稍有不同, 见文章TransactSQL\n","categories":["数据库"],"tags":["存储过程"]},{"title":"NSIS宏","url":"/qqsnote/2020/04/20/NSIS-macro/","content":"NSIS（Nullsoft Scriptable Install System）\n\nMacros are used to insert code at compile time, depending on defines and using the values of the defines. The macro’s commands are inserted at compile time. This allows you to write general code only once and use it a lot of times but with few changes\n\n如上所述，宏的作用是“insert”代码，和通常的编程语言中的#define是一样的。insert的锚点标识是!insertmacro\n宏指令!macro Hello  DetailPrint &quot;Hello world&quot;!macroend Section Test  !insertmacro HelloSectionEnd\n含参宏!macro Hello What  DetailPrint &quot;Hello $&#123;What&#125;&quot;!macroend Section Test  !insertmacro Hello &quot;World&quot;  !insertmacro Hello &quot;Tree&quot;  !insertmacro Hello &quot;Flower&quot;SectionEnd","tags":["nsis"]},{"title":"NSIS插件","url":"/qqsnote/2020/06/01/NSIS-plugin/","content":"—&gt; NSIS收录插件 https://nsis.sourceforge.io/Category:Plugins\n—&gt; 插件本体是托管dll文件，区分unicode编码和ansi编码\n—&gt; NSIS默认检索在NSIS代码目录下的Plugins文件夹，作为插件路径，或可使用标识符!addplugindir 指定其他目录\n一个栗子!ifndef TARGETDIR!ifdef NSIS_UNICODE!define TARGETDIR &quot;..\\binU&quot;!else!define TARGETDIR &quot;..\\bin&quot;!endif!endif!addplugindir &quot;$&#123;TARGETDIR&#125;&quot;曾将!ifdef误解为if not define，NSIS用！xxx做关键字真的是坑。\n","tags":["nsis"]},{"title":"NSIS 基础","url":"/qqsnote/2020/06/03/NSIS/","content":"变量和常量a. 用var关键字来定义变量，使用$来引用变量。\nb. 寄存器变量 $0~$9,$R0~$R9\nc. 系统预置变量\n\n$INSTDIR用户定义的解压路径。\n$PROGRAMFILES程序文件目录(通常为 C:\\Program Files 但是运行时会检测)。\n$COMMONFILES公用文件目录。这是应用程序共享组件的目录(通常为 C:\\Program Files\\Common Files 但是运行时会检测)。\n$DESKTOPWindows 桌面目录(通常为 C:\\windows\\desktop 但是运行时会检测)。该常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。\n$EXEDIR安装程序运行时的位置。(从技术上来说你可以修改改变量，但并不是一个好方法)。\n${NSISDIR}包含 NSIS 安装目录的一个标记。在编译时会检测到。常用于在你想调用一个在 NSIS 目录下的资源时，例如：图标、界面……\n$WINDIRWindows 目录(通常为 C:\\windows 或 C:\\winnt 但在运行时会检测)\n$SYSDIRWindows 系统目录(通常为 C:\\windows\\system 或 C:\\winnt\\system32 但在运行时会检测)\n$TEMP系统临时目录(通常为 C:\\windows\\temp 但在运行时会检测)\n$STARTMENU开始菜单目录(常用于添加一个开始菜单项，使用 CreateShortCut)。该常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。\n$SMPROGRAMS开始菜单程序目录(当你想定位 + $STARTMENU\\程序 时可以使用它)。该常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。\n$SMSTARTUP开始菜单程序/启动 目录。该常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。\n$QUICKLAUNCH在 IE4 活动桌面及以上的快速启动目录。如果快速启动不可用，仅仅返回和 + $TEMP 一样。\n$DOCUMENTS文档目录。一个当前用户典型的路径形如 C:\\Documents and Settings\\Foo\\My Documents。这个常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。该常量在 Windows 95 且 Internet Explorer 4 没有安装时无效。\n$SENDTO该目录包含了“发送到”菜单快捷项。\n$RECENT该目录包含了指向用户最近文档的快捷方式。\n$FAVORITES该目录包含了指向用户网络收藏夹、文档等的快捷方式。这个常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。该常量在 Windows 95 且 Internet Explorer 4 没有安装时无效。\n$MUSIC用户的音乐文件目录。这个常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。该常量仅在 Windows XP、ME 及以上才有效。\n$PICTURES用户的图片目录。这个常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。该常量仅在 Windows 2000、XP、ME 及以上才有效。\n$VIDEOS用户的视频文件目录。这个常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。该常量仅在 Windows XP、ME 及以上才有效。\n$NETHOOD该目录包含了可能存在于我的网络位置、网上邻居文件夹的链接对象。该常量在 Windows 95 且 Internet Explorer 4 和活动桌面没有安装时无效。\n$FONTS系统字体目录。\n$TEMPLATES文档模板目录。这个常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。\n$APPDATA应用程序数据目录。当前用户路径的检测需要 Internet Explorer 4 及以上。所有用户路径的检测需要 Internet Explorer 5 及以上。这个常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。该常量在 Windows 95 且 Internet Explorer 4 和活动桌面没有安装时无效。\n$PRINTHOOD该目录包含了可能存在于打印机文件夹的链接对象。该常量在 Windows 95 和 Windows 98 上无效。\n$INTERNET_CACHEInternet Explorer 的临时文件目录。该常量在 Windows 95 和 Windows NT 且 Internet Explorer 4 和活动桌面没有安装时无效。\n$COOKIESInternet Explorer 的 Cookies 目录。该常量在 Windows 95 和 Windows NT 且 Internet Explorer 4 和活动桌面没有安装时无效。\n$HISTORYInternet Explorer 的历史记录目录。该常量在 Windows 95 和 Windows NT 且 Internet Explorer 4 和活动桌面没有安装时无效。\n$PROFILE用户的个人配置目录。一个典型的路径如 C:\\Documents and Settings\\Foo。该常量在 Windows 2000 及以上有效。\n$ADMINTOOLS一个保存管理工具的目录。这个常量的内容(所有用户或当前用户)取决于 SetShellVarContext 设置。默认为当前用户。该常量在 Windows 2000、ME 及以上有效。\n$RESOURCES该资源目录保存了主题和其他 Windows 资源(通常为 C:\\Windows\\Resources 但在运行时会检测)。该常量在 Windows XP 及以上有效。\n$RESOURCES_LOCALIZED该本地的资源目录保存了主题和其他 Windows 资源(通常为 C:\\Windows\\Resources\\1033 但在运行时会检测)。该常量在 Windows XP 及以上有效。\n$CDBURN_AREA一个在烧录 CD 时储存文件的目录。.该常量在 Windows XP 及以上有效。\n$HWNDPARENT父窗口的十进制 HWND。\n$PLUGINSDIR该路径是一个临时目录，当第一次使用一个插件或一个调用 InitPluginsDir 时被创建。该文件夹当解压包退出时会被自动删除。这个文件夹的用意是用来保存给 InstallOptions 使用的 INI 文件、启动画面位图或其他插件运行需要的文件。\n\n函数NSIS函数本身没有输出输出，但是可以访问变量和堆栈使用Pop Push实现输入输出Function LCIDtoTAG     $&#123;case&#125; &quot;1036&quot;    Push &quot;fr_FR&quot;    $&#123;break&#125;    $&#123;case&#125; &quot;1049&quot;    Push &quot;ru_RU&quot;    $&#123;break&#125;    $&#123;case&#125; &quot;1041&quot;    Push &quot;ja_JP&quot;    $&#123;break&#125;    $&#123;case&#125; &quot;2052&quot;    Push &quot;zh_CN&quot;    $&#123;break&#125;    $&#123;default&#125;    Push &quot;en_US&quot;    $&#123;break&#125;    $&#123;endswitch&#125;FunctionEndSection    Call LCIDtoTAG    Pop $0SectionEnd\n跳转StrCmp $1 &quot;&quot; +1 +2DetailPrint &quot;parameter is empty&quot;DetailPrint &quot;parameter is not empty&quot;\n+n是从该语句向下偏移的“指针”，空行过滤掉不计入偏移量\n","tags":["NSIS"]},{"title":"Netty","url":"/qqsnote/2023/12/06/Netty/","content":"Netty到底是什么\n"},{"title":"NeRF","url":"/qqsnote/2023/03/15/NeRF/","content":"","tags":["AI"]},{"title":"神经网络","url":"/qqsnote/2023/03/16/NeuralNetworks/","content":"神经网络 神经网络15分钟入门\n  如图所示两层神经网络 隐藏层 H = W1X+b1 输出层 Y = W2H+b2\nCNNConvolutional Neural Networks 卷积神经网络\n","tags":["AI"]},{"title":"Nginx","url":"/qqsnote/2019/04/20/Nginx/","content":"配置依赖库。\ngcc(GNU Compiler Collection)\n\npcre依赖库\n\nzlib依赖库\n\nSSL依赖库\n\n\nyum install gcc pcre-devel zlib zlib-devel openssl openssl-devel\n安装NGINX官网下载地址: http://nginx.org/en/download.html\n—&gt; 解压tar -zxvf nginx-1.14.2.tar.gzz(gz格式)j(bz2格式)x(解压)v(显示所有过程)f(使用档案名称命名)—&gt; configure进入解压目录下.&#x2F;configure—&gt;编译makemake install\n启动和停止&#x2F;nginx&#x2F;sbin&#x2F;nginx&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload\n—&gt;查看进程ps -ef | grep nginx访问index.html页面，404—&gt;检查端口telnet 127.0.0.1 8080显示Connection closed by foreign host\n—&gt;查看和关闭防火墙firewall-cmd --statesystemctl stop firewalld.service—&gt;服务开机启动systemctl disable firewalld.servicesystemctl enable nginx.service手动下载源码，并编译安装的是没有nginx.service的，手动创建vi &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;nginx.service编辑内容如下[Unit]Description&#x3D;nginxAfter&#x3D;network.target  [Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginxExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reloadExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quitPrivateTmp&#x3D;true  [Install]WantedBy&#x3D;multi-user.target\nweb服务及反向代理/usr/local/nginx/nginx.conf server &#123;        listen 8080;        #nginx服务器的代理端口        server_name _;    location &#x2F; &#123;        proxy_pass http:&#x2F;&#x2F;172.18.78.14:6080;    #需要反向代理的IP地址+端口        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;Upgrade&quot;;        &#125;&#125;\n负载均衡juejin\n代理服务ngx_http_proxy_connect_module\n","categories":["工具"],"tags":["Linux","Nginx"]},{"title":"Ngx-translate","url":"/qqsnote/2020/05/21/Ngx-translate/","content":"\nNGX-Translate is an internationalization library for Angular. NGX-Translate is also extremely modular. It is written in a way that makes it really easy to replace any part with a custom implementation in case the existing one doesn’t fit your needs.\nWhy ngx-translate exists if we already have built-in Angular i18n\n\n关于载入翻译文件\nHttp Loader: load json translation files with http\nAngular Universal Loader: load json translation files with fs instead of http\nPo Loader: load .po files with http\n\n集成步骤npm install @ngx-translate&#x2F;core @ngx-translate&#x2F;http-loader --save\n在模块中引入import &#123;TranslateModule&#125; from &#39;@ngx-translate&#x2F;core&#39;;export function createTranslateLoader(http: HttpClient) &#123;  return new TranslateHttpLoader(http, &#39;.&#x2F;assets&#x2F;i18n&#x2F;&#39;, &#39;.json&#39;);&#125;@NgModule(&#123;    imports: [        BrowserModule,        HttpClientModule,        TranslateModule.forRoot(&#123;            loader: &#123;            provide: TranslateLoader,            useFactory: createTranslateLoader,            deps: [HttpClient]      &#125;,      defaultLanguage: &#39;en&#39;        &#125;)    ],    bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;组件注入及初始化export class AppComponent &#123;    constructor(translate: TranslateService) &#123;        &#x2F;&#x2F; this language will be used as a fallback when a translation isn&#39;t found in the current language        translate.setDefaultLang(&#39;en&#39;);         &#x2F;&#x2F; the lang to use, if the lang isn&#39;t available, it will use the current loader to get them        translate.use(&#39;en&#39;);    &#125;&#125;在模板中使用管道标记待翻译标记&lt;p&gt;&#123;&#123;&quot;sayHi&quot; | translate&#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123;&#39;sayHiWithParameter&#39; | translate:userObj&#125;&#125;&lt;&#x2F;p&gt;&lt;p&gt;&#123;&#123; &#39;ROLES.&#39; + role | uppercase | translate &#125;&#125;&lt;&#x2F;p&gt;翻译文件，对于HTTP Loader是以Locale_ID命名的Jsonsrc├───assets│   ├───i18n│   │       en.json│   │       fr.json│   │       zh.json翻译格式&#123;    &quot;introductionHeader&quot;:&quot;你好&quot;,    &quot;ROLE&quot;:&#123;        &quot;ADMIN&quot;: &quot;管理员&quot;，        &quot;USER&quot;: &quot;用户&quot;    &#125;,    &quot;sayHiWithParameter&quot;:&quot;你好，&#123;&#123;pride&#125;&#125;的&#123;&#123;lastname&#125;&#125;&#125;先生&quot;&#125;在ts代码中引用翻译translate.get(&#39;HELLO&#39;, &#123;value: &#39;world&#39;&#125;).subscribe((res: string) &#x3D;&gt; &#123;    console.log(res);    &#x2F;&#x2F;&#x3D;&gt; &#39;hello world&#39;&#125;);使用 PO Loader官方提供给的 @biesbjerg/ngx-translate-po-http-loader，很遗憾，并不好使，或许是因为新版本的gettext-parser将msgctxt（信息上下文）作为一级父节点，而ngx-translate-po-http-loader一直没有更新使支持msgctxt部分zh_CN.po文件:msgid &quot;&quot;msgstr &quot;&quot;&quot;MIME-Version: 1.0\\n&quot;&quot;Content-Type: text&#x2F;plain; charset&#x3D;UTF-8\\n&quot;&quot;Content-Transfer-Encoding: 8bit\\n&quot;&quot;Plural-Forms: nplurals&#x3D;1; plural&#x3D;0;\\n&quot;&quot;X-Language: zh_CN\\n&quot;&quot;X-Qt-Contexts: true\\n&quot;#: ..&#x2F;scanflow&#x2F;res&#x2F;qml&#x2F;Dialog&#x2F;AboutDialog.qml:25msgctxt &quot;AboutDialog|&quot;msgid &quot;About&quot;msgstr &quot;关于&quot;#: ..&#x2F;scanflow&#x2F;res&#x2F;qml&#x2F;Dialog&#x2F;AboutDialog.qml:52msgctxt &quot;AboutDialog|&quot;msgid &quot;Product Version&quot;msgstr &quot;产品版本&quot;通过上文“翻译格式”可知，ngx-translate允许多级属性mapping，如&lt;h1&gt;&#123;&#123; &quot;AboutDialog|.About&quot; |translate&#125;&#125;&lt;&#x2F;h1&gt;另外，gettext-parser会将分段的msgid和msgstr进行合并，即msgctxt &quot;ErrorMessage|&quot;msgid &quot;&quot;&quot;Application preferences have been damaged. Reinstall the application to &quot;&quot;solve the problem.&quot;msgstr &quot;&quot;&quot;Předvolby aplikace byly poškozeny. Problém vyřešíte opětovnou instalací &quot;&quot;aplikace.&quot;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&#123;    ...    &quot;ErrorMessage|&quot;:&#123;        msgctxt:&quot;ErrorMessage|&quot;,        msgid:&quot;Application preferences have been damaged. Reinstall the application to solve the problem.&quot;,        msgstr:[&quot;Předvolby aplikace byly poškozeny. Problém vyřešíte opětovnou instalací aplikace.&quot;]    &#125;&#125;原理见@ngx-translate/core/fesm2015/ngx-translate-core.jsgetValue(target, key) &#123;    &#x2F;** @type &#123;?&#125; *&#x2F;    let keys &#x3D; typeof key &#x3D;&#x3D;&#x3D; &#39;string&#39; ? key.split(&#39;.&#39;) : [key];    key &#x3D; &#39;&#39;;    do &#123;        key +&#x3D; keys.shift();        if (isDefined(target) &amp;&amp; isDefined(target[key]) &amp;&amp; (typeof target[key] &#x3D;&#x3D;&#x3D; &#39;object&#39; || !keys.length)) &#123;            target &#x3D; target[key];            key &#x3D; &#39;&#39;;        &#125;        else if (!keys.length) &#123;            target &#x3D; undefined;        &#125;        else &#123;            key +&#x3D; &#39;.&#39;;        &#125;    &#125; while (keys.length);    return target;&#125;结合ngx-translate解析翻译时的逻辑，在实现PO Loader的getTranslation方法（关于自定义loader的继承和实现，ngx-translate有指引 -&gt; link）时，应将msgctxt，msgid转为父子属性形式public getTranslation(lang: string): Observable&lt;any&gt; &#123;    return this._http        .get(&#96;$&#123;this._prefix&#125;&#x2F;$&#123;lang&#125;$&#123;this._suffix&#125;&#96;, &#123; responseType: &#39;text&#39; &#125;)        .pipe(            map((contents: string) &#x3D;&gt; this.parse(contents)));&#125;&#x2F;*** Parse po file* @param contents* @returns &#123;any&#125;*&#x2F;public parse(contents: string): any &#123;    let translations: &#123; [key: string]: object | string &#125; &#x3D; &#123;&#125;;    const po &#x3D; gettext.po.parse(contents, &#39;utf-8&#39;);    if (!po.translations.hasOwnProperty(this.domain)) &#123;        return translations;    &#125;    Object.keys(po.translations)        .forEach(domain &#x3D;&gt; &#123;            if (domain.length &#x3D;&#x3D;&#x3D; 0) &#123; return; &#125;            if (po.translations[domain].msgstr) &#123; &#x2F;&#x2F; there is no msgctxt                translations[domain] &#x3D; po.translations[domain].msgstr;            &#125; else &#123;                &#x2F;&#x2F; context                translations[domain] &#x3D; &#123;&#125;;                Object.keys(po.translations[domain]).forEach(key &#x3D;&gt; &#123;                    let translation: string | Array&lt;string&gt; &#x3D; po.translations[domain][key].msgstr.pop();                    if (translation instanceof Array &amp;&amp; translation.length &gt; 0) &#123;                        translation &#x3D; translation[0];                    &#125;                    if (key.length &gt; 0 &amp;&amp; translation.length &gt; 0) &#123;                        translations[domain][key] &#x3D; translation;                    &#125;                &#125;);            &#125;        &#125;);    return translations;&#125;引入自己的 loader moduleimport &#123; TranslatePoHttpLoader &#125; from &#39;.&#x2F;edited-po-loader&#39;;export function createTranslateLoader(http: HttpClient) &#123;\treturn new TranslatePoHttpLoader(http, &#39;assets&#x2F;i18n&#39;, &#39;.po&#39;);缺失的翻译 handle missing translationsimport &#123;MissingTranslationHandler, MissingTranslationHandlerParams&#125; from &#39;@ngx-translate&#x2F;core&#39;;export class MyMissingTranslationHandler implements MissingTranslationHandler &#123;    handle(params: MissingTranslationHandlerParams) &#123;        return &#39;some value&#39;;    &#125;&#125;@NgModule(&#123;    imports: [        BrowserModule,        TranslateModule.forRoot(&#123;            missingTranslationHandler: &#123;provide: MissingTranslationHandler, useClass: MyMissingTranslationHandler&#125;,            useDefaultLang: false        &#125;)    ],    providers: [    ],    bootstrap: [AppComponent]&#125;)export class AppModule &#123; &#125;\nplural and select这个库没有相应的api与i18n的 plural / select 模式相对应，对于这些场景需要使用ngIf或ngSwitch指令实现\n","categories":["前端技术"],"tags":["Angular"]},{"title":"Nodejs服务端框架","url":"/qqsnote/2019/12/04/NodejsFramework/","content":"Express集合式开发框架，自身已经集成了诸多常用中间件如，router， static， bodyparse等。然而随着开发需求的丰富，仍然不免要在github上调查采集。\n某年月日，基于express.js的服务，使用了morgan格式化日志，如何记response body是个难题，因为一旦response.end()或者response.json(x),其发送的内容将不复存在。\n\nexpress 的中间件机制是线性执行的\n\n受限于当时的js标准，异步过程只能以回调的方式实现，如果顺位在后的中间件返回结果到前一个，必须在调用后者时就带上回调函数, 当中间件“链”很长时，就成了Callback Hell\n于是作者（TJ Holowaychuk大神）又写了一个Koa，实现洋葱模型的中间件机制。\nKoa据说是轻量级、渐进式框架。\nEgg阿里基于Koa统一规范化常用服务及功能，给出较为详细的文档说明，势必免去开发者一些调查采集的工作。\n","categories":["前端技术"],"tags":["express"]},{"title":"OAuth","url":"/qqsnote/2019/12/09/OAuth2/","content":"案例某年月日开发AMS系统，使用公司SSO服务提供的账号密码，用户在AMS前端登录页填写账号密码，AMS后台有记录post请求的requestbody的功能，于是我得到了用户的SSO账号密码。。。\n对于本AMS系统，应视为使用第三方账号登录，类似使用wechat或github账号登录，点击入口后弹出第三方页面，通过彼系统认证返回客户端（browser）授权码，本系统凭此授权码访问与第三方有关的资源，通常可能只是从第三方获取用户名、头像、邮箱来填充本系统的个人信息识别.\n\n此外在CS Scanflow登录Cloud地模块中，设计期望以账密登录后返回两个token，其中A是访问Cloud相关资源地凭据，B是保持登录(Remember me)需要token，当A过期时，调用接口，Cloud认证B合法，返回新的A，即可在后续使用A继续访问Cloud资源。\nOpenIDOpenID 去中心化的身份识别框架，根据协议，任何网站可以作为identity provider，通过一串 URI 向某个网站证明用户的身份。\nOAuth标准\nOAuth在”客户端(受限资源/服务请求方)”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，使用授权层颁发的令牌（token），访问服务提供商的资源。用户注册在服务端的账户密码，不会暴露给客户端。服务提供商可以自由限制授权层令牌的权限范围和有效期。QQs：OAuth不强调认证，它是一个授权协议，实现的是支持由第三方提供授权访问的标准。\nOIDCOpenID Connect 基于OAuth 2.0协议之上的简单身份层，它允许客户端根据授权服务器的认证结果最终确认终端用户的身份，以及获取基本的用户信息；它支持包括Web、移动、JavaScript在内的所有客户端类型去请求和接收终端用户信息和身份认证会话信息；它是可扩展的协议，允许你使用某些可选功能，如身份数据加密、OpenID提供商发现、会话管理等。\n授权方式授权码（authorization code）上文已提到的使用第三方登录的方式即授权码方式，授权码方式是最常用且靠谱的授权方式，相比之下，其余三种比较扯淡。下图中A.com实为客户端，如某电商平台，B.com为用户信息持有方，如某社交平台(包含了受限数据服务以及授权服务)，经过对接A.com可以通过如图的流程使用B.com的用户登录\n\n跳转到B授权页\n确认授权，重定向回A，并带回authorization code\n向B请求访问受限数据，传递A身份，以及授权码\n请求返回可访问受限数据令牌隐藏式（隐式授权）直接返回令牌，安全风险较高 注1密码式返回账号密码，A以此申请访问B的令牌，风险更高。(私以为，既然B予以这种信任，即将访问权限控制让与A，A可以直接以账密登录B而不用可能受限的token)凭据式对于没有前端的命令行应用，以get请求，用query parameters传参直接得到令牌。前后端分离的SSO关于OAuth, OpenId, OIDC什么的网上有文章说OAuth是authorization， OpenId是authentication，这听起来很谜。。OpenID是一个去中心化的网上身份认证系统。（维基百科）\n\n\n所谓认证系统，解决的是”你是谁”的问题，用户在在identity provider（idp）的服务上注册，客户端登录即去idp获取OpenID标识对应的token，服务提供者校验身份，是拿客户端的token去idp确认。OIDC（OpenID Connect）OpenID + OAuth2.0认证（授权访问）服务\n\naccess token 是客户端和资源服务器之间的凭据\n\n那access token在资源服务器上是如何验证的呢？每个请求过来，资源服务器都会拿access token到SSO上去核对吗？\n事实上是不一定的。以JWT为例。如果Access Token是JWT形式签发，资源服务可以使用验证签名的方式判断是否合法，只需要把签名密钥在资源服务同步一份即可。典型的是使用非对称加密（见加密篇），资源服务保留一份公钥，access token由授权服务使用私钥签发，资源服务是可以对其进行校验的。JWT允许携带一些信息，如用户，权限，有效期等，因此资源服务判断JWT合法之后可以继续根据携带信息来判断是否可访问资源。这样就有可以快速验证有效性，不需要频繁访问授权服务的优点，缺点是Access Token一旦签发，将很难收回，只能通过过期来失效。\naccess token, id token, refresh token在Google，微博等认证门户登录成功后 颁发id token， 表示该账户通过认证， 是可以被信赖的， id token中包含用户的名字，邮箱等信息，可以个性化用户体验（personalize user experience）如在UI上显示用户姓名，在生日当天发送祝福消息等 总之与认证有关与授权无关\naccess token用作访问受限的资源，即身份认证授权服务器授权客户端访问某受保护的资源，为其颁发access token，在资源服务器（作为audience）上验证，access token不绑定客户端，因此可以copy出来使用，也就是客户端有责任保护自己的access token安全\n可以说access token用于资源服务器，而不是客户端，与id token不同，它没有什么要告诉客户端的，包括账户是否已通过认证，事实上，账户退出，access token依然可以工作\nrefresh token用以刷新access token 这对于SPA可能不足以保证refresh token的安全，可以使用refresh token的轮换机制，即在access token刷新后更新refresh token，使原refresh token不会再被攻击者利用blablarefresh token, what are they and when to use them\n\n客户端是在服务器上执行的传统 Web 应用程序吗？使用授权代码流。\n\n客户端是单页应用程序 (SPA) 吗？使用带有验证密钥的授权代码流进行代码交换 (PKCE)。\n\n客户端是不需要访问令牌的单页应用程序 (SPA) 吗？将隐式流与 Form Post 一起使用。\n\n客户端是资源所有者吗？您可以使用客户端凭据流。\n\n客户端是否绝对信任用户凭据？您可以使用Resource Owner Password Flow。\n\n\n","categories":["协议和规范"],"tags":["认证&授权"]},{"title":"Node.js Process","url":"/qqsnote/2019/08/06/NodeProcess/","content":"process模块和process.env环境变量vscode debug&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;type&quot;: &quot;node&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;name&quot;: &quot;Launch Program&quot;,            &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;\\\\server.js&quot;,            &quot;args&quot;: [&quot;--trace-sync-io&quot;],            &quot;env&quot;:&#123;                &quot;NODE_ENV&quot;:&quot;production&quot;,                &quot;PORT&quot;:&quot;3001&quot;            &#125;        &#125;    ]&#125;关于设置环境变量 Node及Express入门\nnode.js 程序调用命令行exec方式var exec &#x3D; require(&quot;child_process&quot;).exec;var LangLocale &#x3D; &#123;    fr: &#39;fr_FR&#39;,    fr_FR: &#39;fr-FR&#39;,    zh_CN: &#39;zh-CN&#39;,    zh_TW: &#39;zh-TW&#39;,    en: &#39;en_US&#39;,    en_US: &#39;en_US&#39;,    ja: &#39;ja_JP&#39;,    es: &#39;es_ES&#39;,    de: &#39;de_DE&#39;,    da: &#39;da_DK&#39;,&#125;var langs &#x3D; Object.values(LangLocale)function runCMD(cmd) &#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        exec(&#96;yarn extract src&#x2F;locales&#x2F;$&#123;cmd&#125;.json &#96;, &#123;            maxBuffer: 1024 * 2000        &#125;, function (err, stdout, stderr) &#123;            if (err) &#123;                console.log(err);                reject(err);            &#125; else if (stderr.lenght &gt; 0) &#123;                reject(new Error(stderr.toString()));            &#125; else &#123;                console.log(stdout);                resolve();            &#125;        &#125;);    &#125;)&#125;langs.forEach(async (lang) &#x3D;&gt; &#123;    await runCMD(lang)&#125;)\n等待用户输入","categories":["前端技术"],"tags":["Node.js"]},{"title":"OData","url":"/qqsnote/2020/11/03/ODATA/","content":"OData协定\nOpen Data Protocol（开放数据协议，OData）是用来查询和更新数据的一种Web协议，其提供了把存在于应用程序中的数据暴露出来的方式。OData运用且构建于很多Web技术之上，比如HTTP、Atom Publishing Protocol（AtomPub）和JSON，提供了从各种应用程序、服务和存储库中访问信息的能力。OData被用来从各种数据源中暴露和访问信息，这些数据源包括但不限于：关系数据库、文件系统、内容管理系统和传统Web站点。\n\nOData解决的是Restful Api定义太随便的问题比如查询人员A团队的API 可能是这样：http://A/api/Users/001B团队的API 可能是这样：http://A/api/Users?id=001返回结果也可能各有加工，{status: “ok”,data: {…}}的设计实际上只是自我感觉良好\nOData则约束调用接口 Users然后返回值形如&#123;    &quot;@odata.context&quot;: &quot;https:&#x2F;&#x2F;localhost:44346&#x2F;odata&#x2F;v1&#x2F;$metadata#Users&quot;,    &quot;value&quot;: [        &#123;            &quot;name&quot;: &quot;QQs&quot;,            &quot;emailAddress&quot;: &quot;qqs@qqs.qqs&quot;,            &quot;logo&quot;: &quot;img base 64&quot;,            &quot;enable&quot;: true,            &quot;addressId&quot;: &quot;ca35902d-d236-4496-b649-2f7fcf531110&quot;,            &quot;recordId&quot;: &quot;c7612b51-ddb2-eb11-9bf6-180373e9ce7d&quot;,            &quot;recordCreated&quot;: &quot;2021-05-12T05:52:19.979+08:00&quot;,            &quot;recordLastUpdated&quot;: &quot;2021-05-12T04:48:39.377+08:00&quot;        &#125;    ]&#125;返回值中包含接口的数据上下文文档，包含属性类型定义，Users 相关Api的参数设计等OData似乎暴露了过多的底层设计的，而这么做的目的和结果是对数据的访问不再受限于定义各种查询、过滤以及分页API（由OData库依照标准实现类似sql的查询方式）在.net开发中,得益于entityframework强大的关联模型设计和limbda查询方式，OData方显强大\n参考OData.org Getting started\n安装和应用OData LibraryNuget Package Manager 安装Microsoft.AspNetCore.OData Caution! 这里是7.0版本添加Model DBContext Controller(这块参考EntityFramework)public void ConfigureServices(IServiceCollection services)&#123;    services.AddMvc();    services.AddOData();&#125;public void Configure(IApplicationBuilder app)&#123;    var builder &#x3D; new ODataConventionModelBuilder(app.ApplicationServices);    builder.EntitySet&lt;Product&gt;(&quot;Products&quot;);    app.UseMvc(routeBuilder &#x3D;&gt;    &#123;        &#x2F;&#x2F; and this line to enable OData query option, for example $filter        routeBuilder.Select().Expand().Filter().OrderBy().MaxTop(100).Count();        routeBuilder.MapODataServiceRoute(&quot;ODataRoute&quot;, &quot;odata&quot;, builder.GetEdmModel());        &#x2F;&#x2F; uncomment the following line to Work-around for #1175 in beta1        &#x2F;&#x2F; routeBuilder.EnableDependencyInjection();    &#125;);&#125;\n参考QQs TeamsPersistanceCenter项目\nfilter\n$filter=name eq ‘QQstone’\n$filter=type ne ‘standard’\n$filter=contains(email, ‘163.com’)\n$filter=quantity gt 1 and le 100gt(greater than) lt(less than) ge(greater than or equal to) le(less than or equal to)注意单引号  select\n$select=name,email,typeexpand关联查询 $expand=department关于分页https://localhost:44346/odata/v1/Users?$count=true\n\nhttps://localhost:44346/odata/v1/Users?$skip=20&amp;$top=10\ntrouble shooting\nissue: The EntityXXX key in the URL xxxx does not match the key (00000000-0000-0000-0000-000000000000) in the request content body.\n\nreason：put method, post body中也要包含主键 xxxx\nflaw过分暴露底层模型设计, 也许像GraphQL一样，需要在接口层以下封装一下，微软也不是什么都没做，EDM了解一下\nEDM\nThe Entity Data Model, or EDM, is the abstract data model that is used to describe the data exposed by an OData service.   \nThe EDM makes the stored form of data irrelevant to application design and development.\n\nEF提供了对象描述数据结构的概念 EDM使应用(上层)设计和开发与存储形式无关更正 EDM就是Model层映射了实体数据的class，也就是之前说的‘entity’ 于封装数据木有直接关系 private static IEdmModel GetEdmModel()&#123;    var builder &#x3D; new ODataConventionModelBuilder();    builder.EnableLowerCamelCase();    builder.EntitySet&lt;Partner&gt;(GetEntitySetName&lt;PartnersController&gt;());    var entityType &#x3D; builder.EntitySet&lt;Partner&gt;(GetEntitySetName&lt;PartnersController&gt;()).EntityType;    entityType.Collection.Function(nameof(PartnersController.GetPartnersBySN))        .ReturnsCollectionFromEntitySet&lt;Partner&gt;(&quot;Partners&quot;)        .Parameter&lt;string&gt;(&quot;serialNo&quot;);    builder.EntitySet&lt;Member&gt;(GetEntitySetName&lt;MembersController&gt;());    return builder.GetEdmModel();&#125;\nAction &amp; Function参考Microsoft Docs\n\n动作和函数之间的区别在于: Action可以有副作用(side effect)而Function没有，Action应用场景或应用如复杂交易、一次操作多个实体、仅更新实体部分属性、发送非实体数据等\n\nAction:ODataModelBuilder builder &#x3D; new ODataConventionModelBuilder();builder.EntitySet&lt;Product&gt;(&quot;Products&quot;);&#x2F;&#x2F; New code:builder.Namespace &#x3D; &quot;ProductService&quot;;builder.EntityType&lt;Product&gt;()    .Action(&quot;Rate&quot;)    .Parameter&lt;int&gt;(&quot;Rating&quot;);使能名为‘Rate’的Action的接口 http://localhost/Products(1)/ProductService.Ratecontroller中定义Action，方法名与操作名称相同[HttpPost]public async Task&lt;IHttpActionResult&gt; Rate([FromODataUri] int key, ODataActionParameters parameters)&#123;    if (!ModelState.IsValid)    &#123;        return BadRequest();    &#125;    int rating &#x3D; (int)parameters[&quot;Rating&quot;];    db.Ratings.Add(new ProductRating    &#123;        ProductID &#x3D; key,        Rating &#x3D; rating    &#125;);    try    &#123;        await db.SaveChangesAsync();    &#125;    catch (DbUpdateException e)    &#123;        if (!ProductExists(key))        &#123;            return NotFound();        &#125;        else        &#123;            throw;        &#125;    &#125;    return StatusCode(HttpStatusCode.NoContent);&#125;Function:builder.EntityType&lt;Product&gt;().Collection    .Function(&quot;ProdFunc1&quot;)    .Returns&lt;double&gt;();GET http://localhost:38479/Products/ProductService.ProdFunc1controller中用同样的名称定义API方法[HttpGet]public IHttpActionResult MostExpensive()&#123;    var product &#x3D; db.Products.Max(x &#x3D;&gt; x.Price);    return Ok(product);&#125;Unbound Function:Action或Function应用于单个实体或集合，称之为绑定(binding),未绑定(unbound)的Action/Function称为服务的静态操作builder.Function(&quot;GetSalesTaxRate&quot;)    .Returns&lt;double&gt;()    .Parameter&lt;int&gt;(&quot;PostalCode&quot;);[HttpGet][ODataRoute(&quot;GetSalesTaxRate(PostalCode&#x3D;&#123;postalCode&#125;)&quot;)]public IHttpActionResult GetSalesTaxRate([FromODataUri] int postalCode)&#123;    double rate &#x3D; 5.6;  &#x2F;&#x2F; Use a fake number for the sample.    return Ok(rate);&#125;\ncontainment[EnableQuery]         [ODataRoute(&quot;Accounts(&#123;accountId&#125;)&#x2F;PayinPIs(&#123;paymentInstrumentId&#125;)&quot;)]         public IHttpActionResult GetSinglePayinPI(int accountId, int paymentInstrumentId)         &#123;                 var payinPIs &#x3D; _accounts.Single(a &#x3D;&gt; a.AccountID &#x3D;&#x3D; accountId).PayinPIs;                 var payinPI &#x3D; payinPIs.Single(pi &#x3D;&gt; pi.PaymentInstrumentID &#x3D;&#x3D; paymentInstrumentId);                 return Ok(payinPI);         &#125;         \n关于RESTful和GraphGLREST(Representational State Transfor) 资源表述性状态传递 将状态管理责任传递到客户端 服务端返回后不保留状态\n","categories":["后端技术"],"tags":["OData"]},{"title":"OpenCV 颜色识别","url":"/qqsnote/2023/05/23/OpenCV-ColorRecognize/","content":"参考C++版Determining object color with OpenCV参考python多边形形状及颜色\n# coding&#x3D;utf-8# 导入一些python包from scipy.spatial import distance as distfrom collections import OrderedDictimport numpy as npimport cv2# 创建一个颜色标签类class ColorLabeler:\tdef __init__(self):\t\t# 初始化一个颜色词典\t\tcolors &#x3D; OrderedDict(&#123;\t\t\t&quot;red&quot;: (255, 0, 0),\t\t\t&quot;green&quot;: (0, 255, 0),\t\t\t&quot;blue&quot;: (0, 0, 255)&#125;)\t\t# 为LAB图像分配空间\t\tself.lab &#x3D; np.zeros((len(colors), 1, 3), dtype&#x3D;&quot;uint8&quot;)\t\tself.colorNames &#x3D; []\t\t# 循环 遍历颜色词典\t\tfor (i, (name, rgb)) in enumerate(colors.items()):\t\t\t# 进行参数更新\t\t\tself.lab[i] &#x3D; rgb\t\t\tself.colorNames.append(name)\t\t# 进行颜色空间的变换\t\tself.lab &#x3D; cv2.cvtColor(self.lab, cv2.COLOR_RGB2LAB)\tdef label(self, image, c):\t\t# 根据轮廓构造一个mask，然后计算mask区域的平均值 \t\tmask &#x3D; np.zeros(image.shape[:2], dtype&#x3D;&quot;uint8&quot;)\t\tcv2.drawContours(mask, [c], -1, 255, -1)\t\tmask &#x3D; cv2.erode(mask, None, iterations&#x3D;2)\t\tmean &#x3D; cv2.mean(image, mask&#x3D;mask)[:3]\t\t# 初始化最小距离\t\tminDist &#x3D; (np.inf, None)\t\t# 遍历已知的LAB颜色值\t\tfor (i, row) in enumerate(self.lab):\t\t\t# 计算当前l*a*b*颜色值与图像平均值之间的距离\t\t\td &#x3D; dist.euclidean(row[0], mean)\t\t\t# 如果当前的距离小于最小的距离，则进行变量更新\t\t\tif d &lt; minDist[0]:\t\t\t\tminDist &#x3D; (d, i)\t\t# 返回最小距离对应的颜色值\t\treturn self.colorNames[minDist[1]]"},{"title":"使用预训练模型进行目标识别","url":"/qqsnote/2023/11/14/OpenCV-DeepLearning/","content":"安装TensorFlow Object Detection API参考PaddleX准备anaconda和cuda\n参考安装Tensorflow2conda create -n tensorflow python&#x3D;3.10conda activate tensorflowpip install tensorflow pip自动安装最新release版本 2.0之后不再区分cpu和gpu版本\n测试安装，在python中引用tensorflow， 对一个随机张量的求和python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot;# 结果形如tf.Tensor(-1082.7711, shape&#x3D;(), dtype&#x3D;float32)install the TensorFlow Object Detection API：下载模型库 新建一个Tensorflow目录并将模型库clone/解压到目录下TensorFlow/└─ models/   ├─ community/   ├─ official/   ├─ orbit/   ├─ research/   └── …根据Readme的提示安装official library# 将model路径添加到PYTHONPATH环境变量set PYTHONPATH&#x3D;%PYTHONPATH%;C:\\Users\\qqqst\\Documents\\TensorFlow\\models# 安装requirementspip3 install --user -r models&#x2F;official&#x2F;requirements.txt 下载protobuf添加到环境变量path,对于windows下载 protoc---win64.zip并解压，注意protobuf--.zip是source code 添加路径如D:\\Software\\protoc-25.1-win64\\bin到path\n使用protoc编译模型的python版本(与.proto一一对应的.py文件)# cmdline in TensorFlow&#x2F;models&#x2F;researchfor &#x2F;f %i in (&#39;dir &#x2F;b object_detection\\protos\\*.proto&#39;) do protoc object_detection\\protos\\%i --python_out&#x3D;.\ninstall pycocotools (依赖vc++ 2015)pip install cythonpip install git+https:&#x2F;&#x2F;github.com&#x2F;philferriere&#x2F;cocoapi.git#subdirectory&#x3D;PythonAPI\n看到Object Detection for TensorFlow 2.0的setup script\nInstall the Object Detection API# From within TensorFlow&#x2F;models&#x2F;research&#x2F;cp object_detection\\packages\\tf2\\setup.py .python -m pip install .调用test脚本以测试安装# From within TensorFlow&#x2F;models&#x2F;research&#x2F;python object_detection&#x2F;builders&#x2F;model_builder_tf2_test.py&lt;/del&gt;\n","categories":["图像处理"],"tags":["AI","OpenCV"]},{"title":"OpenCV-Polygon","url":"/qqsnote/2023/05/22/OpenCV-Polygon/","content":"approxPolyDP 多边形逼近参数1是源图像的某个轮廓；参数2(epsilon)是一个距离值，表示多边形的轮廓接近实际轮廓的程度，值越小，越精确；参数3表示是否闭合。\ncontourArea 区域面积double contourArea(InputArray contour, bool oriented = false);\ncontour，输入的二维点集（轮廓顶点），可以是 vector 或 Mat 类型。oriented，面向区域标识符。有默认值 false。若为 true，该函数返回一个带符号的面积值，正负取决于轮廓的方向（顺时针还是逆时针）。若为 false，表示以绝对值返回。\narcLength 曲线长度arcLength 函数用于计算封闭轮廓的周长或曲线的长度。\ndouble arcLength(InputArray curve, bool closed);\ncurve，输入的二维点集（轮廓顶点），可以是 vector 或 Mat 类型。closed，用于指示曲线是否封闭。\n"},{"title":"OpenCV-Video","url":"/qqsnote/2023/10/26/OpenCV-Video/","content":""},{"title":"OpenCV","url":"/qqsnote/2022/06/27/OpenCV/","content":"\nOpenCV是计算机视觉领域应用最广泛的开源工具包，基于C/C++，支持Linux/Windows/MacOS/Android/iOS，并提供了Python，Matlab和Java等语言的接口\n\n\ncore：核心模块，主要包含了OpenCV中最基本的结构（矩阵，点线和形状等），以及相关的基础运算/操作。\nimgproc：图像处理模块，包含和图像相关的基础功能（滤波，梯度，改变大小等），以及一些衍生的高级功能（图像分割，直方图，形态分析和边缘/直线提取等）。\nhighgui：提供了用户界面和文件读取的基本函数，比如图像显示窗口的生成和控制，图像/视频文件的IO等。如果不考虑视频应用，以上三个就是最核心和常用的模块了。针对视频和一些特别的视觉应用，OpenCV也提供了强劲的支持：\nvideo：用于视频分析的常用功能，比如光流法（Optical Flow）和目标跟踪等。\ncalib3d：三维重建，立体视觉和相机标定等的相关功能。\nfeatures2d：二维特征相关的功能，主要是一些不受专利保护的，商业友好的特征点检测和匹配等功能，比如ORB特征。\nobject：目标检测模块，包含级联分类和Latent SVM\nml：机器学习算法模块，包含一些视觉中最常用的传统机器学习算法。\nflann：最近邻算法库，Fast Library for Approximate\nNearest Neighbors，用于在多维空间进行聚类和检索，经常和关键点匹配搭配使用。\ngpu：包含了一些gpu加速的接口，底层的加速是CUDA实现。\nphoto：计算摄像学（Computational Photography）相关的接口，当然这只是个名字，其实只有图像修复和降噪而已。\nstitching：图像拼接模块，有了它可以自己生成全景照片。\nnonfree：受到专利保护的一些算法，其实就是SIFT和SURF。\ncontrib：一些实验性质的算法，考虑在未来版本中加入的。\nlegacy：字面是遗产，意思就是废弃的一些接口，保留是考虑到向下兼容。\nocl：利用OpenCL并行加速的一些接口。\nsuperres：超分辨率模块，其实就是BTV-L1（Biliteral Total Variation – L1 regularization）算法\nviz：基础的3D渲染模块，其实底层就是著名的3D工具包VTK（Visualization Toolkit）。\n\n安装pip install -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple opencv-python\n读取显示图像img = cv2.imread(&#x27;singlemushroom.jpg&#x27;, cv2.IMREAD_UNCHANGED)cv2.imshow(&quot;origin image&quot;, img)img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)cv2.imshow(&quot;gray image&quot;, img_gray)cv2.waitKey(0)cv2.destroyAllWindows()# 写入图像cv2.imwrite(&quot;originImage.jpg&quot;, img)\ncv.imread的枚举参数\n\ncv2.IMREAD_COLOR = 1     ：读入一副彩色图像。透明度会被忽略，默认参数\ncv2.IMREAD_GRAYSCALE = 0 ：以灰度模式读入图像\ncv2.IMREAD_UNCHANGED = -1：保留读取图片原有的颜色通道\n\n缩放result = cv2.resize(src, (200,100))\n像素操作#矩阵运算#拷贝区域ball=img[280:340,330:390]img[273:333,100:160]=ball\n通道#通道顺序与R-G-B顺序相反b,g,r=cv2.split(img)#b=img[:,:,0]img=cv2.merge(b,g,r)\n阈值#读取图片src = cv2.imread(&#x27;miao.jpg&#x27;)#灰度图像处理GrayImage = cv2.cvtColor(src,cv2.COLOR_BGR2GRAY)#二进制阈值化处理r, b = cv2.threshold(GrayImage, 127, 255, cv2.THRESH_BINARY)#THRESH_BINARY 超过阈值像素设为最大值 否则为0#THRESH_BINARY_INV 超过阈值像素设为0 否则为最大值#THRESH_TRUNC 大于阈值部分设为最大值 否则不变#THRESH_TOZERO 大于阈值部分不变 否则设为0#THRESH_TOZERO_INV 大于阈值部分设为0 否则不变print(r)#显示图像cv2.imshow(&quot;src&quot;, src)cv2.imshow(&quot;result&quot;, b)\n自适应阈值 adapativeThreshold\nadaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst])\n\nmaxValue 满足条件的最大值\nadaptiveMethod 自适应方法 ADAPTIVE_THRESH_MEAN_C ADAPTIVE_THRESH_GAUSSIAN_CADAPTIVE_THRESH_MEAN_C的计算方法是计算出领域的平均值再减去 C；ADAPTIVE_THRESH_GAUSSIAN_C的计算方法是计算出领域的高斯均值再减去C\nthresholdType 阈值类型 THRESH_BINARY 或者 THRESH_BINARY_INV\nblockSize 邻域大小 如 3，5，7\nC 阈值偏移量\n\nthresh1 = cv2.adaptiveThreshold(gray_image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)thresh2 = cv2.adaptiveThreshold(gray_image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 31, 3)thresh3 = cv2.adaptiveThreshold(gray_image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)thresh4 = cv2.adaptiveThreshold(gray_image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 31, 3)\n卷积和滤波设想3*3矩阵 对中心位置像素值做卷积运算 其作用即一种平滑滤波\n#高斯滤波gaussianBlur = cv2.GaussianBlur(greyImg, (3,3), 0)\n膨胀和腐蚀，开运算和闭运算 顶帽和底帽#腐蚀kernel=np.ones((5,5),np.uint8)erosion=cv2.erode(img,kernel,iterations=1) #iterations 为重复次数#膨胀kernel=np.ones((5,5),np.uint8)dilate=cv2.dilate(img,kernel,iterations=1)\n开为先腐蚀再膨胀 闭为先膨胀后腐蚀\n顶帽：原图像 - 开运算结果  顶帽得到的是开运算中断开的细节底帽：原图像 - 闭运算结果  底帽得到的是闭运算中补上的细节\n边缘检测 canny\n去噪 噪声会影响该算法进行边缘检测的准确性\n计算每个点的梯度大小和方向 例如用一对Sobel算子作为卷积核对图像滤波\n抑制非边缘点 边缘点应该满足：±梯度方向上的局部最大值，因此将不满足条件的点归零\n用两个阈值条件筛选剩余的边缘‘条纹’\n\nedges = cv.Canny(blur, 50, 150, apertureSize)\nFindContour一种边缘提取方法\ncontours,_=cv2.findContours(img,RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)\n\n参数1 二值图像\n参数2 轮廓返回模式（RETR_EXTERNAL: 表示只检测最外层轮廓；RETR_LIST: 提取所有轮廓，并放置在list中，检测的轮廓不建立等级关系； RETR_TREE: 提取所有轮廓并重新建立网状轮廓结构 ）\n参数3 遍历发现方法（CHAIN_APPROX_NONE：获取每个轮廓的每个像素，相邻的两个点的像素位置差不超过1；CHAIN_APPROX_SIMPLE：压缩水平方向，垂直方向，对角线方向的元素，值保留该方向的重点坐标，如果一个矩形轮廓只需4个点来保存轮廓信息 ）用findcontour去孔洞\n\ndrawContourscv2.drawContours()\ncv2.drawContours(image, contours, contourIdx, color, thickness=None, lineType=None, hierarchy=None, maxLevel=None, offset=None)\n\nimage 原图像\ncontours 轮廓集合 例如findContours获得的集合\ncontourIdx 指定绘制轮廓list中的哪条轮廓，如果是-1，则绘制其中的所有轮廓。\ncolor 颜色\nthickness 轮廓线的宽度，如果是-1（cv2.FILLED），则为填充模式。\n\n外接矩形x, y, w, h = cv2.boundingRect(contour)img = cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 1)cv2.imshow(img)\n区域质心位置mu = cv2.moments(contour, False)mc = [mu[&#x27;m10&#x27;]/mu[&#x27;m00&#x27;], mu[&#x27;m01&#x27;]/mu[&#x27;m00&#x27;]]\n联通区域计数CSDN Blog:连通区域分析算法\nfloodFill填充孔洞掩膜或者叫蒙版 将感兴趣区域（Region of Interest, ROI）提取出来 掩盖其他区域.\nh, w = gaussianBlur.shapemask = np.zeros((h, w), np.uint8)cv2.fillPoly(mask, [capContour], (255, 255, 255))roi = cv2.bitwise_and(GrayImage, GrayImage, mask=mask)cv2.imshow(&#x27;roi&#x27;, roi)\n直方图反映像素的值在图像中的分布，值范围分段，进行统计，值可以是亮度，或任意色彩通道的分量直方图可以作为阈值分割的参数选择依据\nimport cv2  import numpy as npimport matplotlib.pyplot as plt#读取图像src = cv2.imread(&#x27;orign.bmp&#x27;)#绘制直方图plt.hist(src.ravel(), bins=256, density=1, facecolor=&#x27;green&#x27;, alpha=0.75)plt.xlabel(&quot;x&quot;)plt.ylabel(&quot;y&quot;)plt.show()#显示原始图像cv2.imshow(&quot;src&quot;, src)cv2.waitKey(0)cv2.destroyAllWindows()\n\nsrc.ravel()将二维图像数据展成一维\nBINS 分若干组\nDENSITY 密度\nFACECOLOR 直方图颜色\nALPHA\n\nmatchtemplateopencv.jsOpenCV directly in the browser (webassembly + webworker)\n","categories":["图像处理"],"tags":["OpenCV"]},{"title":"开源协议","url":"/qqsnote/2022/10/18/OpenSourceLicense/","content":"宽松许可\n\nMIT\nApache\nBSD鼓励开源和代码共享，允许修改、再发布，尊重原作者权利，在发布或代码引用处声明BSD协议\n\n弱化的著作权 \n\nLGPL\n\n著作权\n\nGPL\n\n"},{"title":"香橙派Zero3","url":"/qqsnote/2025/11/11/OrangePi-Zero3/","content":"25年10月入手OrangePi Zero3\nCortex a53 1.4GHz四核ARM处理器 1G内存\nmission 1: 烧录嵌入式Linux系统balenaEtcher Portable(Portable是绿色免安装)\nOrangepizero3_1.0.8_ubuntu_jammy_desktop_xfce_linux5.4.125\n一个完整的XFCE桌面环境，在启动后，基础占用通常在 350MB - 500MB 之间。这包括了X窗口服务器、窗口管理器、面板、文件管理器等所有基础组件。而远程图形界面的vnc服务也会占用一部分资源，因此随后换用server镜像\nmission 2：交叉编译(CROSS_COMPILE)环境编译是将源码转换成机器执行的二级制文件，编译需要编译器，且编译环境有一定配置要求(比如内存)，因此嵌入式linux的编译需求通常需要在更高级的平台上完成，被称为cross compile(QQs按： cross翻译成交叉真的没问题吗)\nmission 3：联网 录音、播音外设连接命令行连接wifi：\n# 查看网卡名称iwconfig# 创建netplan配置文件 sudo nano /etc/netplan/01-wifi-config.yaml# 写入配置    network:      version: 2      renderer: networkd      wifis:        wlan0:  # &lt;-- 如果你的网卡名不是wlan0，请在这里修改          dhcp4: true          optional: true          access-points:            &quot;your_wifi_ssid&quot;:  # &lt;-- 在这里填入你的Wi-Fi名称              password: &quot;your_wifi_password&quot; # &lt;-- 在这里填入你的Wi-Fi密码# 应用netplansudo netplan apply\n连接usb设备：\n# 查看设备idlsusb # 输出如 Bus 001 Device 003: ID 1d6b:0002 Linux Foundation 2.0 root hub # 其中1d6b是Vendo ID(vid) 0002是Product ID(pid)# 查询linux设备信息 http://www.linux-usb.org/usb.ids\nmission 4：调用LLM apimission 5：语音唤醒mission 6: 指令训练\n退下 停 休息吧 闭嘴\n调教指令\n\nmission 7：音色识别 避免其他设备混淆","categories":["物联网"],"tags":["香橙派"]},{"title":"package.json","url":"/qqsnote/2019/07/18/PackageJSON/","content":"authordescriptionlicensekeywordsdependencies 和 devDependencies, peerDependencies, bundledDependencies, optionalDependencies\nnpm install 命令 不加 —save 不会修改package.json\nnpm install 命令 —save参数将package记入dependencies，—save-dev参数将package记入devdependencies\n开发工具如glup，angular脚手架自动安装的jasmine、karma、tslint、chai等，以致于@angular/cli自身，@angular/compiler-cli等工具，以及用于编译器做类型识别的各种@type/XXX 应该放devdependencies\n运行环境如Express,前端框架@angular/core以及可选包forms、animation等，弥补浏览器内核、版本等差异的腻子如core.js，应为dependencies 参考Angular Doc: npm packages\n封装node.js api第三方工具如操作xml、mail、excel等，是业务不可或缺的，应属dependencies\n重新编译electron的如node-ffi私以为其实并不会进入构建结果，应为dependencies\n当有人准备在自己的程序中下载使用你的模块时，估计他们不想下载构建你使用的外部测试或者文档框架，为此宜将这些依赖项放在devDependencies里 npm doc\n\n\n\npeerDependencies: peer意为同等地位的人，同龄人。peerDependencies将该模块的树形的依赖关系摊平到宿主的依赖环境中\nbundledDependencies: 将依赖的包与当前模块绑定在一起， 如发布一模块做如下配置，npm pack该模块将获得包含”renderized”和”super-streams”的awesome-web-framework-1.0.0.tgz，package version另需在dependencies中指定&#123;  &quot;name&quot;: &quot;awesome-web-framework&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;bundledDependencies&quot;: [    &quot;renderized&quot;, &quot;super-streams&quot;  ]&#125;\noptionalDependencies 可选的依赖，有的依赖模块依赖于特定的运行环境，因此optionalDependencies的依赖项在安装失败的情况下不会影响整个安装结果\n语义版本控制(Semantic Versioning)\nMAJOR version when you make incompatible API changes,\nMINOR version when you add functionality in a backwards-compatible manner, and\nPATCH version when you make backwards-compatible bug fixes.\n\nUse the tilde-character (~) to prefix the version of moment in your dependencies and allow npm to update it to any new PATCH release(补丁).\nUse the caret-character (^) to prefix the version of moment in your dependencies and allow npm to update it to any new MINOR release(小版本).\nGit做版本管理及CHANGELOG\n本地依赖&quot;qqsmodule&quot;: &quot;file:..&#x2F;CustomModules&#x2F;qqsmodule&quot;\npackage-lockNode Docs: package-lock\n\n记录整个依赖树的具体版本， 即包括了依赖的依赖，\n须提交package-lock 在npm install时安装指定的版本\n每次npm update时依据package.json中的升级版本设置修改package-lock.json\n\nversion lensVS Code extension 鼠标悬停在dependency的项上，可查看最新版本和依赖项目链接\n关于版本号和构建编号\nThe standard build numbering convention makes use of a fourth numerical indicator which is appendedto the release number, where the fourth indicator is the build number.\n\n\nFor verification builds, the build number starts with a “1”, and increments with each successivebuild. For each successive release, the build indicator starts again with zero’s.\nFor development builds, the build number starts with “20001” and increments with eachsuccessive build. For each successive release, the build indicator starts again with zero’s.\n\nscripts","categories":["前端技术"],"tags":["Node.js"]},{"title":"PaddleX","url":"/qqsnote/2021/12/24/PaddleX/","content":"百度旗下深度学习平台介于网络问题 使用源码编译 参考PaddlePaddle在Windows下使用源码编译\ncmake .. -G &quot;Visual Studio 16 2019&quot; -A x64 -DPY_VERSION&#x3D;3.8 -DPYTHON_INCLUDE_DIR&#x3D;C:\\\\Users\\\\qqqst\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\include -DPYTHON_LIBRARY&#x3D;C:\\\\Users\\\\qqqst\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\Lib -DPYTHON_EXECUTABLE&#x3D;C:\\\\Users\\\\qqqst\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python38\\\\python.exe -DWITH_FLUID_ONLY&#x3D;ON -DWITH_GPU&#x3D;ON -DWITH_TESTING&#x3D;OFF -DCMAKE_BUILD_TYPE&#x3D;Release -DCUDA_TOOLKIT_ROOT_DIR&#x3D;&quot;C:\\\\Program Files\\\\NVIDIA GPU Computing Toolkit\\\\CUDA\\\\v11.3&quot;\n若使用其他MSBuild编译过 产生./build/CMakeFiles以及CMakeCache.txt 需要先删除\n使用Release x64编译\nError C3848\nFix protobuf compile error\nsmall_vector issue: length_error is not a member of std\npull request: betterpig/Paddle ‘vs2019’Release x64， 先编译third_party,再编译solution 得到约50m的 build\\python\\dist*.whlpip install -U xxx.whl\nPaddleX GUI安装正确姿势 （2022.1.1 paddle v2.2）\n\nnvidia cuda 11.2\nnvdia cudnn 8.2.1 （for cuda v11.2 v11.3）解压覆盖 cuda 安装目录相应文件夹\npip install numpy protobuf  wheel\npip 警告版本更新 则升级pip\npython -m pip install paddlepaddle-gpu==2.2.1.post112 -f https://www.paddlepaddle.org.cn/whl/windows/mkl/avx/stable.html\n下载解压 GUI client \n\nAnaconda大概是python工具链版本控制\nwindows start -&gt; Anaconda3 -&gt; Anaconda Prompt创建激活conda环境# 创建名为my_paddlex的环境，指定Python版本为3.8conda create -n my_paddlex python&#x3D;3.8# 进入my_paddlex环境conda activate my_paddlex\nLabelMeconda activate my_paddlexconda install pyqtpip install labelme# 启动labelme\nToDo\n主要的学习算法\n评估报告及指标的涵义 **\n模型预测实践\n结果详细参数导出 *\n\n圆形标记 -&gt; 目标范围集合R = (U0,U1…Un)\n\n抠图\n导出目标滤波\n计算每个范围内的全物理量\n动态化统计阈值issues\nCannot allocate ???kb  memory on GPU 0,  memory has been allocated and available memory is only 0.000000B.\n\n\n\n","tags":["AI"]},{"title":"Sexual Photography With Soft Light","url":"/qqsnote/2018/08/30/Photography-Soft-Light/","content":"http://viviennemok.foliodrop.com/categories/portfolio\n","categories":["美学"],"tags":["摄影"]},{"title":"PyQt","url":"/qqsnote/2022/08/24/PyQt/","content":"PyQt 是 Qt 的Python版本，Qt是基于C++的GUI，在Python的UI组件库中，PyQt功能强大，提供QT Designer设计UI。PyQt 可与 C++ Qt无缝整合，另有QtWebEngine结合web前端实现Electron的功能。\n题外话：Tkinter 是Python解决UI的原生库，优点在于没有其他依赖。但内容基础功能简单 比其他UI库都有不及\nPyQt5类分为很多模块\n\nQtCore 包含了核心的非GUI的功能。主要和时间、文件与文件夹、各种数据、流、URLs、mime类文件、进程与线程一起使用。QtGui 包含了窗口系统、事件处理、2D图像、基本绘画、字体和文字类。QtWidgets类包含了一系列创建桌面应用的UI元素。 QtMultimedia包含了处理多媒体的内容和调用摄像头API的类。 QtNetwork包含了网络编程的类，这些工具能让TCP/IP和UDP开发变得更加方便和可靠。QtWebSockets包含了WebSocket协议的类。 QtWebKit包含了一个基WebKit2的web浏览器。 \n\n安装pip install pyqt5pip install pyqt5-tools\n使用国内pip源pip install -i https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;pypi&#x2F;web&#x2F;simple pyqt5添加pyqt5-tools路径到环境变量Path\n配置PyCharm外部工具PyCharm -&gt; 文件 -&gt; 设置 -&gt; 工具 -&gt; 外部工具\n填入QT designer路径\n另添加 Pyuic 用于将ui文件转为py文件 \n须填入参数$FileName$ -o $FileNameWithoutExtension$.py\n类似的 可添加PyRCC\nPyQt Hello Worldimport sysfrom PyQt5.QtWidgets import QApplication, QWidgetif __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app &#x3D; QApplication(sys.argv)    w &#x3D; QWidget()    w.resize(250, 150)    w.setFixedSize(250, 150) # 固定大小    w.move(300, 300)    w.setWindowTitle(&#39;HelloWorld!&#39;)    w.show()    sys.exit(app.exec_())\nQT designer完成如上配置 可在PyCharm的外部工具打开 QT designer，使用QT designer生成UI文件\n从.ui文件到.py文件pyuic demo.ui -o demo.py\n生成的py文件是UI的类定义文件class Ui_MainWindow(object):    def setupUi(self, MainWindow):        MainWindow.setObjectName(&quot;MainWindow&quot;)        MainWindow.resize(800, 600)        self.centralWidget &#x3D; QtWidgets.QWidget(MainWindow)        self.centralWidget.setObjectName(&quot;centralWidget&quot;)        self.btn_import &#x3D; QtWidgets.QToolButton(self.centralWidget)        self.btn_import.setGeometry(QtCore, QRect(610, 20, 71, 22))        self.btn_import.setObjectName(&quot;btn_import&quot;)        self.btn_import.clicked.connect(self.on_clicked_btn_import)    def retranslateUi(self, MainWindow):        _translate &#x3D; QtCore.QCoreApplication.translate        MainWindow.setWindowTitle(_translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;))        self.btn_import.setText(_translate(&quot;MainWindow&quot;, &quot;import&quot;))        def on_clicked_btn_import(self):        print(&quot;btn_import clicked&quot;)        .....运行该UI需要在程序入口（__main__）实例化import sysfrom PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog, QMessageBoxfrom ui.mainWindow import Ui_MainWindow # 引入UI的类定义class Startup(QMainWindow, Ui_MainWindow):    def __init__(self):        super(Startup, self).__init__()        self.setupUi(self)    def importImg(self):        fname &#x3D; QFileDialog.getOpenFileName(self, &#39;import Image&#39;, &#39;.&#x2F;&#39;)        if fname[0]:            QMessageBox.information(self, &#39;import success&#39;, fname[0], QMessageBox.Yes)        print(&quot;import img is here&quot;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    app &#x3D; QApplication(sys.argv)    startup &#x3D; Startup()    startup.show()    sys.exit(app.exec_())可见这里的Startup类即 Ui_MainWindow 实例化参数object 两个类是相互引用的；Startup类函数即主窗体的槽函数\n事件、信号和槽函数在控件层面 事件如点击按钮（clicked）选择菜单（triggered），事件可以直接connect到响应函数（槽函数）btn &#x3D; QPushButton(&#39;test&#39;, self)btn.resize(btn.sizeHint())btn.move(50, 50)btn.clicked.connect(self.showDlg)# MenuBar -&gt; Menu -&gt; Action -&gt; Slotself.menubar &#x3D; QtWidgets.QMenuBar(MainWindow)self.menubar.setGeometry(QtCore.QRect(0, 0, 842, 26))self.menubar.setObjectName(&quot;menubar&quot;)self.menu &#x3D; QtWidgets.QMenu(self.menubar)self.menu.setObjectName(&quot;menu&quot;)MainWindow.setMenuBar(self.menubar)self.actionimport &#x3D; QtWidgets.QAction(MainWindow)self.actionimport.setObjectName(&quot;actionimport&quot;)self.menu.addAction(self.actionimport)self.menubar.addAction(self.menu.menuAction())self.retranslateUi(MainWindow)self.actionimport.triggered.connect(MainWindow.importImg)QtCore.QMetaObject.connectSlotsByName(MainWindow)或者，不同事件发送某信号，而某个模块监听到该信号而触发响应# 创建一个信号closeApp。当触发鼠标点击事件时信号会被发射。信号连接到QMainWindow的close()方法。class Communicate(QObject):       closeApp &#x3D; pyqtSignal()# 信号使用了pyqtSignal()方法创建，并且成为外部类Communicate类的属性。self.c &#x3D; Communicate()self.c.closeApp.connect(self.close)# 把自定义的closeApp信号连接到QMainWindow的close()槽上。def mousePressEvent(self, event):         self.c.closeApp.emit()# 当我们在窗口上点击一下鼠标，closeApp信号会被发射。应用中断。\n页面间的信号子页面发射信号 槽函数在父页面子页面：class Child_Widget(QWidget):    status_signal &#x3D; pyqtSignal(str)    def __init__(self):        super(Child_Widget, self).__init__()    def updateStatus(self):        self.status_signal.emit(&#39;update&#39;)父页面：class Parent_Widget(QWidget):    ...    def child_init(self):        self.child_widget &#x3D; Child_Widget()        self.child_widget.status_signal.connect(self.update_child_status)        self.child_widget.show()    def update_child_status(self)：        self.line.setText(&#39;status updated&#39;)\nui控件Basic Widget输入框QLineEdit按钮QPushButton整数调整器QPinBox…\n对话框dialog classfrom PyQt5.QtWidgets import QDialogclass Ui_ModeEditor(QDialog):    def __init__(self, parent&#x3D;None):        super().__init__(parent)        self.__mainWindow &#x3D; parent        .....        def setupUi(self):        self.buttonsLayout &#x3D; QtWidgets.QHBoxLayout(self)        self.buttonsLayout.setObjectName(&quot;buttonsLayout&quot;)        btn_save &#x3D; QtWidgets.QToolButton(self)        btn_save.setObjectName(&quot;btn_save&quot;)        btn_save.setText(&quot;保存&quot;)        btn_save.clicked.connect(self.accept)        btn_cancel &#x3D; QtWidgets.QToolButton(self)        btn_cancel.setObjectName(&quot;btn_cancel&quot;)        btn_cancel.setText(&quot;取消&quot;)        btn_cancel.clicked.connect(self.reject)        self.buttonsLayout.addWidget(btn_save)        self.buttonsLayout.addWidget(btn_cancel)use dialogself.dialog &#x3D; Ui_ModeEditor(self)self.modeEditor.setWindowTitle(&quot;编辑模式&quot;)retVal &#x3D; self.dialog.exec()if retVal &#x3D;&#x3D; QDialog.Accepted:    # return acceptedelse:    # close without accept\n封装pyinstaller vs Nuitka\n\nNuitka(音妞卡)是将python程序转换成C语言的可执行elf文件。这样在运行时就可以享受到C语言处理过程中的优化，提高速度。\n\npip install -U nuitka\n编译依赖Python和C compiler，c compiler需支持C11或C++03 这意味着需安装MinGW64 C11编译器 基于gcc11.2或更高版本，或visual studio\npip install pyinstallerpyinstaller -F -w main.py -n &quot;测量工具&quot;","tags":["Python"]},{"title":"Python文件加密","url":"/qqsnote/2019/07/19/PythonAndEncryption/","content":"AES加密算法 CSC模式：通过密钥和salt（起扰乱作用）按固定算法（md5）产生key和iv。然后用key和iv（初始向量，加密第一块明文）加密（明文）和解密（密文）。\n","categories":["算法"],"tags":["Python","加密"]},{"title":"Python面向对象","url":"/qqsnote/2022/10/18/PythonOOP/","content":"Definationclass Employee:    &#39;员工基类&#39;    empCount &#x3D; 0    def __init__(self, name, salary):         self.name &#x3D; name         self.salary &#x3D; salary         Employee.empCount +&#x3D; 1    def displayCount(self):        print(&quot;%d&quot; % Employee.empCount)    def displayEmployee(self):        print (&quot;Name : &quot;, self.name,  &quot;, Salary: &quot;, self.salary)\n__init__：构造函数\nself 代表类的实例，self 在定义类的方法时是必须有的，print(self)可以看到类实例字样及内存地址\nPython内置类属性\n__dict__ : 类的属性字典，由类的数据属性组成\n__doc__ :类的文档字符串\n__name__: 类名\n__module__: 类定义所在的模块（类的全名是’__main__.className’，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod）\n__bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组）\n\n单下划线、双下划线、头尾双下划线说明：\n__foo__: 定义的是特殊方法，一般是系统定义名字 ，类似 __init__() 之类的。\n\n_foo: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 from module import *\n__foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。\nCSDN Blog: 继承和多态\n","tags":["Python"]},{"title":"Python爬虫","url":"/qqsnote/2020/01/10/PythonWebCrawler/","content":"\n爬虫(Web Crawler)\n郑重声明：本文仅限于编程学习，用于非法目的及造成侵权后果的行为，老子概不负责\nhttp请求私以为，爬虫程序就是以程序执行代替人工操作，在一定范围的网络资源中找自己要的东西。当人做这项枯燥的工作时，无非输入网址—打开网页—用肉眼识别—下载这样子，下面基本上就是用python模拟这个过程。import requestsimport reresponse &#x3D; requests.get(&#39;https:&#x2F;&#x2F;qqstone.github.io&#x2F;qqsnote&#x2F;2019&#x2F;10&#x2F;28&#x2F;MySQL&#x2F;&#39;)print(response.text)if response.text.find(&#39;主键&#39;):    print(&#39;find it！&#39;)    keyUnicode &#x3D; str(&#39;主键&#39;.encode(&#39;unicode_escape&#39;)).replace(&#39;\\\\\\\\&#39;,&#39;\\\\&#39;)[2:14]    print(&#39;\\S*&#39;+keyUnicode+&#39;\\S*&#39;)    matchObj &#x3D; re.findall(&#39;\\S*&#39;+keyUnicode+&#39;\\S*&#39;,response.text)    print(matchObj)\n反“反爬设置”有时请求一个网页时，发现无论通过Get或Post以及其他请求方式，都会出现403错误。这种现象多数是由于服务器拒绝了访问，因为这些网页为了防止恶意采集信息，所用的反爬虫设置。此时可以通过模拟浏览器的header信息来进行访问。import requestsimport reurl&#x3D;&#39;https:&#x2F;&#x2F;www.acfun.cn&#x2F;a&#x2F;ac12293064&#39;headers&#x3D;&#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;79.0.3945.117 Safari&#x2F;537.36&#39;&#125;response &#x3D; requests.get(url,headers&#x3D;headers)print(response.text)上述只是针对user agent检测的手段，通常网站管理员采取的反爬虫基本手段还有封锁IP，检测请求间隔，封锁cookie等，针对这些手段需要采取相应的措施如使用代理，使用sleep模拟点击控制间隔，禁用cookie等\n超时处理\n使用代理解析html树Scrapy框架依赖：pip install Twisted# windows平台用下面这个pip install Twisted[windows_platform]pip install Scrapy参考 Scrapy文档import scrapyimport reclass QuotesSpider1(scrapy.Spider):    name &#x3D; &quot;quotes1&quot;    keyword &#x3D; &quot;&quot;    pages &#x3D; 75    def start_requests(self):        url &#x3D; &#39;https:&#x2F;&#x2F;xxxxxxx.xxx.html&#39;        yield scrapy.Request(url&#x3D;url, callback&#x3D;self.parse)        for i in range(2, self.pages):            surl &#x3D; url.replace(&#39;.html&#39;, &#39;-&#39;+str(i)+&#39;.html&#39;)            yield scrapy.Request(url&#x3D;surl, callback&#x3D;self.parse_key_word)    def parse(self, response):        regexp &#x3D; r&#39;\\d&#123;2&#125;&#39;        video_list_tags &#x3D; response.css(&#39;h3::attr(title)&#39;)        for vt in video_list_tags:            #if vt.extract().find(self.keyword) &gt;&#x3D; 0:            match_array &#x3D; re.findall(regexp, vt.extract())            if len(match_array):                self.log(vt.extract())                filename &#x3D; &#39;output.log&#39;                with open(filename, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:                    f.write(vt.extract()+&#39;--&gt;&#39;+response.url+&quot;\\n&quot;)    def parse_key_word(self, response):        video_list_tags &#x3D; response.css(&#39;h3::attr(title)&#39;)        for vt in video_list_tags:            if vt.extract().find(self.keyword) &gt;&#x3D; 0:                self.log(vt.extract())                filename &#x3D; &#39;output.log&#39;                with open(filename, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as f:                    f.write(vt.extract() + &#39;--&gt;&#39; + response.url + &quot;\\n&quot;)执行scrapy实例scrapy crawl quotes1\n","tags":["Python"]},{"title":"Pytorch","url":"/qqsnote/2024/06/28/Pytorch/","content":"Facebook开发的开源深度学习框架\n"},{"title":"QML","url":"/qqsnote/2023/12/06/QML/","content":"Label Hyberlink Style设置RichText以使文本中的样式生效Label &#123;    textFormat: Text.RichText;    text: &quot;&lt;style&gt;a:link &#123; color: &quot; + Theme.highlightColor + &quot;; &#125;&lt;&#x2F;style&gt;&quot; +          &quot;&lt;a href&#x3D;https:&#x2F;&#x2F;together.jolla.com&#x2F;&#39;&gt;Jolla2Gether&lt;&#x2F;a&gt;&quot;;    &#125;&#125;\n"},{"title":"Qt","url":"/qqsnote/2024/03/01/Qt/","content":"应用及案例Qt是跨平台UI框架WPS Autodesk Maya 极品飞车是Qt开发的医疗设备软件选择Qt开发 缘于极致性能及可靠性\nslot vs signal\nconnect \nfunction\n\nQt creatorDelegate ModelListView &#123;      id: listview      Layout.fillWidth: true       height: 80      orientation: ListView.Horizontal      spacing: 15      displaced: Transition &#123;        NumberAnimation &#123;          properties: &quot;x,y&quot;          easing.type: Easing.OutQuad        &#125;      &#125;       model: DelegateModel &#123;        id: visualModel        model: selectedItems        delegate: DropArea &#123;          id: delegateRoot          width: tt.width          height: tt.height           onEntered: function (drag) &#123;            visualModel.items.move(drag.source.curIndex, tt.curIndex)          &#125;          property int visualIndex: DelegateModel.itemsIndex           DraggableIcon &#123;            id: tt            dragParent: listview            curIndex: delegateRoot.visualIndex            sourceImg: source            keyImg: key          &#125;        &#125;      &#125;    &#125; \n"},{"title":"数据结构-队列","url":"/qqsnote/2024/01/09/Queue/","content":"队列的特点是先进先出，以C#的Queue为例\nQueue&lt;string&gt; numbers &#x3D; new Queue&lt;string&gt;();&#x2F;&#x2F; 进numbers.Enqueue(&quot;one&quot;);numbers.Enqueue(&quot;two&quot;);numbers.Enqueue(&quot;three&quot;);numbers.Enqueue(&quot;four&quot;);numbers.Enqueue(&quot;five&quot;);&#x2F;&#x2F; 出Console.WriteLine(&quot;\\nDequeuing &#39;&#123;0&#125;&#39;&quot;, numbers.Dequeue()); &#x2F;&#x2F; Dequeuing &#39;one&#39;Console.WriteLine(&quot;\\nQueue Size &#39;&#123;0&#125;&#39;&quot;, numbers.)Console.WriteLine(&quot;\\nDequeuing &#39;&#123;0&#125;&#39;&quot;, numbers.Dequeue()); &#x2F;&#x2F; Dequeuing &#39;one&#39;\n队列不能直接操作任意指定位置元素 必要时转换为Array\n"},{"title":"QuickApp","url":"/qqsnote/2020/05/06/QuickApp/","content":""},{"title":"React Native Vision Camera","url":"/qqsnote/2024/10/14/RN-Camera/","content":"npm i react-native-vision-camera\ncamera 和 microphone 权限AndroidManifest.xml中声明该App需要camera 和 microphone 权限：&lt;uses-permission android:name&#x3D;&quot;android.permission.CAMERA&quot; &#x2F;&gt;&lt;!-- optionally, if you want to record audio: --&gt;&lt;uses-permission android:name&#x3D;&quot;android.permission.RECORD_AUDIO&quot; &#x2F;&gt;查询权限const cameraPermission &#x3D; Camera.getCameraPermissionStatus()const microphonePermission &#x3D; Camera.getMicrophonePermissionStatus()const showPermissionsPage &#x3D; cameraPermission !&#x3D;&#x3D; &#39;granted&#39; || microphonePermission &#x3D;&#x3D;&#x3D; &#39;not-determined&#39;&#x2F;&#x2F; 未授权则跳转到 PermissionsPageprops.navigation.navigate(showPermissionsPage?&#39;PermissionsPage&#39;:&#39;CameraPage&#39;)getXXXPermissionStatus的结果:\n\ngranted 授权使用\nnot-determined 尚未申请\ndenied 拒绝(可以再次申请)\nrestricted 禁用\n\nPermissionsPage 请求权限const [cameraPermissionStatus, setCameraPermissionStatus] &#x3D; useState(&#39;not-determined&#39;)const [microphonePermissionStatus, setMicrophonePermissionStatus] &#x3D; useState(&#39;not-determined&#39;)useEffect(()&#x3D;&gt;&#123;    if(cameraPermissionStatus &#x3D;&#x3D;&#x3D; &#39;granted&#39; &amp;&amp; microphonePermissionStatus &#x3D;&#x3D;&#x3D; &#39;granted&#39;)&#123;        navigation.replace(&#39;CameraPage&#39;)    &#125;&#125;, [cameraPermissionStatus, microphonePermissionStatus])const requestPermissions &#x3D; useCallback(async ()&#x3D;&gt;&#123;    const cameraPermission &#x3D; await Camera.requestCameraPermission()    if(cameraPermission &#x3D;&#x3D;&#x3D; &#39;denied&#39;) await Linking.openSettings() &#x2F;&#x2F; 设备设置页    setCameraPermissionStatus(cameraPermission)    &#x2F;&#x2F; ...&#125;)return (&lt;Text onPress&#x3D;&#123;requestPermissions&#125;&gt;grant&lt;&#x2F;Text&gt;)\nCamera视图const device &#x3D; useCameraDevice(&#39;back&#39;)const &#123; hasPermission &#125; &#x3D; useCameraPermission()if (!hasPermission) return &lt;PermissionsPage &#x2F;&gt;if (device &#x3D;&#x3D; null) return &lt;NoCameraDeviceError &#x2F;&gt;return (&lt;Camera    style&#x3D;&#123;StyleSheet.absoluteFill&#125;    device&#x3D;&#123;device&#125;    isActive&#x3D;&#123;true&#125;&#x2F;&gt;)\n设备devicesconst devices &#x3D; Camera.getAvailableCameraDevices()const device &#x3D; getCameraDevice(devices, &#39;back&#39;)其他针对多摄像头和外部摄像头的选择\nisActive可用于暂停会话(pause the session: isActive={false}) 相比于unmount可以更快速再次调用\n生命周期onInitialized — onStarted — onPreviewStarted — onPreviewStopped — onStopped、\n格式const format &#x3D; getCameraFormat(device, [  &#123; videoResolution: &#39;max&#39; &#125;,  &#123; photoResolution: &#39;max&#39; &#125;])other format settings\nPreview预览const camera &#x3D; useRef&lt;Camera&gt;(null)...return(    &lt;Camera &#123;...props&#125;     ref&#x3D;&#123;camera&#125;    photo&#x3D;&#123;true&#125; &#123;&#x2F;* enable take photo *&#x2F;&#125;    preview&#x3D;&#123;isPausePreview&#125;    onPreviewStarted&#x3D;&#123;() &#x3D;&gt; console.log(&#39;Preview started!&#39;)&#125;    onPreviewStopped&#x3D;&#123;() &#x3D;&gt; console.log(&#39;Preview stopped!&#39;)&#125;    androidPreviewViewType&#x3D;&quot;texture-view&quot; &#x2F;&gt;)拍照const file &#x3D; await camera.current.takePhoto()await CameraRoll.save(&#96;file:&#x2F;&#x2F;$&#123;file.path&#125;&#96;, &#123;  type: &#39;photo&#39;,&#125;) \n"},{"title":"RPC","url":"/qqsnote/2024/08/13/RPC/","content":"Remote Procedure Call 远程过程调用\n"},{"title":"RaspberryPi","url":"/qqsnote/2019/12/31/RaspberryPi/","content":"( Raspberry Pi Model B Plus Rev1.2 )\nsetup官方指引：Setting up your Raspberry Pi\n\n常见异常：HDMI无响应\n\n修改/boot/config.txthdmi_force_hotplug&#x3D;1config_hdmi_boost&#x3D;4hdmi_group&#x3D;2hdmi_mode&#x3D;9hdmi_drive&#x3D;2hdmi_ignore_edid&#x3D;0xa5000080disable_overscan&#x3D;1\n\n设置默认命令行启动sudo raspi-configBoot Options -&gt; Desktop / CLI -&gt; Console开启ssh server见 ssh笔记\nGPIOUSB摄像头Using a standard USB webcam实践发现，手上的UVC Camera一旦停止调用就会跳出(中断)搭建直播流服务\n4g上网实践时 电脑USB接口向树莓派供电 插上网卡就电压不足(Under-voltage detected)lsusb命令识别出” ID 05c6:6000 Qualcomm,Inc.Siemens SG75 “安装ppp包\n内网穿透ipv6\n\n","categories":["物联网"],"tags":["树莓派"]},{"title":"React组件交互","url":"/qqsnote/2021/01/28/React-ComponentCommunicate/","content":"受控组件和不受控组件以封装Html表单控件的组件为例，假设ControlledComponent渲染一个input控件，为使input的value可以通过ControlledComponent进行控制，会在ControlledComponent的state为input的value创建一个属性，比如this.state.text，这个属性会绑定到input上，同时input修改时会触发onChange事件，于是在onChange的响应方法中setState更新class ControlledComponent extends React.Component&#123;  constructor (props) &#123;    super(props);    this.state &#x3D; &#123;      text: &quot;add your comments&quot;    &#125;  &#125;  onChange (e) &#123;    console.log(e.target.value);    this.setState(&#123;      text: e.target.value    &#125;)  &#125;  render () &#123;    return &lt;input name&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.text&#125; onChange&#x3D;&#123;(e) &#x3D;&gt; this.onChange(e)&#125; &#x2F;&gt;  &#125;&#125;\n\n在HTML的表单元素中，它们通常自己维护一套state，并随着用户的输入自己进行UI上的更新，这种行为是不被我们程序所管控的。而如果将React里的state属性和表单元素的值建立依赖关系，再通过onChange事件与setState()结合更新state属性，就能达到控制用户输入过程中表单发生的操作。被React以这种方式控制取值的表单输入元素就叫做受控组件。 掘金:受控和非受控组件真的那么难理解吗？\nprops略 见React 子组件传参 \ncontextContext 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。App.tsximport Tools  from &quot;.&#x2F;Tools&quot;const AppContext &#x3D; React.createContext(null);const [ var1, var2, var3] &#x3D;[ &quot;111&quot;, &quot;121&quot;, &quot;311&quot; ]const App &#x3D; () &#x3D;&gt; &#123;  return (    &lt;AppContext.Provider value&#x3D;&#123;      &#123;        var1,        var2,        var3      &#125;    &#125;&gt;      &lt;div className&#x3D;&quot;App&quot;&gt;        &lt;h1&gt;Hello CodeSandbox&lt;&#x2F;h1&gt;        &lt;h2&gt;Start editing to see some magic happen!&lt;&#x2F;h2&gt;      &lt;&#x2F;div&gt;      &lt;Tools &#x2F;&gt;    &lt;&#x2F;AppContext.Provider&gt;  );&#125;;export &#123; App, AppContext &#125;;Tools.tsx略ToolButton.tsximport &#123; AppContext &#125; from &quot;.&#x2F;App&quot;;export default () &#x3D;&gt; &#123;  return (    &lt;AppContext.Consumer&gt;      &#123;(&#123; var1, var2, var3 &#125;) &#x3D;&gt; (        &lt;&gt;          &lt;button &gt;&#123;var1&#125;&lt;&#x2F;button&gt;          &lt;button &gt;&#123;var2&#125;&lt;&#x2F;button&gt;          &lt;button &gt;&#123;var3&#125;&lt;&#x2F;button&gt;        &lt;&#x2F;&gt;      )&#125;    &lt;&#x2F;AppContext.Consumer&gt;  );&#125;;\nhook这里不只是组件交互的范畴，React hook是一套新的状态管理APIuseStateimport React, &#123; useState &#125; from &#39;react&#39;;function Example() &#123;  &#x2F;&#x2F; 声明一个叫 “count” 的 state 变量。  const [count, setCount] &#x3D; useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;  );&#125;useState使用闭包定义setXX函数（参考函数式编程看React Hooks），大致如下let _state;function useState(initialState) &#123;\t_state &#x3D; _state || initialState; &#x2F;&#x2F; 如果存在旧值则返回， 使得多次渲染后的依然能保持状态。  function setState(newState) &#123;    _state &#x3D; newState;    render();  &#x2F;&#x2F; 重新渲染，将会重新执行 Counter  &#125;  return [_state, setState];&#125;useEffectEffect是指获取数据，订阅，Dom操作等。useEffect跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途，只不过被合并成了一个 API，即组件在初始化完成、重新渲染、即将销毁时执行useEffect指定的逻辑。&#x2F;*** Accepts a function that contains imperative, possibly effectful code.** @param effect Imperative function that can return a cleanup function* @param deps If present, effect will only activate if the values in the list change.** @version 16.8.0* @see https:&#x2F;&#x2F;reactjs.org&#x2F;docs&#x2F;hooks-reference.html#useeffect*&#x2F;function useEffect(effect: EffectCallback, deps?: DependencyList): void;useEffect接受一个‘事件’列表作为可选参数关于订阅/取消订阅和清除函数常见于需要在组件初始化后（componentDidMount）设置订阅，在组件销毁前（componentWillUnmount）取消订阅以免内存泄漏，对应于使用Effect钩子的函数式React组件：useEffect(() &#x3D;&gt; &#123;    function handleStatusChange(status) &#123;      setIsOnline(status.isOnline);    &#125;    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    &#x2F;&#x2F; Specify how to clean up after this effect:    return () &#x3D;&gt; &#123;      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    &#125;;  &#125;);Effectf返回一个函数，该函数会作为Effect钩子的清除函数，React组件自动在销毁前执行清除函数useContext上面的ToolBtn经改写变为export default () &#x3D;&gt; &#123;  const &#123;var1, var2, var3&#125; &#x3D; useContext(AppContext);   return (        &lt;&gt;          &lt;button &gt;&#123;var1&#125;&lt;&#x2F;button&gt;          &lt;button &gt;&#123;var2&#125;&lt;&#x2F;button&gt;          &lt;button &gt;&#123;var3&#125;&lt;&#x2F;button&gt;        &lt;&#x2F;&gt;      )&#125;;useCallbackuseCallback是一个允许在多次渲染中缓存函数的hook\n\nuseState不能返回一个方法(读取类型为function的state，会自动执行返回结果)，当需要根据若干state的变化得到动态的函数时，使用useCallback, useCallback的定义形如useEffectuseEffect(()&#x3D;&gt;&#123;  &#x2F;&#x2F; do sth with refresh  renderView()&#125;,[refresh])renderView &#x3D; useCallback(()&#x3D;&gt;&#123;  &#x2F;&#x2F; do render data&#125;, [renderer, data])上述renderView方法随renderer, data的变化更新函数体实现，而renderView的执行时机只受refresh状态触发(而不需要在同时监听三个状态的副作用中判断是否需要执行renderView)\n但是调用useCallback方法时，函数体可能已因依赖项改变而改变\nuseMemo在组件重复渲染中缓存结果其他hooks\n关于函数式组件和Hooks使用Hooks代替class中的生命周期函数，是函数式组件进行逻辑复用、状态管理的方式\n\n旧的思维：“我在这个生命周期要检查props.A和state.B（props和state），如果改变的话就触发xxx副作用”。这种思维在后续修改逻辑的时候很容易漏掉检查项，造成bug。新的思维：“我的组件有xxx这个副作用，这个副作用依赖的数据是props.A和state.B”。从过去的命令式转变成了声明式编程。———— csr632 《为什么 React 现在要推行函数式组件，用 class 不好吗？》下的回答\n\n","tags":["React"]},{"title":"React-Ecosystem","url":"/qqsnote/2020/07/16/React-Ecosystem/","content":"MaterialUIyarn add @material-ui&#x2F;core\noverride material ui styles\nNext.js典型的网站模块和框架，封装webpack、babel, 支持按需加载和seo优化\nstyled component\nSSR和水合作用\n在服务器端已经渲染好的 HTML “骨架”上，附加上 JavaScript 的事件和交互逻辑，使其从一个静态页面变成一个完全可交互的 React 应用的过程。\nReduxReact提供了视图层面组件化开发的模式。为实现组件之间通信和多样的交互，需要引入Redux库\n\nRedux is a predictable state container for JavaScript apps.npx create-react-app my-app --template redux-typescriptnpm install @reduxjs&#x2F;toolkit\nstore， state， action一个应用中只有一个store，是所有组件数据的容器import &#123; createStore &#125; from &#39;redux&#39;;const store &#x3D; createStore(fn);const state &#x3D; store.getState();state是state在某个时间点的快照，state与view绑定\npreact据说是使用更符合Dom规范的事件系统，直接使用浏览器原生事件系统而不是统一用onChange，从而对React的设计进行了简化注1\n\ncracocreate-react-application-configure-overridecraco,当下流行的对React项目进行自定义配置的社区解决方案，AntDesign4官方亦有在使用更骚的create-react-app开发环境配置craco从create-react-app开始配置(关于create-react-app见React)npx create-react-app my-project npx create-react-app my-project --template typescriptyarn add antd @craco&#x2F;craco craco-less @babel&#x2F;plugin-proposal-decorators babel-plugin-import -D添加craco配置 craco.conf.js，即模块化配置，根据所需的资源参考方案：https://github.com/gsoft-inc/craco/tree/master/recipes\npackage.json scripts将命令替换为craco&nbsp;&nbsp;”start”: “react-scripts start”,&nbsp;&nbsp;”build”: “react-scripts build”,&nbsp;&nbsp;”test”: “react-scripts test”,&nbsp;&nbsp;”eject”: “react-scripts eject”&nbsp;&nbsp;”start”: “craco start”,&nbsp;&nbsp;”build”: “craco build”,&nbsp;&nbsp;”test”: “craco test”\nformat.js 国际化见format.js\nreact router安装react-router-dom,这个package是基于react-router开发的，且实现了现成的组件如Link Switch等ReactDOM.render(    &lt;BrowserRouter&gt;        &lt;AppRoutes &#x2F;&gt;    &lt;&#x2F;BrowserRouter&gt;,)...const AppRoutes &#x3D; () &#x3D;&gt; &#123;    return (        &lt;div&gt;            &lt;nav&gt;                &lt;ul&gt;                    &lt;li&gt;&lt;Link to&#x3D;&quot;&#x2F;dashboard&quot;&gt;Dashboard&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;                    &lt;li&gt;&lt;Link to&#x3D;&quot;&#x2F;device&quot;&gt;Device&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;                    &lt;li&gt;&lt;Link to&#x3D;&quot;&#x2F;squre&quot;&gt;Squre&lt;&#x2F;Link&gt;&lt;&#x2F;li&gt;                &lt;&#x2F;ul&gt;            &lt;&#x2F;nav&gt;            &lt;div&gt;                &lt;Route path&#x3D;&quot;&#x2F;dashboard&quot; component&#x3D;&#123;Dashboard&#125; &#x2F;&gt;                &lt;Route path&#x3D;&quot;&#x2F;device&quot; component&#x3D;&#123;Device&#125; &#x2F;&gt;                &lt;Route path&#x3D;&quot;&#x2F;squre&quot; component&#x3D;&#123;Squre&#125; &#x2F;&gt;            &lt;&#x2F;div&gt;        &lt;&#x2F;div&gt;    )&#125;\n拖拽 react-dndfunction DraggableComponent(props) &#123;  const [collected, drag, dragPreview] &#x3D; useDrag(() &#x3D;&gt; (&#123;    type,    item: &#123; id &#125;  &#125;))&#125;\nuseDrag钩子, 接受一个specification配置 声明拖动的type 被拖动项item 需要回传的collect， 返回collect的属性，drag source的引用以及drag preview元素const [&#123; isOver, canDrop &#125;, dropRef] &#x3D; useDrop(&#123;    accept,    drop: onDrop,    collect: (monitor) &#x3D;&gt; (&#123;        isOver: monitor.isOver(),        canDrop: monitor.canDrop(),    &#125;),&#125;)useDrop钩子接收一个‘specification’配置作为参数 可配置drop-target接收的类型 需要回传的props参数返回包含drop-target节点的reference以及回传的props如{isOver, canDrop}的一个列表 \ntrouble shooting Can’t resolve ‘react/jsx-runtime’\nvite.jsVite vs Webpack\n@emotion/reactcss in js方案\n","tags":["React"]},{"title":"React 高阶组件","url":"/qqsnote/2023/07/12/React-HOC/","content":"来源于js高阶函数，高阶函数是接受函数作为输入或者输出的函数，（柯里化方法属于高阶函数）高阶组件接受组件作为参数，并输出新的组件\n高阶组件的意义：\n\n属性代理(Props Proxy)\n反向继承(Inheritance Inversion)\n\n范式：\n\nHOC 使用组合而非继承的方式来复制参数组件的行为\nHOC 通过将原组件包装在容器组件中来组成新组件，而不是修改参数组件\nHOC 是纯函数，没有副作用\nHOC 不需要关心数据的使用方式，而包装组件也不需要关心数据的来源；容器组件和包装组件之间的契约完全由 props 来确定\n\nexport const HOC &#x3D; (OriginComponent) &#x3D;&gt; &#123;    return &lt;&gt;           &lt;&#x2F;&gt;&#125;","tags":["React"]},{"title":"React-Native","url":"/qqsnote/2024/01/25/React-Native/","content":"Why React NativeReact Native 和前端技术生态重合度很高，学习成本低, 一份源码可以同时编译成 Android 和 iOS 原生应用. 适合更新迭代较快的项目同时 其底层架构师根植于移动端原生API 可以自定义原生模块 以及优化性能\n本质（nature）\n在 Android 开发中是使用 Kotlin 或 Java 来编写视图；在 iOS 开发中是使用 Swift 或 Objective-C 来编写视图。在 React Native 中，则使用 React 组件通过 JavaScript 来调用这些视图。在运行时，React Native 为这些组件创建相应的 Android 和 iOS 视图。由于 React Native 组件就是对原生视图的封装，因此使用 React Native 编写的应用外观、感觉和性能与其他任何原生应用一样。我们将这些平台支持的组件称为原生组件。\n在较早的React Native中通过称为Bridge的异步机制完成js与原生代码之间的通信，0.74版本开始默认使用Bridgeless mode，调用JSI访问原生代码从而提高性能和响应速度\nReact Native 允许您为 Android 和 iOS 构建自己的 Native Components（原生组件），以满足您开发应用程序的独特需求。React Native 还包括一组基本的，随时可用的原生组件，您可以使用它们来构建您的应用程序。这些是 React Native 的核心组件。\n\n环境配置\nnode &amp; jdk choco install -y nodejs-lts microsoft-openjdk17\nAndroid Studio\nAndroid SDK及路径其环境变量参考Environment Setup\n\nReact Native项目npx @react-native-community&#x2F;cli@latest init AwesomeProjectyarn start # 启动 Metro 构建工具yarn android\nAndroid设备\n\nUSB连接Android手机\nAVD(Android Virtual Device)模拟器\n\nAndroid Studio—&gt;工具栏Device Manager—&gt;Add a new device—&gt;Create Virtual Device—&gt;选择任意设备—&gt;Next—&gt;UpsideDownCake API Level 34 image\n开发Android Studio开发js/ts很不习惯，可以使用vscode调试，添加react-native-tool，配置emulator到环境变量以使能被vscode调起npm i -g react-nativereact-native init mobileAppnpm run androidnpm run ios项目终端执行 npm run android 输出$ react-native run-androidinfo Launching emulator...info Installing the app&gt; IDLE&gt; IDLE...安装完毕后会另外启动四个窗口\n\nNodeJS 窗口\nemulator\\crashpad_handle.exe\nemulator\\qemu\\windows-x86_64\\qemu-system-x86_64.exe\nAndroid Emulator 移动设备界面\n\n调试在Android Emulator界面上按 Ctrl + M 弹出Emulator菜单，在菜单中点击Open DevTools启动React Native Cli自带DevTools\n打包cd android.&#x2F;gradlew assembleRelease\nandroid emulator命令行输入emulator —help查看工具参数手册emulator -list-avds...对于应用crash导致系统崩溃，尝试不加载snapshot后冷启动emulator -avd myavd -no-snapshot-load -no-snapshot-saveemulator -avd myavd -cold-boot# 擦除用户数据（恢复设置）emulator -avd myavd -no-snapshot-load -wipe-data将本地文件放入虚拟设备avd push D:\\Download\\Game.apk &#x2F;sdcard&#x2F;Download&#x2F;Game.apkInternet\nPlatformimport &#123;Platform, StyleSheet&#125; from &#39;react-native&#39;;const styles &#x3D; StyleSheet.create(&#123;  height: Platform.OS &#x3D;&#x3D;&#x3D; &#39;ios&#39; ? 200 : 100,&#125;);\nPlatform.OS返回’ios’ 或者’android’Platform.version返回OS版本号Platform.select根据平台返回以平台字符串为key的map中对应的valueconst Component &#x3D; Platform.select(&#123;  ios: () &#x3D;&gt; require(&#39;ComponentIOS&#39;),  android: () &#x3D;&gt; require(&#39;ComponentAndroid&#39;),&#125;)();&lt;Component &#x2F;&gt;;\nMetroThe JavaScript bundler for React Native 打包器\n视图视图是React Native UI的基本组成。视图的概念可以小到屏幕上的一个小矩形元素、可用于显示文本、图像或响应用户输入。甚至应用程序最小的视觉元素（例如一行文本或一个按钮）也都是各种视图。View可以嵌套View。全部都是视图。\n核心组件\nView\nText\nImage\nScrollView\nTextInput\nStyleSheet\nButton\nSwitch\nFlatList\nSectionList\n\n样式与网页的不同\n\n子元素不继承样式\n驼峰命名fontSize\n不使用单位(px等)\n\nStyleSheet:import &#123; StyleSheet, Text &#125; from &#39;reat-native&#39;const styles &#x3D; StyleSheet.create(&#123;  sectionTitle: &#123;    fontSize: 24  &#125;&#125;)return (  &lt;&gt;    &lt;Text style&#x3D;&#123;&#123;styles.sectionTitle&#125;&#125;&gt;  &lt;&#x2F;&gt;)css px是逻辑像素，物理像素/逻辑像素叫设备像素比 这里css省略px，强调逻辑像素，具体显示的物理像素数量由设备根据屏幕种类换算\nPPI(pixels per inch)每英寸物理像素点\nRN中的Flexbox规则和Web中Css FlexBox基本一致，主要的不同就是flex-direction默认不同，css中默认是水平方向，rn中默认是垂直方向。\n阴影样式shadowBorder:&#123;  shadowColor:&#39;#000&#39;,  shadowOffset:&#123;width:0, height:0&#125;,  shadowOpacity:0.6,  shadowRadius:8,  elevation:1&#125;对应cssbox-shadow: &#39;0 0 8px 8px #000a&#39;即iOS 通过 shadowOffset shadowOpacity shadowRadius 来实现阴影，而 Android 则通过 elevation 来实现阴影，ios\nNavigatorReact Native NavigationReact Native 中导航变得很复杂，原因在于页面url不会加入window.history\n\nStack Navigator\nTab Navigator\nDrawer Navigatoryarn add @react-navigation&#x2F;nativeyarn add react-native-screens react-native-safe-area-contextyarn add @react-navigation&#x2F;native-stack --&gt; stack导航器\n编辑位于 android/app/src/main/java// 下的 MainActivity.kt 或 MainActivity.java 文件。添加以下代码&#x2F;&#x2F;...import android.os.Bundle;class MainActivity: ReactActivity() &#123;  &#x2F;&#x2F; ...  override fun onCreate(savedInstanceState: Bundle?) &#123;    super.onCreate(null)  &#125;  &#x2F;&#x2F; ...&#125;\nExample：const Stack &#x3D; createNativeStackNavigator(); function App(): React.JSX.Element &#123;   return (    &#x2F;&#x2F; &lt;SafeAreaView style&#x3D;&#123;backgroundStyle&#125;&gt;      &lt;NavigationContainer&gt;            &lt;Stack.Navigator initialRouteName&#x3D;&#39;Home&#39;&gt;        &lt;Stack.Screen name&#x3D;&quot;Home&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;        &lt;Stack.Screen name&#x3D;&quot;List&quot; component&#x3D;&#123;PatientList&#125; &#x2F;&gt;        &lt;Stack.Screen name&#x3D;&quot;Detail&quot; component&#x3D;&#123;PatientDetail&#125; &#x2F;&gt;      &lt;&#x2F;Stack.Navigator&gt;      &lt;&#x2F;NavigationContainer&gt;     &#x2F;&#x2F; &lt;&#x2F;SafeAreaView&gt;  );&#125;\n响应式Dimensions APIimport &#123; Dimensions &#125; from &#39;react-native&#39;const &#123; width, height &#125; &#x3D; Dimensions.get(&#39;screen&#39;)&#x2F;&#x2F;包括状态栏和底部导航const &#123; width, height &#125; &#x3D; Dimensions.get(&#39;window&#39;)&#x2F;&#x2F;Android不包括， IOS上与screen相同\n监听屏幕尺寸改变(横竖屏切换，折叠屏)useEffect(() &#x3D;&gt; &#123;    const subscription &#x3D; Dimensions.addEventListener(      &#39;change&#39;,      (&#123; window &#125;) &#x3D;&gt; &#123;        setWindowSize(&#123;          width: window.width,          height: window.height,        &#125;)      &#125;)    return () &#x3D;&gt; subscription?.remove() &#x2F;&#x2F;组件unmount时移除监听&#125;, [])\n\n\nAndroidManifest.xml声明安卓应用版本信息，元数据，权限声明等，相应的ios应用是Info.plist&lt;uses-permission android:name&#x3D;&quot;android.permission.CAMERA&quot; &#x2F;&gt;\nbuild.gradle配置应用的构建过程，包含依赖的仓库和插件等等使用react-native-vector-icons需要配置build.gradleapply from: file(&quot;..&#x2F;..&#x2F;node_modules&#x2F;react-native-vector-icons&#x2F;fonts.gradle&quot;)使用icons：import Icon from &quot;react-native-vector-icons&#x2F;FontAwesome&quot;&lt;Icon name&#x3D;&quot;camera&quot; color&#x3D;&quot;#ccc&quot; size&#x3D;&#123;36&#125; onPress&#x3D;&#123;openCamera&#125; &#x2F;&gt;\n"},{"title":"React-style","url":"/qqsnote/2023/05/09/React-style/","content":"CSS Modules：CSS Modules将CSS文件的类名作为局部作用域进行处理，以避免全局命名冲突，同时方便了在组件中使用CSS。在React中，您可以使用Webpack和css-loader来加载CSS Modules。\nStyled Components：Styled Components是一个CSS样式解决方案，它通过将CSS作为模板字符串嵌入到JavaScript中来直接在组件中定义样式，从而使组件的样式与其它代码逻辑紧密耦合。\nCSS-in-JS：CSS-in-JS是使用JavaScript来动态地管理CSS样式的方法。这种方法的好处是可以通过JavaScript组合样式，动态修改样式以及动态响应用户交互。\n"},{"title":"React vs Angular","url":"/qqsnote/2021/05/11/React-vs-Angular/","content":"templatevue和angular都鼓励开发者编写尽可能与常规Html相似的template，react却并不是，react则崇尚all in js. 不过从编译角度看，两种方式都是语法糖而已，无论编码风格，编译后都是一个可执行函数\nrender principle了解Angular Ivy: Incremental DOM 和 Virtual DOM\necosystemreact生态庞杂，官方定义了基架，各种具体场景的实现技术在社区百花齐放，各路大神乐于造自己的轮子，库选型劝退选择恐惧症。。。angular：桶里啥都有。。。\n","tags":["React"]},{"title":"React","url":"/qqsnote/2020/06/29/React/","content":"JSX模板以.jsx为后缀的标记文件，用以书写混合js逻辑的dom模板example.jsx, jsx文件经Babel编译为js运行\nconst JSX = (  &lt;div className=&quot;myDiv&quot;&gt;    &lt;h1&gt;Hello World&lt;/h1&gt;    &lt;p&gt;Lets render this to the DOM&lt;/p&gt;  &lt;/div&gt;);ReactDOM.render(JSX,document.getElementById(&quot;challenge-node&quot;))\n\n用{}包含js代码，包括变量和相应方法\n用className绑定class样式\n\n除了jsx标记之外，还有createElement创建React组件的方法\n//声明// const element = React.createElement(&#x27;div&#x27;, &#123; className: &#x27;greeting&#x27; &#125;, &#x27;Hello World!&#x27;)//引用&lt;element /&gt;\n注释use the syntax {/**/}\n表单render() &#123;  return (    &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;      &lt;label&gt;        文章:        &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;      &lt;/label&gt;      &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;    &lt;/form&gt;  );&#125;\nES6语法import &#123; Component &#125; from &#x27;react&#x27;class App extends Component &#123;  constructor(props) &#123;    super(props);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Here is Entry&lt;/h1&gt;        &#123;/* 子组件 */&#125;        &lt;ChildComponent /&gt;      &lt;/div&gt;    );  &#125;&#125;;const ChildComponent = () =&gt; &#123;  return (    &lt;div&gt;      &lt;p&gt;I am the child&lt;/p&gt;    &lt;/div&gt;  );&#125;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;app&quot;)) \n子组件传参const CurrentDate = (props) =&gt; &#123;  return (    &lt;div&gt;      &lt;p&gt;The current date is: &#123;props.date&#125;&lt;/p&gt;    &lt;/div&gt;  );&#125;;const Data = ()=&gt;&#123;  return new Date().toLocaleString();&#125;class Calendar extends React.Component &#123;  constructor(props) &#123;    super(props);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h3&gt;What date is it?&lt;/h3&gt;        &lt;CurrentDate date=&#123;Date()&#125;/&gt;        &lt;p&gt;&#123;this.props.name&#125;&lt;/p&gt;      &lt;/div&gt;    );  &#125;&#125;;\n使用函数表达式不需要this指针而class定义是要的(ES6 ()=&gt;{}不创建this)\n另外设置默认参数：ComponentA.defaultProps = {name:’New Component’}\n更多组件通信见React组件交互\n参数校验MyComponent.propTypes = &#123;  // 你可以将属性声明为 JS 原生类型，默认情况下  // 这些属性都是可选的。  optionalArray: PropTypes.array,  optionalBool: PropTypes.bool,  optionalFunc: PropTypes.func,  optionalNumber: PropTypes.number,  optionalObject: PropTypes.object,  optionalString: PropTypes.string,  optionalSymbol: PropTypes.symbol,  // 任何可被渲染的元素（包括数字、字符串、元素或数组）  // (或 Fragment) 也包含这些类型。  optionalNode: PropTypes.node,  // 一个 React 元素。  optionalElement: PropTypes.element,  // 一个 React 元素类型（即，MyComponent）。  optionalElementType: PropTypes.elementType,  // 你也可以声明 prop 为类的实例，这里使用  // JS 的 instanceof 操作符。  optionalMessage: PropTypes.instanceOf(Message),  // 你可以让你的 prop 只能是特定的值，指定它为  // 枚举类型。  optionalEnum: PropTypes.oneOf([&#x27;News&#x27;, &#x27;Photos&#x27;]),  // 一个对象可以是几种类型中的任意一个类型  optionalUnion: PropTypes.oneOfType([    PropTypes.string,    PropTypes.number,    PropTypes.instanceOf(Message)  ]),  // 可以指定一个数组由某一类型的元素组成  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),  // 可以指定一个对象由某一类型的值组成  optionalObjectOf: PropTypes.objectOf(PropTypes.number),  // 可以指定一个对象由特定的类型值组成  optionalObjectWithShape: PropTypes.shape(&#123;    color: PropTypes.string,    fontSize: PropTypes.number  &#125;),    // An object with warnings on extra properties  optionalObjectWithStrictShape: PropTypes.exact(&#123;    name: PropTypes.string,    quantity: PropTypes.number  &#125;),     // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保  // 这个 prop 没有被提供时，会打印警告信息。  requiredFunc: PropTypes.func.isRequired,  // 任意类型的数据  requiredAny: PropTypes.any.isRequired,  // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。  // 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。  customProp: function(props, propName, componentName) &#123;    if (!/matchme/.test(props[propName])) &#123;      return new Error(        &#x27;Invalid prop `&#x27; + propName + &#x27;` supplied to&#x27; +        &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27;      );    &#125;  &#125;,  // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。  // 它应该在验证失败时返回一个 Error 对象。  // 验证器将验证数组或对象中的每个值。验证器的前两个参数  // 第一个是数组或对象本身  // 第二个是他们当前的键。  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123;    if (!/matchme/.test(propValue[key])) &#123;      return new Error(        &#x27;Invalid prop `&#x27; + propFullName + &#x27;` supplied to&#x27; +        &#x27; `&#x27; + componentName + &#x27;`. Validation failed.&#x27;      );    &#125;  &#125;)&#125;;\n使用 PropTypes 进行类型检查\nstate及组件生命周期&gt;\n\nprops是父组件传入的只读参数，state是组件自身的动态的状态\n为了正确地构建组件，需要找出组件模型所需的 state 的最小表示，其他所有数据根据该state计算出。React哲学props是传入参数，而state是组件内部表征状态的对象，往往在构造函数中，根据props初始化state\n\n组件状态更新使用setState，函数触发组件的重新渲染\nclass Clock extends React.Component &#123;  constructor(props) &#123;    super(props);    // 初始化date为当前时间    this.state = &#123;date: new Date()&#125;;  &#125;  /* 加载 */  componentDidMount() &#123;    // 1s后开始跳    this.timerID = setInterval(      () =&gt; this.tick(),      1000    );  &#125;  /* 卸载 */  componentWillUnmount() &#123;    clearInterval(this.timerID);  &#125;  tick=()=&gt;&#123;this.setState((pre)=&gt;(&#123;date:new Date()&#125;))&#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;Hello, world!&lt;/h1&gt;        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;      &lt;/div&gt;    );  &#125;&#125;\nbind ‘this’class MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      text: &quot;Hello&quot;    &#125;;    this.handleClick = this.handleClick.bind(this);  &#125;  handleClick() &#123;    this.setState(&#123;      text: &quot;You clicked!&quot;    &#125;);  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;button onClick=&#123;this.handleClick&#125;&gt;Click Me&lt;/button&gt;        &lt;h1&gt;&#123;this.state.text&#125;&lt;/h1&gt;      &lt;/div&gt;    );  &#125;&#125;;\n为什么要bind(this) 因为在严格模式下(React内部执行严格模式)函数在对象外被调用时 this 并不指向对象，事实上React组件的响应方法不‘生成’this(即undefined) 这与非严格模式下的html原生事件响应不同(非严格模式下事件会指向window) 原因在于React事件并不真实作用于dom节点，而是编译时生成的独立响应树(事件委托机制)\n如果handleClick需要处理组件属性 必须onClick={this.handleClick.bind(this)} 或在构造方法中提前绑定\n条件渲染render() &#123;  const isLoggedIn = this.state.isLoggedIn;  let button;  if (isLoggedIn) &#123;    button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;  &#125; else &#123;    button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;  &#125;  return (    &lt;div&gt;      &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;      &#123;button&#125;    &lt;/div&gt;  );&#125;\n与运算&amp;&amp;\n&#123;flag &amp;&amp; &lt;toggleComponent /&gt;&#125;\n三目运算\nrender() &#123;  const isLoggedIn = this.state.isLoggedIn;  return (    &lt;div&gt;      &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;      &#123;isLoggedIn?&lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;:&lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;&#125;    &lt;/div&gt;  );&#125;\n继承没有继承！\n\n在render return中组合子组件提供了清晰而安全地定制组件外观和行为的灵活方式，没有需要使用继承来构建组件层次的情况。React Docs:组合 vs 继承\ncreateRef onRef useRef\n子组件实例化回调函数，用以获取子组件对象\n\nuseRef 仅能用在 FunctionComponent，createRef 仅能用在 ClassComponent。\n\n组件的对象会随组件的更新而刷新，但useRef返回的对象不会随着组件的更新而重新构建，像引入的全局变量，且随组件的销毁而释放，不需手动销毁\nFragment相当于Angular的template，插入子组件不生成额外的元素(如div)，可以省略为\nReactDOMServerclass App extends React.Component &#123;  constructor(props) &#123;    super(props);  &#125;  render() &#123;    return &lt;div/&gt;  &#125;&#125;;ReactDOMServer.renderToString(&lt;App /&gt;);\n服务端渲染(SSR),生成dom的html字符串,实现SEO优化\nCreate React App这是一个package create-react-app, 如angular-cli，和vue-cli中包含的命令工具(这里封装的命令是react-scripts, 见package.json中的scripts)，用以创建基于React的完整应用。\nmy-app/  node_modules/  public/    index.html    favicon.ico  src/    App.css    App.js    App.test.js    index.css    index.js    logo.svg  README.md  package.json```js#### 关于typescript```jsyarn add --dev typescript\n在tsconfig.json中配置typescript编译器(略)\n使用tsx文件书写包含jsx代码的typescript代码\n使用tsc命令编译\n添加@types/react, vs code 右下角TypeScript版本选择4..-pnpify\nlistconst ArrayComponent = () =&gt; &#123;  const array = [&#x27;John&#x27;, &#x27;Robbie&#x27;, &#x27;Tony&#x27;]  return (    &lt;&gt;    &#123;array.map((name, index)=&gt;&lt;Item key=&#123;index&#125; &gt;&#123;name&#125;&lt;/Item&gt;)&#125;    &lt;&gt;  )&#125;```js需要指出的是 key 并不是 Item定义的Props，在Item组件内部访问key会得到undefined[Github Issue:this.key seems to always be undefined inside a React component](https://github.com/facebook/react/issues/2429#issuecomment-61008642)#### Interview Questions&gt;&gt; 类组件 vs 函数组件&gt; props不可变性&gt; React hook 闭包陷阱闭包内缓存state 导致定时器时间间隔内取到的都是上一次的值```jsfunction Counter() &#123;  const [count, setCount] = useState(0);  const handleClick = () =&gt; &#123;    setTimeout(() =&gt; &#123;      setCount(count + 1);    &#125;, 1000);  &#125;;  const handleReset = () =&gt; &#123;    setCount(0);  &#125;;  return (    &lt;div&gt;      &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;handleClick&#125;&gt;Increment&lt;/button&gt;      &lt;button onClick=&#123;handleReset&#125;&gt;Reset&lt;/button&gt;    &lt;/div&gt;  );&#125;\nsetCount(count =&gt; (count + 1))可以避免\n","tags":["React"]},{"title":"读书分享20230609","url":"/qqsnote/2023/06/08/ReadingSharing20230609/","content":"@startmindmap* 阴阳五行学    ** 维度        *** 两仪         *** 四象          *** 八卦 乾 坎 艮 震 巽xùn 离 坤 兑         *** 术数        ** 历史         *** 《周易》 * 道教神话体系    ** 天人    ** 神兽 神木 仙山 矿藏 神魔    ** 干支纪年        *** 甲 乙 丙 丁 戊 己 庚 辛 壬 癸        *** 子 丑 寅 卯 辰 巳 午 未 申 酉 戌 亥    ** 星宿 [[https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;582989560 星图]] [[https:&#x2F;&#x2F;zhidao.baidu.com&#x2F;question&#x2F;451326733.html?fr&#x3D;search&amp;word&#x3D;%D0%C7%CB%DE%B7%D6%D2%B0+%BB%F9%D3%DA&amp;ie&#x3D;gbk 分野]]        *** 东·青龙 角 亢 氐 房 心 尾 箕        *** 北·玄武 斗 牛 女 虚 危 室 壁        *** 西·白虎 奎 娄 胃 昴mǎo 毕 觜zī 参        *** 南·朱雀 井 鬼 柳 星 张 翼 轸    ** 劫数        *** 三灾    ** 临兵斗者皆阵列在前* 修仙文学体系    ** 境界        *** 练气 筑基 金丹 元婴 出窍 分神 合体 渡劫 大乘 《飘渺之旅》        *** 品阶 宗师     ** 进阶套路         @endmindmap"},{"title":"《沉思录》","url":"/qqsnote/2020/07/16/Reading-Meditations%20/","content":"在继承中闪耀的美德\n灵魂之所以会伤害自身 往往都是它无法承受快乐或痛苦的时候\n\n不以物喜，不以己悲，居庙堂之高，则忧其民；处江湖之远，则忧其君。是进亦忧，退亦忧；然则何时而乐耶？其必曰：“先天下之忧而忧，后天下之乐而乐”呼！噫！微斯人，吾谁与归？\n理性的灵魂基于理性的生物天地规律是我们必须遵守的生前伟大 死后遗忘与傻瓜对话我们即为傻瓜\n做事不可迟缓，言谈不可杂乱，思想不可漂游，灵魂不可全然倾注自我，也不可总被外物烦扰，生活不可始终忙碌不止\n\n为了人类的进步我应多做有意义的事\n人与人之间，即相互鄙视，又相互奉承，每个人都希望自己高人一等，又匍匐在别人面前\n\n马可·奥勒留在位的第5年是45岁，按现在的平均寿命而言他正值春秋鼎盛，这一年就是公元166年，他在这一年达成了养父安敦尼的政治遗愿——联通了中国。中国和罗马的史书都没有记载这次联通的结果，当时在位的皇帝是汉桓帝\n奥勒留所在的历史时期命名为“安敦尼王朝”，这个时期的罗马帝国有6位皇帝，按次序分别是涅尔瓦、图拉真、哈德良、安敦尼、马可·奥勒留和康茂德。之所以如此称谓是因为其时的罗马统治者一般都认为，安敦尼的统治时期是罗马帝国最发达最繁荣的时代，并认为元首本人就是最理想君主的摹本，并把王朝中康茂德之前的五任皇帝评价为“五贤帝”，奥勒留是五贤帝的最后一位。\n屋大维统治晚期，政治遗嘱建议罗马的疆域不再扩张，此后直到罗马分裂，其疆域一直保有着横跨欧亚非三个大陆的庞大体量。极度不发达的交通、极度辽阔的幅员和繁星满天的种族信仰所伴生的运转不灵兼供血不足，直接导致了巨人症帝国的统治矛盾丛生蔓长且无处不在。以奥勒留为例，如果形容他的统治期，最接地气的莫过于中国诗人王勃的16字咒“时运不济、命运多舛、冯唐易老、李广难封”。\n奥勒留于162年继位成为罗马帝国皇帝。在前一年，帕提亚的沃洛吉斯四世（Vologases IV）继位，开始入侵亚美尼亚和叙利亚，重夺埃德萨，奥勒留的养父安敦尼在忧愤中去世，奥勒留“奉命于危难之间”，接过了充满了硝烟的权杖，而这场战争一直打到奥勒留特使抵达中国洛阳的那一年——罗马有心东来，中国却无暇西顾。\n奥勒留的罗马处境远不止于此，在北方边境，马科曼尼人、夸狄人、萨马坦人、恺悌人和扎则基斯人等日耳曼部族都相继发动叛乱。巧合的还是公元166年——叛乱的先头部队一度冲进北部意大利。奥勒留当局被迫开启了全民皆兵模式，把奴隶和角斗士都编入军队。终奥勒留一生，这身扑火队长的行头一直没能脱下。180年3月17日，他死在了征讨马科曼尼人的多瑙河边的Pannonia省（现威尼斯），只是他并非战死而是死于瘟疫，而这场瘟疫也是奥勒留继位初期的种因。\n奥勒留继位做的第一举措，就是邀请安敦尼的另一养子维鲁斯共理国事，这是罗马帝国史上首度出现两帝共治。随后罗马安息战争的东方战事，奥勒留就托付给维鲁斯处理，维鲁斯率兵攻陷并焚毁了塞琉西亚和泰西封，与此同时一些士兵染上莫名且致命的传染病，军队因此撤回国内。这些近东作战的士兵带来了天花和麻疹，大瘟疫序幕拉开。死亡之霾悄无声息地从小亚细亚半岛暴风一般席卷了帝国东部，旋即迅速蔓延到西部的意大利、高卢和日耳曼地区，罗马帝国所有的行省都无一幸免。两个共治皇帝均病殁于这次瘟疫。更具讽刺意味的是，这次史上称为“安东尼瘟疫”的传染病，正是以奥勒留（马可·奥勒留·安东尼·奥古斯都）的名字命名的。\n这是传染病学史上的一次大事件，也是人类历史上十大恶性传染病事件之一。它继古希腊“雅典大瘟疫”之后，拜占庭“查士丁尼瘟疫”之前，为一千多年以后蔓延欧洲的黑死病风暴（即欧洲中世纪大瘟疫）开了先河。这场瘟疫，使包括社会精英在内的众多人口集体毙命。如雅典，在167-171年间，首席法官的职务就因候选人病死而无法补足。考虑到相似体制的行政单位还有许多，不少地方的基层治理能力就因此遭遇重创。罗马史学家迪奥卡称，当时罗马一天就有2千人因染病而死，占总传染人数的1/4；而在有些地方，瘟疫造成总人口的1/3死亡。估计总死亡人数有500万。\n奥勒留当局不得不从普通奴隶或角斗士队伍中招募新兵。但老兵的安抚与新人的入职，无不需要大笔资金维持，而帝国的银矿开采也因瘟疫而陷入停顿，如东方商业重镇亚历山大港的银币铸造完全停止，商品价格普遍上涨而地租却巨幅下跌。梁实秋曾如此描述“民穷财困，局势日非，玛克斯（即马可·奥勒留）被迫出售私人所藏珠宝，筹款赈灾。此种困窘情形，在玛克斯在位之日，一直继续存在。内忧外患，交相煎迫。”这场瘟疫就像巨人泰坦的铁拳，将帝国的各级秩序敲得摇摇欲坠，几乎所有的行业均震荡备至。\n这场瘟疫足足肆虐了7年之后才趋于消停。当在公元191年再度大规模爆发的时候，奥勒留已经去世11年了。\n兵戈瘟疫之外也并非全部，还有洪水泛滥，此处不赘。穷其执政期间，奥勒留如同暴风雨中海上的一叶小舢舨，无时无刻不处在鞍马倥偬和颠踣动荡中。人类万物的恒性在于追求平衡，外面越是风雨雷电，内里越是风淡云清，否则必然走向崩溃和灭失。你既然理解太平天国运动中的曾国藩、宁王之乱中的王阳明，那你也必然会理解奥勒留为什么成了“哲学家皇帝”了。\n今人不见古时月，今月曾经照古人。古人今人若流水，共看明月皆如此。唯愿当歌对酒时，月光长照金樽里。\n行文不像书籍 主旨零散 更像是日记的随笔 深夜寂寞的灯下与自己内心的对话我未伏案研读 肯定觉得枯燥 跑步时听的 在这种有氧运动中放空自己时 听到这样的文字 容易引起共鸣你想这个跟你对话的是一千八百年前的‘古人’呀 而且还是皇帝 一位皇帝 高居庙堂 掌握着古罗马的超大版图 这种人物应该鲜有闲情逸致写这种散漫的文字我们从经典古文中鲜有这种近距离之感\n","tags":["读书"]},{"title":"Redux","url":"/qqsnote/2020/07/30/Redux/","content":"这里是React-Redux，Redux状态管理的React绑定库，使React组件从Redux store中读取数据，并且向store分发actions以更新数据npm install --save react-redux或yarn add react-redux另，有typescript的definition包：@types/react-redux\nwhy Redux对比useContext\n\n复杂性：Redux通常被认为更复杂，而React Context更简单。\n状态管理：Redux提供了更严格的状态管理方式，中心化状态管理————状态在store中，状态的更新通过定义的纯函数进行。\n可预测性：由于状态更新的方法是预先定义的，故状态具有一定可预测性， 而context的更新太过灵活。\n可追踪性：Redux提供了更好的状态追踪和调试工具Redux DevTools。\n适用场景：Redux更适合大型应用，Context更适合小到中等规模的应用，或者作为大型应用中Redux的补充usage以Provider组件载入Redux storeimport React from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import &#123; Provider &#125; from &quot;react-redux&quot;;import store from &quot;.&#x2F;store&quot;;import App from &quot;.&#x2F;App&quot;;const rootElement &#x3D; document.getElementById(&quot;root&quot;);ReactDOM.render(  &lt;Provider store&#x3D;&#123;store&#125;&gt;    &lt;App &#x2F;&gt;  &lt;&#x2F;Provider&gt;,  rootElement);\n使用Hooks调用Redux storeimport React from &#39;react&#39;import &#123; useSelector, useDispatch &#125; from &#39;react-redux&#39;import &#123;  decrement,  increment,  incrementByAmount,  incrementAsync,  selectCount,&#125; from &#39;.&#x2F;counterSlice&#39;import styles from &#39;.&#x2F;Counter.module.css&#39;export function Counter() &#123;  const count &#x3D; useSelector(selectCount)  const dispatch &#x3D; useDispatch()  return (    &lt;div&gt;      &lt;div className&#x3D;&#123;styles.row&#125;&gt;        &lt;button          className&#x3D;&#123;styles.button&#125;          aria-label&#x3D;&quot;Increment value&quot;          onClick&#x3D;&#123;() &#x3D;&gt; dispatch(increment())&#125;        &gt;          +        &lt;&#x2F;button&gt;        &lt;span className&#x3D;&#123;styles.value&#125;&gt;&#123;count&#125;&lt;&#x2F;span&gt;        &lt;button          className&#x3D;&#123;styles.button&#125;          aria-label&#x3D;&quot;Decrement value&quot;          onClick&#x3D;&#123;() &#x3D;&gt; dispatch(decrement())&#125;        &gt;          -        &lt;&#x2F;button&gt;      &lt;&#x2F;div&gt;      &#123;&#x2F;* omit additional rendering output here *&#x2F;&#125;    &lt;&#x2F;div&gt;  )&#125;\nstore一个待办列表（todo list）的store示例&#123;  todos: [&#123;    text: &#39;Eat food&#39;,    completed: true  &#125;, &#123;    text: &#39;Exercise&#39;,    completed: false  &#125;],  visibilityFilter: &#39;SHOW_COMPLETED&#39;&#125;\nstore管理状态，状态不可随意改变actionaction用以触发状态更新 形如&#123;type:&#39;action_nameXX&#39;, value:&#39;any value&#39;&#125;\nreduce联系state和action的方法 即传入state action 根据action更新state 最后返回新的statefunction visibilityFilter(state &#x3D; &#39;SHOW_ALL&#39;, action) &#123;  switch (action.type) &#123;    case &#39;SET_VISIBILITY_FILTER&#39;:      return action.filter    default:      return state  &#125;&#125;function todos(state &#x3D; [], action) &#123;  switch (action.type) &#123;    case &#39;ADD_TODO&#39;:      return [        ...state,        &#123;          text: action.text,          completed: false        &#125;      ]    case &#39;COMPLETE_TODO&#39;:      return state.map((todo, index) &#x3D;&gt; &#123;        if (index &#x3D;&#x3D;&#x3D; action.index) &#123;          return Object.assign(&#123;&#125;, todo, &#123;            completed: true          &#125;)        &#125;        return todo      &#125;)    default:      return state  &#125;&#125;\nFlux Immutable数据流createStoreuseSelectordispatchmiddleware语法糖createSlice关于state tree极其reducer的嵌套从vuex迁移 原vuex代码export const initialState &#x3D; () &#x3D;&gt; (&#123;  data: &#123;    nextID: 1,    index: &#123;&#125;,    imageIDs: [],    dicomIDs: [],    modelIDs: [],    labelmapIDs: [],    vtkCache: &#123;&#125;,  &#125;,  &#x2F;&#x2F; track the mapping from volumeID to data ID  dicomVolumeToDataID: &#123;&#125;,  selectedBaseImage: NO_SELECTION,  &#x2F;&#x2F; data-data associations, in parent-of or child-of relationships.  &#x2F;&#x2F; is used for cascaded deletes  dataAssoc: &#123;    childrenOf: &#123;&#125;,    parentOf: &#123;&#125;,  &#125;,&#125;);export default (deps) &#x3D;&gt;  new Vuex.Store(&#123;    modules: &#123;      dicom: dicom(deps),      visualization: visualization(deps),      widgets: widgets(deps),      annotations: annotations(deps),      measurements: measurements(deps),    &#125;,    state: initialState(),    getters: &#123;      visibleLabelmaps(state) &#123;        return state.data.labelmapIDs.filter(          (id) &#x3D;&gt; state.dataAssoc.parentOf[id] &#x3D;&#x3D;&#x3D; state.selectedBaseImage        );      &#125;,      sceneObjectIDs(state, getters) &#123;        const &#123; selectedBaseImage, data &#125; &#x3D; state;        const order &#x3D; [].concat(getters.visibleLabelmaps, data.modelIDs);        if (selectedBaseImage !&#x3D;&#x3D; NO_SELECTION) &#123;          order.unshift(selectedBaseImage);        &#125;        return order;      &#125;,    &#125;,    mutations: &#123;      ...datasets.mutations,    &#125;,    actions: &#123;      ...datasets.makeActions(deps),    &#125;,  &#125;);\nredux:const preloadedState &#x3D; &#123;  data: &#123;    nextID: 1,    index: &#123;&#125;,    imageIDs: [],    dicomIDs: [],    modelIDs: [],    labelmapIDs: [],    vtkCache: &#123;&#125;,  &#125;,  &#x2F;&#x2F; track the mapping from volumeID to data ID  dicomVolumeToDataID: &#123;&#125;,  selectedBaseImage: -1,  &#x2F;&#x2F; data-data associations, in parent-of or child-of relationships.  &#x2F;&#x2F; is used for cascaded deletes  dataAssoc: &#123;    childrenOf: &#123;&#125;,    parentOf: &#123;&#125;,  &#125;,  widgets: &#123; focusedWidget: -1, widgetList: [], activeWidgetID: -1 &#125;,  annotations: &#123;    selectedLabelmap: -1,    currentLabelFor: &#123;&#125;, &#x2F;&#x2F; labelmap ID -&gt; currently selected label    labels: &#123;&#125;, &#x2F;&#x2F; labelmapID -&gt; label -&gt; color    radius: 0,    radiusRange: [1, 100],  &#125;,  measurements: &#123;    widgets: [], &#x2F;&#x2F; list of widget ids    measurements: &#123;&#125;, &#x2F;&#x2F; widget ID -&gt; opaque measurement obj    &#x2F;&#x2F; widget&#x2F;measurement parent is the base image association    parents: &#123;&#125;, &#x2F;&#x2F; data ID -&gt; [widget ID]    widgetParent: &#123;&#125;, &#x2F;&#x2F; widget ID -&gt; data ID  &#125;,&#125;;const store &#x3D; createStore(reducer, preloadedState);const reducer &#x3D; (state, action) &#x3D;&gt; &#123;  return &#123;    ...state,    widgets: widgets(state.widgets, action),    annotations: annotations(state.annotations, action),    measurements: widgets(state.measurements, action),  &#125;;&#125;;\n\n\n","tags":["React"]},{"title":"读书分享20231220","url":"/qqsnote/2023/12/20/ReadingSharing20231220/","content":"无间刘邦被围安史之乱潼关失守"},{"title":"响应式设计","url":"/qqsnote/2021/01/08/ResponsiveWebDesign/","content":"移动端‘像素点’密度往往高于桌面显示器，而横纵比例较小，使用移动设备打开页面，可能因为宽度不足产生挤压变形，也可能因为自动像素缩放导致layout变形\n视口(viewport)在document形成的整个视图中，从一个虚拟的窗口观察，视口较小时，需要借助横纵滚动条才能浏览页面&lt;meta name&#x3D;”viewport” content&#x3D;”width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1″&gt;视口宽度为设备宽度，初始缩放比例为1，最大缩放比例为1水平滚动条是极差的用户体验，将视口宽度设置为设备宽度，将页面样式调整到方便垂直滚动浏览\n\n请勿使用较大的固定宽度元素\n不要让内容依赖于特定值的视口宽度\n使用媒体查询为小屏幕和大屏幕应用不同样式Grid如Bootstrap Grid水平分割若干份，计算并罗列每份宽度，使用百分比，block之间用float排列，行末清除浮动.col-1 &#123;width: 8.33%;&#125;.col-2 &#123;width: 16.66%;&#125;.col-3 &#123;width: 25%;&#125;.col-4 &#123;width: 33.33%;&#125;.col-5 &#123;width: 41.66%;&#125;.col-6 &#123;width: 50%;&#125;.col-7 &#123;width: 58.33%;&#125;.col-8 &#123;width: 66.66%;&#125;.col-9 &#123;width: 75%;&#125;.col-10 &#123;width: 83.33%;&#125;.col-11 &#123;width: 91.66%;&#125;.col-12 &#123;width: 100%;&#125;[class*&#x3D;&quot;col-&quot;] &#123;  float: left;  padding: 15px;  border: 1px solid red;&#125;.row::after &#123;  content: &quot;&quot;;  clear: both;  display: table;&#125;\nBreakpoint设置一个边界，使用媒体查询，实现当宽度越过边界值时，触发从桌面屏幕layout到移动设备layout的跃变Imagestip: 图片的拉伸是有限的，专业的做法是为不同设备提供不同的资源&#x2F;* For width smaller than 400px: *&#x2F;body &#123;  background-image: url(&#39;img_smallflower.jpg&#39;);&#125;&#x2F;* For width 400px and larger: *&#x2F;@media only screen and (min-width: 400px) &#123;  body &#123;    background-image: url(&#39;img_flowers.jpg&#39;);  &#125;&#125;\nHTML5 新元素支持指定多个资源以及媒体条件&lt;picture&gt;  &lt;source srcset&#x3D;&quot;img_smallflower.jpg&quot; media&#x3D;&quot;(max-width: 400px)&quot;&gt;  &lt;source srcset&#x3D;&quot;img_flowers.jpg&quot;&gt;  &lt;img src&#x3D;&quot;img_flowers.jpg&quot; alt&#x3D;&quot;Flowers&quot;&gt;&lt;&#x2F;picture&gt;\n\n","categories":["前端技术"],"tags":["CSS"]},{"title":"正则表达式","url":"/qqsnote/2018/12/15/RegularExpression/","content":"\n剔除符号str.replace(&#x2F;[^0-9a-zA-Z]&#x2F;g,&quot;&quot;);function palindrome(str) &#123;  str &#x3D; str.replace(&#x2F;[^0-9a-zA-Z]&#x2F;g,&quot;&quot;);  str &#x3D; str.toLowerCase();  return str&#x3D;&#x3D;str.split(&quot;&quot;).reverse().join(&quot;&quot;);&#125;指定内容行前注#^(Proxy.+)$#$1$1为()内的内容\n\n常见用法regExp.test(target)判断target是否符合正则表达式规则\ntarget.match(regExp)返回target字符串中符合正则表达式规则的部分\n匹配语法flag: g, i\ng: global\ni: case insensitive\n\n集合[]非和开头^\n^在集合中表示非 \n\n 比如上面剔除符号的用法\n\n在集合外表示以…开头\n频率 +， *， ?\n\n\n\nsymbol\ndescription \n\n\n\n\n +\n出现1次或者多次\n\n\n *\n出现任意次\n\n\n ?\n出现一次或者不出现\n\n\n {n}\n重复n次\n\n\n {m, n}\n重复m~n次\n\n\n\n\n\ngreedy matching vs lazy matching贪心匹配（?）匹配最长的串，惰性匹配（?）匹配最小的串let text &#x3D; &quot;&lt;h1&gt;Winter is coming&lt;&#x2F;h1&gt;&quot;;let myRegex &#x3D; &#x2F;&lt;.*&gt;&#x2F;; let result &#x3D; text.match(myRegex); &#x2F;&#x2F; matching &lt;h1&gt;Winter is coming&lt;&#x2F;h1&gt;myRegex &#x3D; &#x2F;&lt;.*?&gt;&#x2F;; result &#x3D; text.match(myRegex); &#x2F;&#x2F; matching &lt;h1&gt;let article &#x3D; &quot;&lt;h1&gt;Winter is coming&lt;&#x2F;h1&gt;&lt;div&gt;&lt;&#x2F;div&gt;&lt;h1&gt;north remembers&lt;&#x2F;h1&gt;&lt;h1&gt;dragon is coming&lt;&#x2F;h1&gt;&lt;h1&gt;the Queen is coming&lt;&#x2F;h1&gt;&quot;let titles &#x3D; article.match(&#x2F;&lt;h1&gt;.*?&lt;\\&#x2F;h1&gt;&#x2F;g)\n\n思考：折中的需求\n\n匹配符合下列规律的字符串,规律是连续的两个parameter，即某规则重复2次&lt;parameter key&#x3D;&quot;xxx&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;&lt;any-other-marks&gt;&lt;parameter key&#x3D;&quot;yyy&quot; value&#x3D;&quot;2&quot; type&#x3D;&quot;0&quot;&#x2F;&gt;可以这样xmlInfo.match(&#x2F;&lt;parameter.*?\\&#x2F;&gt;.*?&lt;parameter.*?\\&#x2F;&gt;&#x2F;)里面有重复了两段规则，见下文（）部分\n代码占位符\n\n\n\nsymbol\ndescription \n\n\n\n\n\\w\n字符,空格,标点，下划线等 类似但不等价于[A-Za-z0-9_] \n\n\n\\W\n非字符\n\n\n\\d\n任意数字 相当于[0-9]\n\n\n\\D\n任意非数字\n\n\n\\s\n匹配任意不可见字符，包括空格、制表符、换页符等 相当于[ \\f\\n\\r\\t\\v]\n\n\n\\S\n匹配任意可见字符\n\n\n\n\nlookaheads暂时不知道如何翻译例 密码规则不少于6位，且至少包含连续2位数字let pwRegex &#x3D; &#x2F;(?&#x3D;\\w&#123;6,&#125;)(?&#x3D;\\D*\\d&#123;2&#125;)&#x2F;;let result &#x3D; pwRegex.test(sampleWord);(?=\\D*\\d{2})应理解为任意非数字内容（或者不存在这部分内容）加两个数字(?=…)检测包含…的字符串，(?!…)检测不包含…的字符串，只检测是否符合条件，不返回匹配片段\n()括号的本义是封装模式，封装的模式可以用\\1 \\2的方式代替上面有个遗留问题，重复部分可写作xmlInfo.match(&#x2F;(&lt;parameter.*?\\&#x2F;&gt;).*?\\1&#x2F;)上述代码存在问题\n正/反向断言\n(?=pattern)：正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。非获取匹配,即符合该模式的匹配结果不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。不消耗字符，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。\n\n(?!pattern)：正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。\n\n(?&lt;=pattern)： 反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。\n\n(?&lt;!pattern)：反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。从结果理解正向反向：匹配得到的“Windows”，如果对其接下来的内容有要求，正则表达式/Windows/要追加一个断言模式，如果对其之前的内容有要求，除了在/Windows/之前加断言模式，还要用“？&lt;”表明这是反向断言\n写过的例子\n常见邮箱格式&#x2F;^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;)$&#x2F;\n以,分隔的邮箱地址&#x2F;^(([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;),)*(([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]&#123;2,4&#125;))$&#x2F;\n获取文件扩展名\nfilename.match(&#x2F;\\.(\\w+)$&#x2F;);\n返回match的Array,取第一项为扩展名\n\n查找代码中所有的描述字符串(目的是做多语言替换)\n(?&lt;!from |require\\(|: |console\\.log\\()&#39;.+&#39;\n即非空字符串且排除import from，require，以及console.log等语法\n\n图床地址https://tvax+数字+.sinaimg.cn 模式的字符串替换为 https://i0.wp.com/tvax+相同数字+.sinaimg.cn 的字符串捕获组\n(https:\\&#x2F;\\&#x2F;tvax)(\\d)(\\.sinaimg\\.cn)\n替换\nhttps:&#x2F;&#x2F;i0.wp.com&#x2F;tvax$2.sinaimg.cn\n\n查找项目对某个库任意api的引用\nimport\\s*\\&#123;([^&#125;]*)\\&#125;\\s*from\\s+[&#39;&quot;]three[&#39;&quot;]$\n\n","categories":["工具"],"tags":["正则表达式"]},{"title":"路由器、AP 和 AC","url":"/qqsnote/2023/12/04/Router-AC-AP/","content":"AP(Access Point)通常说的是无线AP，即无线网络接入点，无线路由器的天线就是AP，其作用是收发网络数据信号，在网络中相当于交换机，家装中做全屋网络覆盖会安装AP设备 （因为常常是商用，其功能不如路由器售价却比路由器贵很多）\nAC(Access Controller)接入控制器，集中化控制局域网内可控的无线AP, 应用场景如商场的不同区域AP，统一连接到AC，使得顾客从一个区域到另一个区域，始终连接统一网络\n"},{"title":"Rust","url":"/qqsnote/2023/12/20/Rust/","content":"无意在网上看到了编程语言的鄙视链，我anyscript(ts)位列末端，Rust以其编码效率和执行效率、面向现代化，没有历史包袱的优点成为鄙视链上高于C/C++的存在\n"},{"title":"SQL Project及其持续集成","url":"/qqsnote/2020/11/23/SQL-Project/","content":"SSDT Project\nSQL Server Data Tools (SSDT) 通过引入跨 Visual Studio 内所有数据库开发阶段的无所不在的声明性模型，为数据库开发带来变革。创建一个数据库项目进行脱机的数据库开发（不直接对数据库服务进行在线修改），像编辑声明定义一样创建、编辑、重命名和删除表、存储过程、类型和函数。\n\n为Visual Studio安装SSDT的features，加载sqlproj或dtproj项目(VS2010数据库和服务器项目、数据层应用程序项目)，用所提供的方法build、publish所作的修改。参考Microsoft Docs:面向项目的脱机数据库开发\n创建visual studio sql project参考SQL Server 数据库项目\npublish右键项目 选择Publish注意 Scripts目录下的脚本也会执行，因此在这里编写初始数据是可行的如果是初始化数据，为了防止脚本重复执行，可以按如下方式插入数据DECLARE @CSDid uniqueidentifierSELECT @CSDid&#x3D;NEWID()INSERT INTO [ent].[ScannerGroup]           ([ID]           ,[Name]           ,[ParentID]           ,[Type]           ,[BrandID]           ,[GroupLevel])     SELECT           @CSDid           ,&#39;CSD&#39;           ,null           ,10           ,null           ,HierarchyID::GetRoot()     WHERE NOT EXISTS (SELECT 1 FROM [ent].[ScannerGroup])INSERT INTO [ent].[PartnerAdmin]           ([ID]           ,[Email]           ,[GroupID]           ,[Name])     SELECT           NEWID()           ,&#39;qqqqq@qqqq.qqq&#39;           ,@CSDid           ,&#39;QQs&#39;     WHERE NOT EXISTS (SELECT 1 FROM [ent].[PartnerAdmin])GO\nPredeployment Scripts &amp; Postdeployment Scripts\nPredeployment Scripts和Postdeployment Scripts分别在数据库项目生成的主要部署脚本之前和之后执行，在 Visual Studio 中，从架构比较结果更新目标时(Compare之后的Update)，将不执行Predeployment Scripts。 一个项目只能有一个Predeployment Scripts和一个Postdeployment Scripts。 \n\nScripts文件夹右键Add —&gt; Script… 选择Pre Deployment Scripts或Post Deployment Scripts\nissues\nOnly one statement is allowed per batch. A batch separator, such as ‘GO’, might be required between statements.\n\nScripts目录下的sql文件属性中，默认Build Action = Build导致编译失败，应改为Build Action = None\n.jfm文件，可以认为是对项目操作的备份，若未自动添加到gitignore，则可手动添加\n\nCannot import the following key file: RightCheckDB.pfx. The key file may be password protected. To correct this, try to import the certificate again or manually install the certificate to the Strong Name CSP with the following key container name: VS_KEY_E7D8A7C85598CE59\n\npfx是保存SSL Certificate的一种文件格式，上述错误表示SQL项目需要重新认证凭据。重新写入密码的方式&quot;C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v10.0A\\bin\\NETFX 4.8 Tools\\sn.exe&quot; -i companyname.pfx VS_KEY_3E185446540E7F7A\n用MSBuild和Jenkins实现Continuse Integration## set msbuild.exe&#x3D;C:&#x2F;Program Files (x86)&#x2F;Microsoft Visual Studio&#x2F;2017&#x2F;Professional&#x2F;MSBuild&#x2F;15.0&#x2F;Bin&#x2F;MSBuild.exemsbuild.exe &#x2F;t:Build &quot;MyDB.sqlproj&quot;msbuild.exe &#x2F;t:Publish &#x2F;p:SqlPublishProfilePath&#x3D;&quot;MyDB.publish.staging.xml&quot; &quot;MyDB.sqlproj&quot;\nDevOps issues\n实现一键部署\n实现集成过程可配置\n自动化脚本提交到版本控制库\n利用版本控制回退数据库\n应用的更新的集成使用最新的数据库\npipeline执行测试\n\n","categories":["数据库","工具"],"tags":["SQL_Server","Jenkins"]},{"title":"Rxjs","url":"/qqsnote/2020/03/24/Rxjs/","content":"\ncurrent version: 6.5.2\n关于响应式编程知乎：响应式编程\nObservable 的发布和订阅&#x2F;&#x2F; Create simple observable that emits three valuesconst myObservable &#x3D; of(1, 2, 3); &#x2F;&#x2F; or from([1,2,3])&#x2F;&#x2F; Create observer objectconst myObserver &#x3D; &#123;  next: x &#x3D;&gt; console.log(&#39;Observer got a next value: &#39; + x),  error: err &#x3D;&gt; console.error(&#39;Observer got an error: &#39; + err),  complete: () &#x3D;&gt; console.log(&#39;Observer got a complete notification&#39;),&#125;;&#x2F;&#x2F; Execute with the observer objectmyObservable.subscribe(myObserver);&#x2F;&#x2F; Logs:&#x2F;&#x2F; Observer got a next value: 1&#x2F;&#x2F; Observer got a next value: 2&#x2F;&#x2F; Observer got a next value: 3&#x2F;&#x2F; Observer got a complete notification\nof(…items) from(iterable)是自带常用产生Observable对象的工具\nObservable 可观察对象在http请求中，可观察对象不是new构造的，而是由httpclient的get或post方法返回一个Observable\\. 私以为是成功调用接口后就发布一个结果，这个结果可以用管道加工参考 Observable 的操作符getDict(dictname): Observable&lt;DictItem[]&gt; &#123;    return this.http.get(&#96;dict&#x2F;$&#123;dictname&#125;&#96;).pipe(      map((res: HttpResponse) &#x3D;&gt; &#123;        if (res.status &#x3D;&#x3D;&#x3D; &#39;ok&#39;) &#123;          return res.data;        &#125; else &#123;          return [];        &#125;      &#125;),    );&#125;获取这个结果就需要订阅（subscribe）这个Observable，这个Observable是匿名的，每次获取它需要调用函数来返回 \nQQs:为什么httpclient方法不需要取消订阅\n\n据说这些方法被实现为只next一次 \nSubject\nA Subject is a special type of Observable which shares a single execution path among observers.\n\n被比喻成广播者const subject &#x3D; new Subject();subject.subscribe(log(&#39;s1 subject&#39;));subject.subscribe(log(&#39;s2 subject&#39;));subject.next(&#39;r&#39;);subject.next(&#39;x&#39;);\n同步数据转Observable场景：组件粒度小，在视图中多次实例化，或者重复初始化，为防止频繁调用后台接口应加入数据缓存，基础数据缓存实现为，第一次调用，从httpclient获取接口数据的Observable对象，并用管道处理加入缓存，之后将缓存数据取出转为Observable对象basicdata.service.tsimport &#123; Observable, of, from &#125; from &#39;rxjs&#39;;import &#123; map &#125; from &#39;rxjs&#x2F;operators&#39;;users: User[];getUserList(): Observable&lt;User[]&gt; &#123;  if (this.users) &#123;    return of(this.users);  &#125; else &#123;    return this.http.post(&#96;user&#x2F;search&#96;, &#123; isvalid: 1 &#125;).pipe(      map((res) &#x3D;&gt; &#123;        this.users &#x3D; res as User[];        return this.users;      &#125;)    );  &#125;&#125;app.component.tsthis.basicData.getUserList().subscribe(list &#x3D;&gt; &#123;  this.userlist &#x3D; list;  this.getUserName();&#125;);\nPromise转Observable起初为了用async await编码以及利用链式调用，很多异步操作封装成了Promise，Promise转Observable用from方法转换import &#123; Observable, of, from &#125; from &#39;rxjs&#39;;import &#123; map &#125; from &#39;rxjs&#x2F;operators&#39;;getCurrentUserToken(): Observable&lt;any&gt; &#123;  if (this.currentUser) &#123;      return of(this.currentUser);  &#125; else &#123;      return from(this.ipcService.call(&#39;currentuser&#39;)).pipe(          map(arg &#x3D;&gt; &#123;              if (arg) &#123;                  return typeof arg &#x3D;&#x3D;&#x3D; &#39;string&#39; ? JSON.parse(arg) : arg;              &#125; else &#123;                  return null;              &#125;          &#125;)      );  &#125;&#125;\nObservable的链式调用操作符操作符实在太多了实现一个乘10的operatorfunction multiplyByTen(input: Observable&lt;any&gt;): Observable&lt;any&gt; &#123;  return Rx.Observable.create(observer &#x3D;&gt; &#123;    input.subscribe(&#123;      next: (v) &#x3D;&gt; observer.next(10 * v),      error: (err) &#x3D;&gt; observer.error(err),      complete: () &#x3D;&gt; observer.complete()    &#125;);  &#125;);&#125;\n创建操作符 of from interval等：from  转化Promise对象、类数组对象、迭代器对象转化为 Observables将数组转化为 Observablevar array &#x3D; [10, 20, 30];var result &#x3D; Rx.Observable.from(array);result.subscribe(x &#x3D;&gt; console.log(x));&#x2F;&#x2F; 结果如下:&#x2F;&#x2F; 10 20 30将一个无限的迭代器(来自于 generator)转化为 Observable。function* generateDoubles(seed) &#123;  var i &#x3D; seed;  while (true) &#123;    yield i;    i &#x3D; 2 * i; &#x2F;&#x2F; double it  &#125;&#125;var iterator &#x3D; generateDoubles(3);var result &#x3D; Rx.Observable.from(iterator).take(10);result.subscribe(x &#x3D;&gt; console.log(x));&#x2F;&#x2F; Results in the following:&#x2F;&#x2F; 3 6 12 24 48 96 192 384 768 1536\n转化操作符 map mapTo merge mergeMap等：map类似于Array.prototype.map投射函数应用于每个值;mapTo相当于忽略实际订阅接受结果，替换为指定值；merge将多个订阅捋直成一个订阅；mergeMap将投射函数应用于每个值，并将多个订阅捋直(啥?不懂)\ntakefiltertap\nPerform a side effect for every emission on the source Observable, but return an Observable that is identical to the source.对源可观察对象的每个‘发射’应用一个副作用，但仍然返回与源相同的可观察对象tap&lt;T&gt;(nextOrObserver?: NextObserver&lt;T&gt; | ErrorObserver&lt;T&gt; | CompletionObserver&lt;T&gt; | (  (x: T) &#x3D;&gt; void),  error?: (e: any) &#x3D;&gt; void,  complete?: () &#x3D;&gt; void): MonoTypeOperatorFunction&lt;T&gt;参数可以是可观察对象或回调方法常见于附上一个log操作getHeroes(): Observable&lt;Hero[]&gt; &#123;  return this.http.get&lt;Hero[]&gt;(this.heroesUrl)    .pipe(      tap(heroes &#x3D;&gt; this.log(&#96;fetched heroes&#96;)),      catchError(this.handleError(&#39;getHeroes&#39;))    ) as Observable&lt;Hero[]&gt;;&#125;\nBehaviorSubjectSubject 的作用是实现 Observable 的多播。由于其 Observable execution 是在多个订阅者之间共享的，所以它可以确保每个订阅者接收到的数据绝对相等。不仅使用 Subject 可以实现多播，RxJS 还提供了一些 Subject 的变体以应对不同场景，那就是：BehaviorSubject、ReplaySubject 以及 AsyncSubject。\n\nBehaviorSubject 的特性就是它会存储“当前”的值。这意味着你始终可以直接拿到 BehaviorSubject 最后一次发出的值const subject &#x3D; new Rx.BehaviorSubject(Math.random());&#x2F;&#x2F; 订阅者 Asubject.subscribe((data) &#x3D;&gt; &#123;  console.log(&#39;Subscriber A:&#39;, data);&#125;);subject.next(Math.random());&#x2F;&#x2F; 订阅者 Bsubject.subscribe((data) &#x3D;&gt; &#123;  console.log(&#39;Subscriber B:&#39;, data);&#125;);subject.next(Math.random());\ntoPromise deprecatedRxjs v8版本后toPromise方法弃用， 原因基于Observable与Promise前后返回值不一致的issueRxJS heads up: toPromise is being deprecated\n曾常使用的public async loadCategories() &#123;  this.categories &#x3D; await this.inventoryService    .getCategories()    .toPromise()&#125;变更为import &#123; lastValueFrom &#125; from &#39;rxjs&#39;;...public async loadCategories() &#123;  const categories$ &#x3D; this.inventoryService.getCategories();  this.categories &#x3D; await lastValueFrom(categories$);&#125;rxjs 6中被废弃的toPromise\n\nThe lastValueFrom is almost exactly the same as toPromise() meaning that it will resolve with the last value that has arrived when the Observable completes, but with the difference in behavior when Observable completes without emitting a single value. When Observable completes without emitting, toPromise() will successfully resolve with undefined (thus the return type change), while the lastValueFrom will reject with the EmptyError. Thus, the return type of the lastValueFrom is Promise, just like toPromise() had in RxJS 6.lastValueFrom几乎与toPromise() 一个意思，在Observable complete的时候，lastValueFrom会带着Observable最后一个产生的值resolve，但是不同之处在于Observable不带值complete的情况下。当Observable不产生值并且complete时，toPromise方法会成功resolve为undefined（也就是返回类型改变了，不再是T），但是lastValueFrom会带着EmptyErrorreject。因此，就如同在RxJS 6里一样，它的返回类型是Promise。\nHowever, you might want to take the first value as it arrives without waiting an Observable to complete, thus you can use firstValueFrom. The firstValueFrom will resolve a Promise with the first value that was emitted from the Observable and will immediately unsubscribe to retain resources. The firstValueFrom will also reject with an EmptyError if the Observable completes with no values emitted.然而，你可能不等Observable complete，想要使用其第一个生产的值，因此可以用firstValueFrom。firstValueFrom会将Observable第一个生产的值resolve并且立刻unsubscribe保存该值。firstValueFrom也会在Observable没有值产生而complete的情况下带着 EmptyErrorreject。\n\n"},{"title":"关系型数据库和非关系型数据库","url":"/qqsnote/2019/08/19/SQLndNoSQL/","content":"非关系型数据库来自Mongodb开发者的话，出自知乎\n\n「让开发者更高效」概括了 MongoDB 相较于关系型数据库带来的全部价值。这要放在最近十年整个行业的大背景下理解。软件行业的工资水平是出了名得高。这意味着软件开发的成本中，人力成本已经超越了硬件成本，成为成本里的大头。曾经长周期、瀑布式的开发流程被强调快速迭代的开发流程所替代。所有这些，加上你经常听说的热词，比如敏捷开发，微服务，DevOps，都指向「让开发者更高效」。这一背景下，基于关系表的关系型的数据模式也被灵活的非关系型数据模式替代。\n\n使用文档模型文档模型与面向对象的数据表达方式更相似更自然。与关系型数据库中表结构不同，文档中可任意嵌入数组和子文档，就像程序中的数组和成员变量一样。这是关系型数据库三范式不允许的。但实际中我们经常看到一对多和一对一的数据。比如，一篇博客文章的 Tag 列表作为文章的一部分非常直观，而把 Tag 与文章的从属关系单独建立一张关系表就不那么自然。再比如，一个订单下面的收货地址，包括省、市、区、街道和门牌，作为一个子文档，与订单的信用卡地址很容易区分开。更方便的是，嵌入的数组和子文档之上可以直接建立索引，比如我可以很快找到所有 Tag 包含 MongoDB 的文章。\n性能在关系数据库中，为了满足一个查询，多个表的数据都要参与 Join，每一个表都对应着磁盘的一次读取。这和数据放在一个地方，一次读完，当然完全不同。更简单的数据访问模式也让开发者更容易理解数据库的性能表现，尤其是当涉及到索引时。\n灵活关系数据库，常见的运维问题是给已有数据加一个新的属性，从数据表到应用数据层都要改。尽管有些工具可以把它自动化，这仍然是一个复杂的工作，尤其是更新产品线上数据库的时候。MongoDB 没有定义 Schema（模式）的话，就不需要改动数据库，只需要在应用层做必要的改动。另一个问题是，纯粹业务需要的自定义属性，如不同商品的各种特性，我能理解的是在商品筛选的时候，这些特性可能临时成为区分用的指标，产品这个表应该怎么设计？最简单的方案，是把每个可能的属性都变成单独一列，当然这个方案不能扩展。另一个例子，一个通讯录允许用户随意添加新的联系方式，你有 Facebook，他有 Twitter。一种方案是在程序里把所有自定义属性序列化，比如用 JSON 放到同一字段里。另一种方案，叫做 Entity-attribute-value Model，把自定义属性和他们的数据类型，进一步抽象，增加关系表来表现。这时，相比这些复杂方案，MongoDB 没有 Schema 的优点就显现出来了。\n扩展数据一台机器放不下了，就需要 sharding（分片）把它放到几台机器上去。分片是 MongoDB 多年以来的原生功能，与 MongoDB 其他功能高效整合。例如，分片集群中一个复杂的聚合查询会自动地根据 Shard Key（片键）分配到多个结点上运行，尽可能将计算任务下推到数据结点上，最后在一个结点上聚合所有结点的结果。分片还可以在各个结点间自动迁移数据，均衡其数据量。为了升级数据库容量，相较于关系型数据库分库分表需要同时改动应用和数据库，MongoDB分片的运维也简单很多，能够做到对应用透明。我们希望即使机器硬件有问题，数据也不要丢，服务不受影响。分片后机器更多，任一机器出问题的概率也就更高。Replication 复制解决了这个问题。它把同一份数据实时地复制到多个结点，自动地在其中切换。MongoDB 的商业客户中，不论规模大小，使用复制集已经成了一个标准，因为数据丢失的代价远大于冗余机器的成本。\n关系型数据库第一范式实体中的某个属性不能有多个值或者不能有重复的属性。即要求数据库表的无重复列，同一列不能有多个值。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的多个属性构成，新实体与原实体之间为一对多关系\n第二范式非主属性完全依赖于主关键字。经典的例子是考察一个学生在某门课程中的信息，以（学号，课程）为主关键字的话，考察成绩、教室、教师、上课时间等都没有问题，考察教材时，因为教材应该仅依赖课程，考察学生信息（姓名、性别、专业），因为学生信息只依赖学生。这里存在违反第二范式的隐患。上述表大致为serialNo|姓名|专业|上课时间|上课地点|任课教授|资料|成绩 :———|:—:|:—:|:—:|:—:|:—:|:—:|:—: 120022001|王丫蛋|声乐|周三|12教102|Professor Steven|人教版|90 120022201|李铁锤|机械|周四|11教412|Professor Johnson|人教版|75 360022201|李铁锤|机械|周五|12教308|Professor Hassan|人教版|75 首先，调整部分依赖的字段会很麻烦：因考研大纲修改，开课改用外研社教材。需修改大量记录，李铁锤改名李婉如，修改大量记录，即数据冗余 其次，学校新设电子竞技课程，指定了教材，尚未有学生选课，数据是写不进去的，即插入异常 然后，哪天这门课程被教育部指定有悖社会主义核心价值体系，学校偷偷删除了所有选课记录，此时导致表中的学生信息大量遗失，即删除异常 因此应有课程-教材关系表 学号-学生信息关系表\n第三范式符合第二范式的关系模式（具备必要的关系表）中，不应出现依赖于非主属性的属性例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。即消除了传递依赖\nBCNF根据候选键关系进一步消除传递依赖（没看懂）\n第四范式满足BCNF，属性不应含有多值，如联系方式相关字段的设计\n","categories":["数据库"],"tags":["NoSQL"]},{"title":"用户密码应该如何存储","url":"/qqsnote/2020/03/20/SavePassword/","content":"\n风险一 用户数据库泄露导致用户密码泄露风险二 网站管理人员、数据库管理员获取用户密码\n\n如何安全的存储密码要点如下\n\n加密（对称加密）存储无法防止风险二\n通用的以hash（单向散列算法如md5）获取的 digest（摘要）无法还原完整的原数据，但是存在rainbow table的隐患\n\n\nrainbow table: 多数人所使用的密码为常见的组合，攻击者可以将所有密码的常见组合进行单向哈希，得到一个摘要组合, 然后与数据库中的摘要进行比对即可获得对应的密码(QQs理解的是，这里的密码或许与用户密码并不完全一致，但是可以通过网站的摘要核对)。这个摘要组合也被称为rainbow table。在当今计算机处理能力下，这种破译方式是可行而且可取的。\n在线彩虹表\n\n\n\n\n\n明文\n摘要(32bit MD5)\n\n\n\n\n111111\n96e79218965eb72c92a549dd5a330112\n\n\n123456\nE10ADC3949BA59ABBE56E057F20F883E\n\n\n000000\n670b14728ad9902aecba32e22fa4f6bd\n\n\n…\n…\n\n\n\n\n\nSalted Hash 改进的单项hash算法，明文密码混入“随机因素“，然后进行单向哈希后存储，其结果是rainbow table因salt不同而不同\n  QQs按：做到这个份上，应该足够安全了，然而据说随着显卡并行计算能力的发展，存在破解出rainbow table的可能，我想可能是暴力破解salt。因此有了Salted Hash的各种改进方案\n\n慢哈希 如bcrypt，迭代执行多次hash运算，现实是增加了计算时间，使得暴力破解实际不可行\n\n\n如设置 bcrypt 计算一次需要 0.5 秒，遍历 6 位的简单密码，需要的时间为：((26 * 2 + 10)^6) / 2 秒，约 900 年。\n\nbcrypt\n文章略老，基于以上原理，单向hash算法有了更多的发展\n","categories":["算法"],"tags":["加密"]},{"title":"Stable Diffusion 和 ComfyUI","url":"/qqsnote/2023/03/08/StableDiffusion/","content":"原理\nStable Diffusion is a latent text-to-image diffusion model. Thanks to a generous compute donation from Stability AI and support from LAION, we were able to train a Latent Diffusion Model on 512x512 images from a subset of the LAION-5B database. Similar to Google’s Imagen, this model uses a frozen CLIP ViT-L/14 text encoder to condition the model on text prompts. With its 860M UNet and 123M text encoder, the model is relatively lightweight and runs on a GPU with at least 10GB VRAM. \n\nQQs按：Stable Diffusion并非特定程序，而是一种文生图扩散模型，所谓扩散模型大致是将语意或原图，人为加入随机种子并采样，从局部要素发散以匹配学习过的素材特征，从而生成完整图像。Stability AI是推出Stable Diffusion模型的创业公司，LAION（Large-scale Artificial Intelligence Open Network）是一家非营利组织，成员来自世界各地，旨在向公众提供大规模机器学习模型、数据集和相关代码。这里需要指出的是，由于训练素材大多是512x512的小尺寸图像，使用文生图不宜创建太大尺寸，否则会被算法认为是多图拼接，欲生成大尺寸图像应由计算结果通过高清插值插件扩充。\n通俗理解扩散模型\n大白话讲解扩散模型\nwebuiStable Diffusion Webui 为方便调用模型接口制作了图形化的交互界面 \nenv requirement:\n\nPython3.10models\nGFPGAN 腾讯开源的人像修复算法\nVAE (Variational Auto-Encoder 变分自编码器) 修复图片中的某些部分,例如修复人脸图片中的眼睛，或者可以理解为一种滤镜\nLoRA (Low-Rank Adaptation of Large Language Models) 自然语言处理大模型的低秩(Low-Rank)适应性版本(Adaptation)\nDeepBooru\n\nLoRA什么是LoRA模型自然语言大模型参数庞大(如GPT参数量超过千亿)，训练成本太高，因此LoRA采用了一个办法，仅训练低秩矩阵（low rank matrics），使用时将LoRA模型的参数注入（inject）SD模型，从而改变SD模型的生成风格，或者为SD模型添加新的人物/IP。\nvastagskorean doll\nnagetive prompt\npaintings, sketchers, (worst quality:2), (low quality:2), (normal quality:2), lowres, normal quality, ((monochrome)), ((grayscale)), skin spots, acnes, skin blemishes, age spot, glans\ntroubleshooting\nnot enough GPU memory@echo offset PYTHON&#x3D;set GIT&#x3D;set VENV_DIR&#x3D;set COMMANDLINE_ARGS&#x3D; --lowvram --no-half --precision full --no-half-vae --opt-sub-quad-attention --opt-split-attention-v1 --autolaunch call webui.batNo python at “D:\\Program Files\\Anaconda3\\env\\py310\\Python.exe”删除项目env下除Libs外的所有文件 重新执行webui.bat\n资源Stable Diffusion 提示词入门指南基础模型库：C站 Huggingface 出自魔法学院文章\n\nComfyUIrecommended Python3.12！对Stable Diffusion相关工具链的进一步封装，提供工作流编辑。GitHubgit clone https:&#x2F;&#x2F;github.com&#x2F;comfyanonymous&#x2F;ComfyUI.git编辑extramodelpaths.yaml文件以访问Stable Diffusion Webui项目目录下的模型pip install torch torchvision torchaudio --extra-index-url https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;cu126pip install -r requirements.txtpython main.py --listen&#x3D;127.0.0.1 --port&#x3D;8188其中torch 2.5GB下载较久 源地址 https://download.pytorch.org/whl/cu126/torch-2.6.0%2Bcu126-cp312-cp312-win_amd64.whl  下载后本地安装命令如pip install D:\\Download\\torch-2.6.0+cu126-cp312-cp312-win_amd64.whl修改haggingface.io使用国内镜像：D:\\Software\\Anaconda3\\envs\\py312\\Lib\\site-packages\\huggingface_hub__init.py脚本末尾添加os.environ[&#39;HF_ENDPOINT&#39;] &#x3D; &#39;https:&#x2F;&#x2F;hf-mirror.com&#39;ComfyUI中文手册\nSD3 SD3.5 Flux.1checkpoints可见载入我们的大模型的label写的是checkpoints, 即所谓大模型放在model/checkpoints目录, checkpoints常见于RPG游戏被认为是存档点，对于训练复杂的模型，也需要记录阶段性的实验结果，以方便之后的运算基于此进行。Keras Docs对checkpoints的解释 from《理解checkpoints》：\n\nThe architecture of the model, allowing you to re-create the model\nThe weights of the model\nThe training configuration (loss, optimizer, epochs, and other meta-information)\nThe state of the optimizer, allowing to resume training exactly where you left off.\n\ncheckpoints是基础模型的参数定制\ncontrolnetothers清华大学第六弹：AIGC发展研究3.0\n人物替换","tags":["AI"]},{"title":"Technical Artist","url":"/qqsnote/2024/06/27/TechnicalArtist/","content":"Tech Art\n方向\n\n渲染向 自研/二开引擎 材质 光追 抗锯齿\n动画 动作绑定 \n特效 粒子\n管线向 流程 易用性开发\n美术\n\nsketchfab模型库\nunity -&gt; ASE -&gt; shader\n上海F4 米哈游 叠纸 莉莉丝 鹰角\nUE vs Unity\n图形质量和性能：Unreal Engine在图形渲染和视觉效果方面具有较高的品质，提供更高的渲染质量和更好的性能。Unity也可以实现出色的图形效果，但相较而言，Unreal Engine在这方面更具优势。\n编程语言和学习曲线：Unity使用C#作为主要的编程语言，而Unreal Engine使用C++和Blueprints。C++相对较难学习，而Blueprints提供了一种无需编写代码即可创建逻辑的可视化编程方式。因此，Unity在学习曲线上可能更易上手。\n跨平台支持：Unity在跨平台支持方面更为出色，可以轻松发布到多个平台，包括移动设备、PC和主机。Unreal Engine也支持多种平台，但在跨平台发布上可能比Unity稍显复杂。\n社区和文档：Unity拥有庞大的社区和丰富的文档资源，可以方便开发者学习和解决问题。Unreal Engine的社区也很活跃，但相较而言，Unity的资源更为丰富。\n\n总体来说，选择使用Unreal Engine还是Unity取决于项目的需求和开发者的个人偏好。如果追求高质量的图形效果和性能，以及想要更多的定制和控制权，那么Unreal Engine可能更适合。如果希望快速上手、轻松发布到各种平台，并且喜欢使用C#编程语言，那么Unity可能更适合。\n"},{"title":"TensorFlow","url":"/qqsnote/2024/06/27/TensorFlow/","content":""},{"title":"three.js中的材质","url":"/qqsnote/2025/07/27/ThreeJS-Materials/","content":"1. MeshStandardMaterial\n用途：基于物理渲染（PBR），适用于追求真实感的场景，支持金属度、粗糙度、环境光遮蔽（AO）、法线贴图等。\n优势：高度逼真，支持复杂光照模型，适合高质量渲染。\n缺点：计算开销较大，不适合性能敏感的场景。2. MeshLambertMaterial\n用途：基于 Lambert 反射模型，是一种简化的漫反射材质，不考虑高光或复杂反射。\n优势：计算简单，性能好，适合非金属、低光要求的物体。\n缺点：缺乏真实感，不支持法线贴图、金属度等高级特性。3. MeshPhongMaterial\n用途：基于 Phong 反射模型，支持高光反射，可以模拟塑料、漆面等材质。\n优势：比 Lambert 更真实，支持高光和法线贴图。\n缺点：不是基于物理的渲染，效果不如 PBR 自然。4. MeshDepthMaterial\n用途：不显示颜色，只渲染深度信息（相机到物体的距离） QQs按：接近近投影面(camera.near)变明亮反之变暗 适合做雾效 寂静岭阴森视距。\n优势：常用于后期处理、阴影生成、深度图分析等。\n缺点：不适用于常规物体渲染。5. MeshNormalMaterial\n用途：显示法线方向，用于调试或特殊视觉效果。\n优势：便于检查模型的法线是否正确。\n缺点：无法用于真实渲染。\n\n性能与适用场景的权衡\n\n性能优化：在移动端或低性能设备上，使用 MeshLambertMaterial 或 MeshBasicMaterial 可以显著提高渲染性能，而 MeshStandardMaterial 由于其复杂的光照计算，可能会造成帧率下降。\n\n特殊效果：例如，MeshDepthMaterial 可用于实现深度边缘检测、雾效或自定义的后期处理效果，这些是 MeshStandardMaterial 无法直接实现的。\n\n艺术风格：某些风格化渲染（如卡通渲染）更适合使用 MeshToonMaterial，而不是 PBR 材质。\n\n\n三、兼容性与历史原因\nThree.js 作为一个成熟的 3D 渲染库，需要兼容多种渲染管线和设备。一些材质（如 MeshLambertMaterial 和 MeshPhongMaterial）在早期版本中就已经存在，它们为不支持 PBR 的设备或项目提供了替代方案。\n在 WebGL 1.0 环境下，某些高级特性（如 PBR）可能不被完全支持，此时需要使用更简单的材质。\n\n\n四、实际开发中的选择建议\n\n\n\n材质类型\n适用场景\n是否支持贴图\n性能\n\n\n\n\nMeshStandardMaterial\n高质量渲染、PBR 场景\n支持所有贴图\n较低\n\n\nMeshLambertMaterial\n简单漫反射、低性能设备\n仅支持漫反射贴图\n较高\n\n\nMeshPhongMaterial\n高光材质、塑料效果\n支持高光、法线贴图\n中等\n\n\nMeshDepthMaterial\n深度分析、后期处理\n不支持颜色贴图\n高\n\n\nMeshNormalMaterial\n法线调试、特殊效果\n不支持颜色贴图\n高\n\n\n\n\n\nroughMap vs displacementMap前者是PBR即作用于光线反射 后者是作用于顶点位移\n","tags":["Three.js"]},{"title":"React-Three-Fiber","url":"/qqsnote/2025/07/27/ThreeJS-R3F/","content":"@React-three/fiber开箱即用(out of box) 组件化场景对象如\\  \\  \\\nnpm i three @react-three/fiber\n额外的，transpile in Next.js, set in next.config.js:\ntranspilePackages: [&#x27;three&#x27;],\nReact Native中需要expo-gl\n# Automatically installexpo install expo-gl# Install NPM dependenciesnpm install three @react-three/fiber\nset Metro boundle tool if use loader, gltf and so on\n// metro.config.jsmodule.exports = &#123;  resolver: &#123;    sourceExts: [&#x27;js&#x27;, &#x27;jsx&#x27;, &#x27;json&#x27;, &#x27;ts&#x27;, &#x27;tsx&#x27;, &#x27;cjs&#x27;, &#x27;mjs&#x27;],    assetExts: [&#x27;glb&#x27;, &#x27;gltf&#x27;, &#x27;png&#x27;, &#x27;jpg&#x27;],  &#125;,&#125;\n简单的栗子\nimport React from &#x27;react&#x27;import &#123; Canvas &#125; from &#x27;@react-three/fiber&#x27;const App = () =&gt; (  &lt;Canvas&gt;&#123;/* 相当于初始化的Scene */&#125;    &lt;pointLight position=&#123;[10, 10, 10]&#125; /&gt;    &lt;mesh&gt;      &lt;sphereGeometry /&gt;      &lt;meshStandardMaterial color=&quot;hotpink&quot; /&gt;    &lt;/mesh&gt;  &lt;/Canvas&gt;)\n@React-three/drei@react-three/drei 是一个工具包（Utility Library），为 @react-three/fiber 提供了一系列高阶组件和实用函数，比如加载模型(useGLTF)、添加环境光(Environment)、设置相机控制(OrbitControls)等。 德语单词“Drei”，意思是“三”从零探索@react-three/fiber @React-three/drei\nLevanpm install leva@latest --save-dev\nimport &#123; useControls &#125; from &#x27;leva&#x27;const color = useControls(&#123;  value: &#x27;green&#x27;,&#125;)&lt;Canvas&gt;  &lt;color attach=&quot;background&quot; args=&#123;[color.value]&#125; /&gt;&lt;/Canvas&gt;\n#","tags":["图形学","Three.js","R3F"]},{"title":"Three.js RayCaster","url":"/qqsnote/2025/08/28/ThreeJS-Raycaster/","content":"Three.js Doc: RayCaster\nAI coding demo painting on texture&#x2F;&#x2F; --- 创建模型和画布纹理 ---const canvas &#x3D; document.createElement(&#39;canvas&#39;);canvas.width &#x3D; 1024;canvas.height &#x3D; 1024;const context &#x3D; canvas.getContext(&#39;2d&#39;);context.fillStyle &#x3D; &#39;#ffffff&#39;;context.fillRect(0, 0, canvas.width, canvas.height);const texture &#x3D; new THREE.CanvasTexture(canvas);texture.minFilter &#x3D; THREE.LinearFilter;texture.magFilter &#x3D; THREE.LinearFilter;const material &#x3D; new THREE.MeshStandardMaterial(&#123;    map: texture,    roughness: 0.8,    metalness: 0.2,&#125;);const geometry &#x3D; new THREE.SphereGeometry(2, 64, 64);const sphere &#x3D; new THREE.Mesh(geometry, material);scene.add(sphere);&#x2F;&#x2F; --- 射线投射和鼠标事件 ---const raycaster &#x3D; new THREE.Raycaster();const mouse &#x3D; new THREE.Vector2();let isPainting &#x3D; false;function onMouseMove(event) &#123;    mouse.x &#x3D; (event.clientX &#x2F; window.innerWidth) * 2 - 1;    mouse.y &#x3D; -(event.clientY &#x2F; window.innerHeight) * 2 + 1;    if (isPainting) &#123;        paint();    &#125;&#125;function onMouseDown(event) &#123;    isPainting &#x3D; true;    paint();&#125;function onMouseUp(event) &#123;    isPainting &#x3D; false;&#125;window.addEventListener(&#39;mousemove&#39;, onMouseMove);window.addEventListener(&#39;mousedown&#39;, onMouseDown);window.addEventListener(&#39;mouseup&#39;, onMouseUp);&#x2F;&#x2F; --- 核心绘制函数 ---function paint() &#123;  raycaster.setFromCamera(mouse, camera);  const intersects &#x3D; raycaster.intersectObject(sphere);  if (intersects.length &gt; 0) &#123;    const intersect &#x3D; intersects[0];    const uv &#x3D; intersect.uv;    const x &#x3D; uv.x * canvas.width;    const y &#x3D; (1 - uv.y) * canvas.height;    const brushRadius &#x3D; 20;    context.fillStyle &#x3D; &#39;#ff0000&#39;; &#x2F;&#x2F; 红色笔刷    context.beginPath();    context.arc(x, y, brushRadius, 0, Math.PI * 2);    context.fill();    texture.needsUpdate &#x3D; true;  &#125;&#125;\n","tags":["Three.js"]},{"title":"Three.js","url":"/qqsnote/2025/07/27/ThreeJS/","content":"Rendererinit scene\nconst canvas = document.createElement(&#x27;canvas&#x27;)const sizes = &#123;width: this.$refs.container.clientWidth,height: this.$refs.container.clientHeight&#125;canvas.width = sizes.width;canvas.height = sizes.height;this.$refs.container.appendChild(canvas);// 创建3D场景对象Sceneconst scene = new THREE.Scene();console.log(scene); // Geometryconst geometry = new THREE.SphereGeometry(5, 32, 32);const material = new THREE.MeshBasicMaterial(&#123;color: &#x27;#aaa&#x27;, wireframe:true&#125;)// Meshconst mesh = new THREE.Mesh(geometry, material)mesh.position.set(0, 0, -10);scene.add(mesh)// 创建相机对象Camera// 45-75 是透视投影相机建议的视角范围fov// 视角比例aspect w/h// 投影近平面// 投影远平面const camera = new THREE.PerspectiveCamera(75, sizes.width/sizes.height, 0.1, 1000);scene.add(camera);const renderer = new THREE.WebGLRenderer(&#123;canvas: canvas&#125;);renderer.render(scene, camera);\nCaution! 虽设置canvas尺寸 但canvas初始化renderer时 其尺寸会受到影响 其结果仍使canvas超出父容器 出现滚动条应使用renderer.setSize\nconst renderer = new THREE.WebGLRenderer()renderer.setSize(container.current.clientWidth, container.current.clientHeight)container.current.appendChild(renderer.domElement)\n另外onResize要加防抖 overflow hidden该加还是得加\nControlsimport &#123; OrbitControls &#125; from &#x27;three/addons/controls/OrbitControls.js&#x27;;...// Add OrbitControlsconst controls = new OrbitControls(camera, renderer.domElement)// controls.update() must be called after any manual changes to the camera&#x27;s transformcamera.position.set( 0, 20, 100 );controls.update();// camera 移动是重复的render过程 需要requestAnimationFramefunction animate() &#123; requestAnimationFrame( animate ); // required if controls.enableDamping or controls.autoRotate are set to true controls.update(); renderer.render( scene, camera );&#125;\nMesh和Geometry两者都可以rotate, Geometry是”是什么(what)” Mesh是”如何(how)”\nAnimationtick()&#123;    mesh.rotaion.y += 0.05    console.log(&quot;tick tack&quot;)    requestAnimationFrame(tick)&#125;\ntick  调用频率是帧速率相关的 可以用Date或者THREE.Clock\nconst clock = new THREE.Clock()const animate = () =&gt; &#123;    const t = clock.getElapsedTime()    group.rotation.y=0.5*Math.PI*t    requestAnimationFrame(animate);    renderer.render(scene, camera);&#125;;animate();\nIssue： 单纯调用gsap无效 需要配合requestAnimationFrame和render方法才能使模型运动生效\ngsap.to(group.position, &#123;    duration:1,    delay:1,    x:20&#125;)gsap.to(group.position, &#123;    duration:1,    delay:2,    x:0&#125;)   const animate = () =&gt; &#123;        requestAnimationFrame(animate);        renderer.render(scene, camera);&#125;;animate();\nCamera正交相机\nconst camera = new THREE.OrthographicCamera(    -20*container.current.clientWidth/container.current.clientHeight, /*左边界*/    20*container.current.clientWidth/container.current.clientHeight,/*右边界*/    20,/*上边界*/    -20,/*下边界*/    0.1,    1000)\n相机环绕\n // mouse rotatedocument.addEventListener(&#x27;mousemove&#x27;, (e)=&gt;&#123;    if(!container.current) return    const x = (e.x - container.current.offsetLeft)/container.current.clientWidth - 0.5;    const y = -(e.x - container.current.offsetTop)/container.current.clientHeight + 0.5;    // 圆形轨迹的坐标呈正弦/余弦往复    camera.position.z = Math.cos(x*Math.PI*10)*20    camera.position.x = Math.sin(x*Math.PI*10)*20    // 注意！ 相机位置移动时 会从原目标移开 所以重新设置lookAt    camera.lookAt(scene.position)    renderer.render(scene, camera)&#125;)\ncamera controls\n\nOrbitControl\nDeviceOrientationControls\nFirstPersionControls\nFlyControls\nPointLockControls\nTrackballControls\n\ndebug tool:dat.gui (out of date) -&gt; lil-guicontrol panelcontrolkitGuifyOui\n纹理映射const loader = new THREE.TextureLoader()const texture = loader.load(&#x27;./assets/images/cover/cover-6.webp&#x27;,    (txt)=&gt;&#123;        console.log(txt)    &#125;,    ()=&gt;&#123;        console.log(&#x27;loading&#x27;)    &#125;,    (e)=&gt;&#123;        console.error(e)    &#125;)// 设置纹理在U轴（水平方向）和V轴（垂直方向）上的重复次数。texture.repeat.x = 2texture.repeat.y = 2// 设置纹理在U轴（S方向）和V轴（T方向）上的包裹模式（wrap mode）。// THREE.MirroredRepeatWrapping接缝处镜像翻转texture.wrapS = THREE.MirroredRepeatWrappingtexture.wrapT = THREE.MirroredRepeatWrappingtexture.offset.x = 0.5// 素材逆时针旋转Π/2texture.rotation = Math.PI * 0.5texture.center.x = 1texture.center.y = 1// 放大时 线性平滑texture.magFilter = THREE.LinearFilter// 缩小时 取相邻两个mip层做线性平滑texture.minFilter = THREE.LinearMipmapLinearFilterconst cubeMaterial = new THREE.MeshBasicMaterial(&#123;    // color: 0xff0000,     // wireframe:true    map: texture&#125;)const sphereGeometry = new THREE.SphereGeometry(5, 32, 32)const ball = new THREE.Mesh(sphereGeometry, cubeMaterial)\nmaterial properties:\n\ntransparent true/false\nopacity 透明度0~1\nwireframe 显示线框\nside 材质应用到外侧(THREE.FrontSide)或者内侧(THREE.BackSide)\nflatshading\n\nmatcap\nenvironmentMap and HDRI(High Dynamic Range Imaging 高动态范围成像)\n在宏大场景中，计算周围环境在物体上的倒影是巨大的运算负担，于是聪明的图形工作者想到了将环境贴图直接贴在反光物体上的想法\n在Three.js中支持将立方体环境的图像映射到物体上 常用HDRI生成立方环境贴图的免费网站：https://polyhaven.com/hdris 原HDRIHeaven\n或使用blender工具\n3D TextTextBufferGeometry\nfacetype.js 转换.ttf字体成jsonQQs: 包含中文的字体转换后出现问题，json中以‘字-坐标’作key-value，中文(甚至字母和数字)转换失败在json中显示为方框，于是输入的字无法找到映射。loader导入这样的字体会报 character “xxx” does not exists in font family XXX\nimport &#123; FontLoader &#125; from &#x27;three/examples/jsm/loaders/FontLoader.js&#x27;;import &#123; TextGeometry &#125; from &#x27;three/examples/jsm/geometries/TextGeometry&#x27;;// textconst fontLoader = new FontLoader()fontLoader.load(&#x27;./assets/font/Kristen ITC_Regular.json&#x27;, (font) =&gt; &#123;    const textGeometry = new TextGeometry(        &#x27;Hello 3D&#x27;,        &#123;            font,            size: 2,            depth:0.2, /** 原height属性 */            curveSegments: 12,            bevelEnabled: true, /**斜角 */            bevelThickness: 0.3,            bevelSize: 0.2,            bevelOffset: 0,            bevelSegments: 5        &#125;    )    const textMaterial = new THREE.MeshBasicMaterial(&#123; color: &#x27;blue&#x27;, wireframe:true &#125;)    const textMesh = new THREE.Mesh(textGeometry, textMaterial)    //textMesh.position.set(0,0,0)    scene.add(textMesh)&#125;)```js3D Text默认position位于文字起点 移动到中心```jstextGeometry.translate(    - (textGeometry.boundingBox.x - 0.2)*0.5, /** 减去倒角 */    - (textGeometry.boundingBox.y - 0.2)*0.5,    - (textGeometry.boundingBox.z - 0.3)*0.5)\n阴影粒子可视化优化Three.js常见性能问题和内存泄漏\n\n及时dispose释放资源\n减少segment\n复用geometry实例\n优化requestAnimationFrame 降低帧率和简化回调\n\nwebGPUThree.js 支持webGPU,使用webGPU需要浏览器对该功能的支持 见openGL\n对于没有原生支持的浏览器可以通过Polyfill实现\n","tags":["Three.js","WebGL"]},{"title":"TransactSQL","url":"/qqsnote/2020/05/19/TransactSQL/","content":"\nTransact-SQL（又称T-SQL），是在Microsoft SQL Server和Sybase SQL Server上的ANSI SQL实现，与Oracle的PL/SQL性质相近（不只是实现ANSI SQL，也为自身数据库系统的特性提供实现支持），当前在Microsoft SQL Server和Sybase Adaptive Server中仍然被使用为核心的查询语言。\n\n下文涉及的函数/方法限T-SQL使用，在MySQL和Oracle中未必兼容\n存储过程的查询条件待改进的一种条件拼接：SELECT * FROM LocalExport where SSO&#x3D;IIF(@SSO is null, SSO, @SSO)and SN&#x3D;IIF(@SN is null, SN, @SN)T-SQL方法  IIF(expression, return value when ture, return value when false)待改进是因为存在下述bug：当缺省SN过滤条件（即@SN为null）时，记录中SN列的值为空的行不会查出，即null=null为false可以这么表达SELECT * from LocalExport where (ISNULL(@SSO, &#39;&#39;)&#x3D;&#39;&#39; OR SSO&#x3D;@SSO)and (ISNULL(@SN, &#39;&#39;)&#x3D;&#39;&#39; OR SN&#x3D;@SN)动态SQL语句SET @SQL&#x3D;&#39;select * from LocalExport where 1&#x3D;1&#39;;IF  @SSO is not nullBEGIN    SET @SQL&#x3D;@SQL+&#39; AND SSO&#x3D;@SSO&#39;ENDIF  @SN is not nullBEGIN    SET @SQL&#x3D;@SQL+&#39; AND SN&#x3D;@SN&#39;ENDEXEC sp_executesql  @SQL \n","categories":["数据库"],"tags":["SQL_Server"]},{"title":"Trea solo","url":"/qqsnote/2025/11/01/Trea/","content":"\n你是一位专业的程序员，请帮我开发《学习英雄-AI问答引导式学习》微信小程序。用户可以自主设置一个想学习(或测验)的主题，由AI围绕主题生成若干个有趣的知识问答卡片，通过闯关答题的形式引导用户更轻松愉快地掌握知识。\n请你基于最新的产品需求文档和技术架构文档进行开发，优先开发后端，确保可以正常运行(需润色)\n\n","categories":["人工智能"],"tags":["trea","大模型"]},{"title":"TypeScript_JsonMapping","url":"/qqsnote/2020/04/26/TypeScript-JsonMapping/","content":""},{"title":"TypeScript_Module","url":"/qqsnote/2023/07/07/TypeScript-Module/","content":"通常我们使用的module，其概念更接近命名空间(namespace)，module在自身作用域内运行，定义在一个module里的变量，函数，类等等在module外部不可见，使用export导出以便其他作用域import，从而访问module内部的变量\n导出模块\n如上所述，通过export关键字导出声明（如变量、函数、类、类型别名或接口）原声明添加export，即可在其他作用域import\n重命名 export { MyClass as A }\n\n外部模块","categories":["前端技术"],"tags":["TypeScript"]},{"title":"TypeScript","url":"/qqsnote/2019/05/20/TypeScript/","content":"QQs：TS相比ES————静态类型，代码的可读性和可维护性TS相比ES不只是静态类型，还有Class Interface Generics(泛型) Enum等辩证地看，也有它地缺点如学习成本，搭框架地额外成本，与js库的兼容性，额外的编译过程等官方Doc在线编译器\n调试方法一 npm install typescriptadd tsconfig.json&#123;    &quot;compilerOptions&quot;: &#123;        &quot;module&quot;: &quot;commonjs&quot;,        &quot;target&quot;: &quot;es5&quot;,        &quot;noImplicitAny&quot;: true,        &quot;outDir&quot;: &quot;.&#x2F;dist&quot;,        &quot;sourceMap&quot;: true    &#125;,    &quot;include&quot;: [        &quot;src&#x2F;**&#x2F;*&quot;    ]&#125;add .vscode/tasks.json&#123;    &#x2F;&#x2F; See https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;733558    &#x2F;&#x2F; for the documentation about the tasks.json format    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        &#123;            &quot;type&quot;: &quot;typescript&quot;,            &quot;tsconfig&quot;: &quot;tsconfig.json&quot;,            &quot;problemMatcher&quot;: [                &quot;$tsc&quot;            ],            &quot;group&quot;: &#123;                &quot;kind&quot;: &quot;build&quot;,                &quot;isDefault&quot;: true            &#125;        &#125;    ]&#125;Terminal—Run Task—Choose tsconfig.json\nadd .vscode/launch.json&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;launch&quot;,            &quot;type&quot;: &quot;node&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;dist&#x2F;main.js&quot;,            &quot;args&quot;: [],            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,            &quot;protocol&quot;: &quot;inspector&quot;        &#125;    ]&#125;Run Debugging(Choose ‘launch’, the name definited in the launch.json)方法二 npm i typescript node-tsadd tsconfig.js&#123;    &quot;compilerOptions&quot;: &#123;        &quot;module&quot;: &quot;commonjs&quot;,        &quot;target&quot;: &quot;es5&quot;,        &quot;noImplicitAny&quot;: true,        &quot;outDir&quot;: &quot;.&#x2F;dist&quot;,        &quot;sourceMap&quot;: true    &#125;,    &quot;include&quot;: [        &quot;src&#x2F;**&#x2F;*&quot;    ]&#125;add .vscode/launch.json&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;Current TS File&quot;,            &quot;type&quot;: &quot;node&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;node_modules&#x2F;ts-node&#x2F;dist&#x2F;_bin.js&quot;,            &quot;args&quot;: [                &quot;$&#123;relativeFile&#125;&quot;            ],            &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,            &quot;protocol&quot;: &quot;inspector&quot;        &#125;    ]&#125;\n基本类型\nnumber \nboolean\nstring\n[]\nenum\nany\nvoid\nnull 和 undefined\nnever \n\n关于枚举定义一组常量enum Direction &#123;    Up &#x3D; &quot;↑&quot;,    Down &#x3D; &quot;↓&quot;,    Left &#x3D; &quot;←&quot;,    Right &#x3D; &quot;→&quot;,&#125;类似map的用法switch(key)&#123;    case Direaction.Up:        console.log(&#39;direction is up&#39;);        break;    ...&#125;类似interface的用法， 如 function Foo(direct: Direaction)\n“类型谓词”function isFish(pet: Fish | Bird): pet is Fish &#123;    return (&lt;Fish&gt;pet).swim !&#x3D;&#x3D; undefined;&#125;定义类型保护函数isFish用以区分一个联合类型(Fish | Bird)的变量,依据是Fish类型存在swim属性其意义无非就是把下列代码if ((&lt;Fish&gt;pet).swim) &#123;    (&lt;Fish&gt;pet).swim();&#125;else &#123;    (&lt;Bird&gt;pet).fly();&#125;改为if (isFish(pet)) &#123;    pet.swim();&#125;else &#123;    pet.fly();&#125;多数情况下还是用 typeof 和 instanceof\nlet 和 const 同es6\nlet const 声明的变量只在当前代码块中有效\n\nfor (var i &#x3D; 0; i &lt; 10; i++) &#123;&#125;console.log(i); &#x2F;&#x2F;10\nfor(let j &#x3D; 0; j &lt; 10; j++) &#123;&#125;console.log(j);&#x2F;&#x2F; Error: j is not define\n\n以前需要立即执行表达式(IIFE)解决的问题for (var k &#x3D; 0; k &lt; 5; k++) &#123;    (function (k) &#123;      setTimeout(function () &#123;        console.log(k); &#x2F;&#x2F;输出0,1,2,3,4      &#125;,0);    &#125;)(k);&#125;for (let j &#x3D; 0; j &lt; 5; j++) &#123;    setTimeout(function () &#123;      console.log(j); &#x2F;&#x2F;输出0,1,2,3,4    &#125;,0);&#125;不存在变量提升console.log(foo); &#x2F;&#x2F; 输出undefinedconsole.log(bar); &#x2F;&#x2F; 报错ReferenceErrorvar foo &#x3D; 2;let bar &#x3D; 2;不允许重复声明\n暂时性死区\n\n即不允许在声明位置之前调用该变量\n\nconst 声明引用值不允许修改，然而const的对象内部状态是可以修改的。区分声明只读类型关键字readonly readonly GIPX &#x3D; 0x1a;\n\n解构\n接口\n鸭子类型interface LabelledValue\t&#123;\t\t    label: string; &#125;function printLabel(labelledObj:LabelledValue)\t&#123;\t\t    console.log(labelledObj.label); &#125;let myObj &#x3D; &#123;size: 10, label: &quot;Size 10 Object&quot;&#125;; printLabel(myObj);可见，参数对象并非实现接口，只需对外表现接口的特性\n\n另外，接口里的属性可以定义为非必须的interface SquareConfig &#123;     color?: string;    width?: number; &#125;\n\n定义可索引的类型interface StringArray &#123;    [index: number]: string;&#125;let myArray: StringArray; myArray\t&#x3D; [&quot;Bob&quot;, &quot;Fred&quot;];let myStr: string &#x3D; myArray[0];如上，是一个接口的定义，符合该接口的属性可以number类型为索引。\n\n另，索引亦可为string类型。注意当同时使用两种类型的索引，数字索引的返回值必须是字符串索引返回值类型的子类型。    这是因为当使用    number    来索引时，JavaScript会将它转换成    string    然后再去索引对象。    就是说用    100    （一个    number    ）去索引等同于使用    “100”    （一个    string    ）去 索引，因此两者需要保持一致。\ninterface 和 type：如上所述，interface是接口，是一种规范，简单的对功能的抽象。接口可以用extends扩展(栗子略了)type是类型, 多次声明的接口定义是扩展叠加的关系interface WidgetProps&#123;    click:any&#125;interface WidgetProps&#123;    drag:any&#125;CanWidgetProperty ： WidgetProps &#x3D; &#123;    click: handleClick;    drag:  handleDrag;&#125;type顾名思义是类型，可以是基础类型（或其组合，如用逻辑|的组合）的别名。与interface相比似乎更加固定、安全（不似interface灵活）\n实现多个接口：let person: Person &amp; AdditionalProperties\n类\n实现接口..\n\n es6是没有constructor的，可以再琢磨下js原型篇。 ts中，类是具有两个类型：静态部分的类型和实例的类型。静态部分是类定义本身，实例部分就是生成的类的对象 constructor 存在于类的静态部分 interface ClockConstructor &#123;    new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123;    tick();&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123;    return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123;    constructor(h: number, m: number) &#123; &#125;    tick() &#123;        console.log(&quot;beep beep&quot;);    &#125;&#125;class AnalogClock implements ClockInterface &#123;    constructor(h: number, m: number) &#123; &#125;    tick() &#123;        console.log(&quot;tick tock&quot;);    &#125;&#125;let digital &#x3D; createClock(DigitalClock, 12, 17);let analog &#x3D; createClock(AnalogClock, 7, 32);这个是官方示例代码。为了实现定义一个符合ClockInterface接口规范的createClock方法。而且应将符合ClockConstructor接口规范的类型作为返回值得类型\n泛型function identity&lt;T&gt;(arg: T): T &#123;     return arg; &#125;\n在es中class本质是函数，故class也可将泛型作为构造方法参数，并加以类型约束\ninfertype ParamType&lt;T&gt; &#x3D; T extends (param: infer P) &#x3D;&gt; any ? P : T;\ninfer表示P是待推断的参数类型，如T\nnever不会返回结果的类型，一直是while(true)的函数，或者一定会抛出异常的函数\n模块\nexport 和 import\nnamespace(存目)从js迁移参考TS Doc\n元组与数组的唯一区别是依次逐项指定了类型适用于特定的数据元结构，比较现实的场景如csv文件的rowconst newRow:[number,string,boolean] &#x3D; [1,&#39;老王&#39;,true]\n装饰器 Decorator装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息作为参数传入。\n\nimport &quot;reflect-metadata&quot;;const formatMetadataKey &#x3D; Symbol(&quot;format&quot;);function format(formatString: string) &#123;    return Reflect.metadata(formatMetadataKey, formatString);&#125;function getFormat(target: any, propertyKey: string) &#123;    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);&#125;\n这里用到了反射class Greeter &#123;    @format(&quot;Hello, %s&quot;)    greeting: string;    constructor(message: string) &#123;        this.greeting &#x3D; message;    &#125;    greet() &#123;        let formatString &#x3D; getFormat(this, &quot;greeting&quot;);        return formatString.replace(&quot;%s&quot;, this.greeting);    &#125;&#125;\n运行时变量属性未在类型声明中使typeScript 识别未声明的属性 除了parameter:any 有以下几种方法更好的做法\n\n重新声明中变量&#x2F;&#x2F; types.d.ts  import &#39;some-library&#39;;  declare module &#39;some-library&#39; &#123;      export interface Person &#123;          [key: string]: any; &#x2F;&#x2F; 添加索引签名          email?: string;     &#x2F;&#x2F; 添加可选属性      &#125;  &#125;\n类型断言let personWithTypeAssertion: Person &#x3D; &#123;name: &quot;John Doe&quot;,age: 30,additionalProperty: &quot;Some value&quot; &#x2F;&#x2F; TypeScript 不会报错&#125; as Person &amp; &#123; additionalProperty: string &#125;;\ntypescript-eslint见Typescript-ESLint\n\n面试必备typescript的特点 \n\n提供面向对面编程(OOP)的特性 如 类，接口，模块\n静态类型检查\nES6特性 箭头函数 变量声明等\n可选参数\n内置类型\n\n优点和技巧\n\n静态类型\n扩展名为.d.ts的Definition文件提供对现有JavaScript库（如Jquery，D3.js等）的支持。\n\ntroubleshooting\nfork-ts-checker-webpack-plugin error in undefined(undefined,undefined)\n\n该插件与typescript类型检查有关 该报错原因难以定位 修改typescript到旧版本解决场景：&quot;@craco&#x2F;craco&quot;: &quot;^6.0.0&quot;,&quot;@types&#x2F;node&quot;: &quot;^14.14.16&quot;,&quot;react&quot;: &quot;^17.0.1&quot;,&quot;typescript&quot;: &quot;4.1.3&quot;,\n","categories":["前端技术"],"tags":["TypeScript"]},{"title":"UIdesign","url":"/qqsnote/2021/04/27/UIdesign/","content":"https://www.canva.com/这个网站的404是一个拼图游戏，纯html img + css以及拖动实现\n"},{"title":"UILibrary","url":"/qqsnote/2024/03/26/UILibrary/","content":"Material UIBootstrapAnt DesignElastic UIElastic UI 框架 (EUI) 是 Elastic 使用的一个设计库，用于构建需要分享我们美学的内部产品。它分发 UI React 组件和静态资源，用于构建 Web 布局。使用高对比度、色盲安全调色板，并通过大多数辅助技术进行测试。可配置性足以满足各种环境的需求，同时保持品牌和低级别的一致性。\n作者：快跑啊小卢_链接：https://juejin.cn/post/7296345202238636072来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\nREAVIZREAVIZ 是一个模块化图表组件库，它原生利用 React 来渲染组件，同时在底层使用 D3js 进行计算。该库提供了一种简单的方法来开始创建图表，而无需牺牲定制能力。\nArcoDesignArcoDesign 是由字节跳动 GIP UED 团队和架构前端团队联合推出的企业级设计系统，打磨沉淀 3 年之后开源，ArcoDesign 与 TDesign 开源也就是前后脚的事，让我们通过这两套开源组件，看到大厂在前端完备的设计理念和工整的生产流程。这套 UI 库，基于 ArcoDesign 设计规范，Arco 同时提供了 React 和 Vue 两套 UI 组件库。\nSemi DesignSemi Design是由抖音前端团队，MED 产品设计团队设计、开发维护的设计系统。它作为全面、易用、优质的现代企业级应用解決方案，从字节各业务线的复杂场景提炼而来，服务字节内外部 10 万+用户。经过近两年的迭代，在各类不同形态的业务落地验证后，Semi Design 已成为跨部门级的基础设施，围绕组件库形成丰富的工具链和生态。\n","categories":["前端技术"],"tags":["UI"]},{"title":"Ubuntu 软件安装","url":"/qqsnote/2019/07/24/Ubuntu/","content":"昨天法国人发我一资料，前置工作参照一教程安装nodejs环境，使用apt-get install完了，node -v 一看，是4.x.x的版本实际上，这种情况下应该先更新软件的源curl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_10.x | sudo -E bash -sudo apt-get install -y nodejs\n\ndpkg was interrupted, you must manually run ‘sudo dpkg —configure -a’ to correct the problem\n\n之前调用apt-get install时出现上述异常需要cd &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;updatessudo rm *sudo apt-get update这里提一下update和upgrade的区别:update 是更新软件库列表upgrade 是在上述基础上将本地软件安装升级\n处理控制台进程无响应Ctrl C无法终结，按Ctrl Z将进程转到后台执行，然后ps -ef查看进程列表，kill无响应的进程\nubuntu lts 的IP设置sudo nano &#x2F;etc&#x2F;netplan&#x2F;01-xxxx.yaml\n这个配置文件内容如下例network:  version: 2  renderer: NetworkManager  ethernets:    enp0s3:      addresses:        - 192.168.1.100&#x2F;24      gateway4: 192.168.1.1      nameservers:        addresses: [8.8.8.8, 4.4.4.4]enp0s3为配置的ethernet(以太网)网络接口 用 ip link show 命令显示网络接口列表# netplan try 若配置正确 这个命令会应用上面的配置 并提示是否退回之前的设置sudo netplan apply# sudo netplan --debug apply\n查看发行版本号cat &#x2F;etc&#x2F;issue","categories":["Linux"],"tags":["Linux"]},{"title":"Umi","url":"/qqsnote/2025/09/08/Umi/","content":"Umi(乌米)阿里前端底层框架 基于React 提供构建企业级基础框架 以及插件化项目扩展的功能\nUmi是类似Next.js的“元框架” 提供更好的扩展性\n\nUmi 通过提供插件和插件集的机制来满足不同场景和业务的需求。插件是为了扩展一个功能，而插件集是为了扩展一类业务。比如要支持 vue，我们可以有 @umijs/preset-vue，包含 vue 相关的构建和运行时；比如要支持 h5 的应用类型，可以有 @umijs/preset-h5，把 h5 相关的功能集合到一起。如果要类比，插件集和 babel 的 preset，以及 eslint 的 config 都类似。\n\n安装及模板# use npmnpm create umi@latest -- --template electron# use pnpmpnpm create umi --template electron\n目录结构.├── config│   └── config.ts├── dist├── mock│   └── app.ts｜tsx├── src│   ├── .umi│   ├── .umi-production│   ├── layouts│   │   ├── BasicLayout.tsx│   │   ├── index.less│   ├── models│   │   ├── global.ts│   │   └── index.ts│   ├── pages│   │   ├── index.less│   │   └── index.tsx│   ├── utils &#x2F;&#x2F; 推荐目录│   │   └── index.ts│   ├── services &#x2F;&#x2F; 推荐目录│   │   └── api.ts│   ├── app.(ts|tsx)│   ├── global.ts│   ├── global.(css|less|sass|scss)│   ├── overrides.(css|less|sass|scss)│   ├── favicon.(ico|gif|png|jpg|jpeg|svg|avif|webp)│   └── loading.(tsx|jsx)├── node_modules│   └── .cache│       ├── bundler-webpack│       ├── mfsu│       └── mfsu-deps├── .env├── plugin.ts ├── .umirc.ts &#x2F;&#x2F; 与 config&#x2F;config 文件 2 选一├── package.json├── tsconfig.json└── typings.d.ts\n"},{"title":"UniAnimate","url":"/qqsnote/2025/03/26/UniAnimate/","content":"","tags":["aigc"]},{"title":"VR & AR","url":"/qqsnote/2023/02/16/VRandAR/","content":"ARCore\n\nVR（Virtual Reality）  模拟三维场景 使用户感觉身临其境\nAR（Augmented Reality）将虚拟元素叠加到现实世界\nMR（Mixed Reality）    前两者的融合和交互\nXR（Extended Reality） 统称以及应用延申\n\n"},{"title":"版本号","url":"/qqsnote/2023/10/08/Versions/","content":"关于版本号和构建编号\nThe standard build numbering convention makes use of a fourth numerical indicator which is appendedto the release number, where the fourth indicator is the build number.\n\n\nFor verification builds, the build number starts with a “1”, and increments with each successivebuild. For each successive release, the build indicator starts again with zero’s.\nFor development builds, the build number starts with “20001” and increments with eachsuccessive build. For each successive release, the build indicator starts again with zero’s.\n\nExamples:4.3.0.20134 – The 134th development build of release 4.3.04.3.0.4 – The 4th verification build of release 4.3.0\nRelease image naming convention -&gt; Example: GxPicture_3.4.3.7.ISO\n"},{"title":"Vue进阶","url":"/qqsnote/2022/01/21/VueAdvance/","content":"程序入口&#x2F;&#x2F; main.jsimport Vue from &#39;vue&#39;import App from &#39;.&#x2F;App.vue&#39;&#x2F;&#x2F; 生产环境中不提示 正在使用开发板警告Vue.config.productionTip &#x3D; falsenew Vue(&#123;  render: h &#x3D;&gt; h(App),&#125;).$mount(&#39;#app&#39;)\nh 是 createElement 的别名$mount(‘#app’) 表示将该组件挂在到id=”app”的dom上，这个#app在public/index.html上\nprovider &amp; inject类似于React的 Context Provider, 避免父组件向孙子后代组件传参时逐层引用，而以依赖注入的形式暴露给其他组件const app &#x3D; Vue.createApp(&#123;&#125;)app.component(&#39;todo-list&#39;, &#123;  data() &#123;    return &#123;      todos: [&#39;Feed a cat&#39;, &#39;Buy tickets&#39;]    &#125;  &#125;,  provide: &#123;    user: &#39;John Doe&#39;  &#125;,  template: &#96;    &lt;div&gt;      &#123;&#123; todos.length &#125;&#125;      &lt;!-- 模板的其余部分 --&gt;    &lt;&#x2F;div&gt;  &#96;&#125;)app.component(&#39;todo-list-statistics&#39;, &#123;  inject: [&#39;user&#39;],  created() &#123;    console.log(&#96;Injected property: $&#123;this.user&#125;&#96; &#x2F;&#x2F; &gt; 注入的 property: John Doe  &#125;&#125;)注意 provide 组件实例property，需要用返回函数的形式provide() &#123;    return &#123;        todoLength: this.todos.length    &#125;&#125;\n生命周期\ncreated vs mounted\nbeforeUpdete updated\nbeforeDestroy destroyed\nactivated deactivated (only for keep-alive)\n\n@startumlactor UserUser -&gt; FatherComponent: beforeCreateUser -&gt; FatherComponent: createdUser -&gt; FatherComponent: beforeMountFatherComponent -&gt; ChildComponent: beforeCreateFatherComponent -&gt; ChildComponent: createdFatherComponent -&gt; ChildComponent: beforeMountFatherComponent -&gt; ChildComponent: mountedUser -&gt; FatherComponent: mounted@enduml\n组件通信\nprops/$emit\nevent bus\nvuex\nprovide/inject\nref 由生命周期图示可知 获取子组件引用必须要在mounted后\n$parent $children jquery的回忆浮现脑海\nattrs/listeners \n\nOptions API vs Composition API 指的是生命周期的选项 类似React class组件中‘选择’恰当的生命周期钩子嵌入业务逻辑。 created, mounted 等生命周期钩子，直接对应 componentDidMount, componentDidUpdate 等\nComposition API则React function组件中的hooks\nref() 和 reactive() 对应 useState。computed() 对应 useMemo。onMounted -&gt; useEffect(…, [])onUpdated -&gt; useEffect(…, […]) (不指定依赖)onUnmounted -&gt; useEffect(() =&gt; { return () =&gt; { … } }, [])\n组合式函数defineProperty\n自定义指令defineConponent\nvue.config.jsvue cli 项目配置包含项目基本配置和对webpack的封装\n基本配置：\n\n构建路径如 publicPath outputDir indexPath\n构建设置 transpileDependencies(false to disable sourcemap) …\ndevServer 配置webpack-dev-server选项 包括 host proxy等module.exports &#x3D; defineConfig(&#123;  transpileDependencies: true,  devServer: &#123;    port: 8081,    headers: &#123;      &#x2F;&#x2F; 微前端需要跨域      &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;    &#125;  &#125;,  configureWebpack: &#123;    output: &#123;      library: &#96;$&#123;packageName&#125;-[name]&#96;,      libraryTarget: &#39;umd&#39;,      chunkLoadingGlobal: &#96;webpackJsonp_$&#123;packageName&#125;&#96;,    &#125;  &#125;&#125;)\nwebpack配置:调整 webpack 配置最简单的方式就是在 vue.config.js 中的 configureWebpack 选项提供一个对象 该对象将会被 webpack-merge 合并入最终的 webpack 配置 (注意与vue.config.js重叠的配置项会被vue.config.js覆盖)\n\n","tags":["vuejs"]},{"title":"Vue语法","url":"/qqsnote/2020/03/04/VueGrammar/","content":"模板与绑定&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;&lt;span v-html&#x3D;&quot;rawHtml&quot;&gt;&lt;&#x2F;span&gt;&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;&lt;img v-bind:src&#x3D;&quot;url&quot; &#x2F;&gt;&lt;p v-if&#x3D;&quot;seen&quot;&gt;现在你看到我了&lt;&#x2F;p&gt;&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;&lt;li v-for&#x3D;&quot;item in items&quot;&gt;...&lt;&#x2F;li&gt;\n@click is short for v-on:click方法的括号（）不是必须的支持动态属性名和事件名称&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;\nVue实例&lt;template&gt;&lt;div id&#x3D;&quot;container&quot; &gt;  &lt;span&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;span&gt;  &lt;span v-once&gt;&#123;&#123; title &#125;&#125; 没变吧&lt;&#x2F;span&gt;  &lt;span v-if&#x3D;&quot;flag&quot;&gt;now shown&lt;&#x2F;span&gt;  &lt;p&gt;    &lt;a v-on:click&#x3D;&quot;handleClick&quot;&gt;      &lt;img v-bind:src&#x3D;&quot;url&quot; :class&#x3D;&quot;[flag? &#39;imgSize1&#39;:&#39;imgSize2&#39;]&quot; &#x2F;&gt;    &lt;&#x2F;a&gt;  &lt;&#x2F;p&gt;  &lt;p&gt;  &lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import * as THREE from &#39;three&#39;export default &#123;    name:&#39;viewPort&#39;,    props:&#123;        &#x2F;&#x2F;target    &#125;,    data()&#123;      return&#123;        title:&quot;titleXXX&quot;,        flag:true,        items:[&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;],        url: require(&#39;@&#x2F;assets&#x2F;images&#x2F;threelogo.png&#39;)      &#125;    &#125;,    &#x2F;&#x2F;     created()&#123;    &#125;,    mounted()&#123;      this.initScene()    &#125;,    methods:&#123;      initScene()&#123;        &#x2F;&#x2F; 创建3D场景对象Scene        const scene &#x3D; new THREE.Scene();        console.log(scene);      &#125;,      handleClick() &#123;        this.flag &#x3D; !this.flag;      &#125;    &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;#container &#123;  margin: 0;  width: 100%;  height: 100vh;  background: #fff;&#125;.imgSize1 &#123;  width: 100px;  height: 100px;&#125;.imgSize2 &#123;  width: 50px;  height: 50px;&#125;&lt;&#x2F;style&gt;\n当一个 Vue 实例被创建时，它将 data 对象中的所有的属性加入到 Vue 的响应式系统中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。\n常用实例方法：vm.$data &#x3D;&#x3D;&#x3D; data &#x2F;&#x2F; &#x3D;&gt; truevm.$el &#x3D;&#x3D;&#x3D; document.getElementById(&#39;example&#39;) &#x2F;&#x2F; &#x3D;&gt; truevm.$watch(&#39;a&#39;, function (newValue, oldValue) &#123;  &#x2F;&#x2F; 这个回调将在 &#96;vm.a&#96; 改变后调用&#125;)生命周期钩子new Vue(&#123;  data: &#123;    a: 1  &#125;,  created: function () &#123;    &#x2F;&#x2F; &#96;this&#96; 指向 vm 实例    console.log(&#39;a is: &#39; + this.a)  &#125;  mounted: function () &#123;    console.log(&#39;a is: &#39; + this.a)  &#125;  beforeDestroy:function()&#123;  &#125;&#125;)内联处理器方法new Vue(&#123;  data: &#123;      &#125;,  methods:&#123;      &#x2F;&#x2F; TODO functions  &#125;&#125;)\n","tags":["vuejs"]},{"title":"Vue QuickStart","url":"/qqsnote/2020/03/03/VueQuickStart/","content":"官网\n爬行起步方式Caution! 限定的引入顺序：template —&gt; vue.js —&gt; vue controller其中 template 和 vue.js 交换没有影响&lt;html&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Hi vue&lt;&#x2F;title&gt;    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;vue&#x2F;dist&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;    &lt;div id&#x3D;&quot;app&quot;&gt;        &#123;&#123; message &#125;&#125;    &lt;&#x2F;div&gt;    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;        var app &#x3D; new Vue(&#123;            el: &#39;#app&#39;,            data: &#123;                message: &#39;here here&#39;            &#125;        &#125;)    &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n常规起步方式npm install -g @vue&#x2F;clivue create vueproj\n阅读 vue-cli指引\n原力起飞方式webpack 打包 vue 基础\n多模块项目vue-multi-module\nvue渐进式\n完整版 \n编译器 用以将模板字符串编译成js渲染函数\n运行时 不含编译器 用以创建vue实例 处理虚拟dom\nUMD 通过\\引入html的完整版本\n\nvue对比其他框架\n\n\n\n\n特性\nVue.js\nReact\nAngular 2+\n\n\n\n\n核心特点\n渐进式框架，易学易用\n虚拟DOM，组件化\n完整的MVC框架\n\n\n学习曲线\n平缓，只需HTML/CSS/JS基础\n中等，需掌握JSX和ES2015\n陡峭，需掌握TypeScript和大量概念\n\n\n性能优化\n自动依赖追踪，精确更新\n需手动使用PureComponent或shouldComponentUpdate\n自动优化，但体积较大\n\n\n模板语法\n支持HTML模板，也支持JSX\n强制使用JSX\n使用类似HTML的模板\n\n\nCSS处理\n单文件组件中的scoped样式\nCSS-in-JS方案(如styled-components)\n支持组件样式，但不如Vue灵活\n\n\n生态系统\n官方维护路由和状态管理\n丰富的第三方库，生态系统庞大\n官方完整解决方案\n\n\n向下扩展\n简单，可通过CDN直接使用\n需要构建系统，不适合简单项目\n不适合简单项目\n\n\n向上扩展\n良好，官方提供CLI脚手架\n强大，但配置较复杂\n非常强大，适合大型企业应用\n\n\nTypeScript支持\n良好，官方提供类型声明\n优秀，TS是React的一部分\n必须使用TypeScript开发\n\n\n项目体积\n小(gzip后约30KB)\n中等\n较大(gzip后约65KB)\n\n\n灵活性\n高，不强制代码组织方式\n中等，组件灵活但生态约束\n低，有严格的代码组织规范\n\n\n浏览器兼容性\nIE9+\n现代浏览器\n现代浏览器\n\n\n响应式系统\n基于依赖追踪的观察系统\n基于状态管理和虚拟DOM\n基于Zone.js和变更检测\n\n\n原生渲染\n通过Weex或NativeScript-Vue\nReact Native\nIonic或NativeScript\n\n\n数据流\n单向数据流\n单向数据流(通过状态管理)\n单向数据流\n\n\n\n\n\n易用性：Vue &gt; React &gt; Angular\nVue学习曲线最平缓，React需要掌握JSX，Angular最复杂\n\n\n灵活性：Vue &gt; React &gt; Angular\nVue不强制代码组织方式，React组件灵活但生态约束，Angular有严格规范\n\n\n性能：Vue ≈ React &gt; Angular\nVue和React性能接近且优秀，Angular体积较大但性能也不错\n\n\n生态系统：React &gt; Angular &gt; Vue\nReact生态系统最庞大，Angular提供完整官方解决方案，Vue官方维护核心库\n\n\n适用场景：\nVue：中小型项目，需要快速开发，团队技术栈多样\nReact：大型项目，需要丰富生态系统，团队熟悉JS\nAngular：大型企业应用，需要完整解决方案，团队熟悉TypeScript\n\n\n\n从Angular、React到Vue\n\n单文件组件 single file component\n相似的指令绑定\n直接赋值属性 无需setState\nComposition API类React Hooks\nprops emit类似Angular装饰器风格\n\n从vue2到vue3\n","tags":["vuejs"]},{"title":"Vuetify","url":"/qqsnote/2025/10/14/Vuetify/","content":"","tags":["vuejs"]},{"title":"Vue Router","url":"/qqsnote/2025/08/12/VueRouter/","content":"","tags":["vuejs"]},{"title":"Vuex","url":"/qqsnote/2022/02/14/Vuex/","content":"vue的状态管理库其核心是管理一个store(仓库) store保存变量的状态 组件引用store 查询状态以commit mutation的方式更新状态 \n\n状态驱动视图 UI=f(state)\nstate使用单一状态树，即app只用一个对象管理所有变量\n\nvuex通过vue插件系统将store注入到每一个组件，子组件通过this.$store.count访问\nmapstatecomouted: mapState([&#39;count&#39;])\n字符串为state的变量名\nmutationstore.commit(&#39;increment&#39;, payload)\nconst store &#x3D; createStore(&#123;  state: &#123;    count: 1  &#125;,  mutations: &#123;    increment (state, payload) &#123;        state.count +&#x3D; payload    &#125;  &#125;&#125;)\nmutation的处理方法不能是异步的 对于异步的状态是无法追踪的\naction与mutation类似分发actionstore.dispatch(&#39;increment&#39;)action通常传递一个mutation 其处理方法可以是异步的actions: &#123;  incrementAsync (&#123; commit &#125;) &#123;    setTimeout(() &#x3D;&gt; &#123;      commit(&#39;increment&#39;)    &#125;, 1000)  &#125;&#125;\nmodule由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n实践store/index.js&#x2F;&#x2F; 数据const state &#x3D; &#123;  count,  user:&#123;name:&#39;&#39;&#125;&#125;const getters &#x3D; &#123;  getUser(state)&#123;    return state.user  &#125;&#125;&#x2F;&#x2F; 修改数据 const mutations &#x3D; &#123;  updateUser(state, user)&#123;    state.user &#x3D; user  &#125;&#125;&#x2F;&#x2F; 异步操作const actions &#x3D; &#123;  delayUpdate(store, user)&#123;    setTimeout(()&#x3D;&gt;&#123;      store.commit(&#39;updateUser&#39;, user)    &#125;)  &#125;&#125;&#x2F;&#x2F; 分装const modules &#x3D; &#123;  moduleA:&#123;    state,    mutations,    actions  &#125;,  moduleB:&#123;    state,    mutations,    actions  &#125;&#125;子组件中 调用mutation用commit方法 调用action用dispatch方法this.$store.commit(&#39;updateUser&#39;, user)this.$store.dispatch(&#39;delayUpdate&#39;, user)\ntroubleshooting\nTypeError: Cannot read properties of undefined (reading ‘commit’)\n\nvuex@4 不兼容vue2 改为vuex@3定义store时 Vue.use(Vuex)\n","tags":["vuejs"]},{"title":"WPF Prism","url":"/qqsnote/2025/07/27/WPF-Prism/","content":"安装依赖&lt;ItemGroup&gt;  &lt;PackageReference Include&#x3D;&quot;HandyControl&quot; Version&#x3D;&quot;3.5.1&quot; &#x2F;&gt;  &lt;PackageReference Include&#x3D;&quot;Prism.Unity&quot; Version&#x3D;&quot;8.1.97&quot; &#x2F;&gt;&lt;&#x2F;ItemGroup&gt;app.xmal中Wpf:Application替换成prism:PrismApplication&lt;prism:PrismApplication    x:Class&#x3D;&quot;WpfApp1.App&quot;    xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;winfx&#x2F;2006&#x2F;xaml&#x2F;presentation&quot;    xmlns:x&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;winfx&#x2F;2006&#x2F;xaml&quot;    xmlns:local&#x3D;&quot;clr-namespace:WpfApp1&quot;    xmlns:prism&#x3D;&quot;http:&#x2F;&#x2F;prismlibrary.com&#x2F;&quot;&gt;    &lt;Application.Resources&gt;    &lt;&#x2F;Application.Resources&gt;&lt;&#x2F;prism:PrismApplication&gt;标记中删除了StartupUri=”MainWindow.xaml”（否则生成两个实例）\ncs代码实现两个抽象方法RegisterTypes和CreateShell&#x2F;&#x2F; 创建程序主窗口protected override Window CreateShell()&#123;    return Container.Resolve&lt;MainWindow&gt;();&#125;protected override void RegisterTypes(IContainerRegistry container)&#123;    &#x2F;&#x2F; 注册导航页面和ViewModel    container.RegisterForNavigation&lt;MainWindow, MainWindowViewModel&gt;();        &#x2F;&#x2F; 注册单例服务    container.RegisterSingleton&lt;IMyService, MyService&gt;();    &#x2F;&#x2F; 配置文件基础路径    string programData &#x3D; System.Environment.GetFolderPath(System.Environment.SpecialFolder.MyDocuments);    programData &#x3D; Path.Combine(programData, &quot;xxxx&quot;);        &#x2F;&#x2F; 从注册表读取配置路径    using (var key &#x3D; Registry.LocalMachine.OpenSubKey($@&quot;SOFTWARE\\xxxx&quot;))    &#123;        if (key !&#x3D; null &amp;&amp; key.GetValue(&quot;SolutionPath&quot;) !&#x3D; null)        &#123;            programData &#x3D; key.GetValue(&quot;SolutionPath&quot;).ToString();        &#125;    &#125;    &#x2F;&#x2F; 初始化全局缓存    GlobalCache.Instance.FileBasePath &#x3D; programData;    GlobalCache.Instance.InitPaths();&#125;\n"},{"title":"WPF","url":"/qqsnote/2023/02/27/WPF/","content":"Application WindowApp.xmalMainWindow.xmal\ndispatch.invoke从主 UI 线程派生的后台线程不能更新的内容，比如在Button onClick中创建的线程，为了使后台线程访问Button的内容属性,后台线程必须将工作委托给Dispatcher 与 UI 线程关联。 这通过使用Invoke 或 BeginInvoke实现。 Invoke 是同步，BeginInvoke 是异步的。\ncontrol template实现一个按钮 倒圆角 背景 字体 MouseOver效果&lt;Button HorizontalAlignment&#x3D;&quot;Center&quot; VerticalAlignment&#x3D;&quot;Center&quot; Height&#x3D;&quot;40&quot; Width&#x3D;&quot;120&quot;     Foreground&#x3D;&quot;#4D4D4D&quot; Content&#x3D;&quot;Close&quot; FontSize&#x3D;&quot;14&quot; FontWeight&#x3D;&quot;bold&quot; Click&#x3D;&quot;btnOK_Click&quot;&gt;    &lt;Button.Template &gt;        &lt;ControlTemplate TargetType&#x3D;&quot;&#123;x:Type Button&#125;&quot; &gt;            &lt;Border x:Name&#x3D;&quot;btnBorder&quot; BorderBrush&#x3D;&quot;&#123;TemplateBinding Control.BorderBrush&#125;&quot; CornerRadius&#x3D;&quot;5,5,5,5&quot;&gt;                &lt;Border.Background &gt;#DDF9FE&lt;&#x2F;Border.Background&gt;                &lt;TextBlock x:Name&#x3D;&quot;BtnText&quot; Text&#x3D;&quot;&#123;TemplateBinding ContentControl.Content&#125;&quot;                            Foreground&#x3D;&quot;&#123;TemplateBinding Foreground&#125;&quot;                            HorizontalAlignment&#x3D;&quot;Center&quot; VerticalAlignment&#x3D;&quot;Center&quot;&gt;&lt;&#x2F;TextBlock&gt;            &lt;&#x2F;Border&gt;            &lt;ControlTemplate.Triggers&gt;                &lt;Trigger Property&#x3D;&quot;IsMouseOver&quot; Value&#x3D;&quot;True&quot;&gt;                    &lt;Setter TargetName&#x3D;&quot;btnBorder&quot; Property&#x3D;&quot;Background&quot; Value&#x3D;&quot;#36B0C9&quot;&#x2F;&gt;                    &lt;Setter TargetName&#x3D;&quot;BtnText&quot; Property&#x3D;&quot;Foreground&quot; Value&#x3D;&quot;#FFF&quot;&#x2F;&gt;                &lt;&#x2F;Trigger&gt;            &lt;&#x2F;ControlTemplate.Triggers&gt;        &lt;&#x2F;ControlTemplate&gt;    &lt;&#x2F;Button.Template&gt;&lt;&#x2F;Button&gt;\n"},{"title":"Web无障碍","url":"/qqsnote/2021/01/28/Web-Accessibility/","content":""},{"title":"Web3D-performance","url":"/qqsnote/2025/09/04/Web3D-performance/","content":"","tags":["图形学","性能"]},{"title":"Web3D","url":"/qqsnote/2023/02/09/Web3D/","content":"瓶颈\n终端的渲染性能包括网页端WebGL的渲染性能，以及移动终端的硬件性能\n网络对大型模型场景的传输能力\n\n像素流送UE像素流送\nWebGPUWebGL是OpenGL ES版本API的封装，已经有十几年的历史，随着图形技术的发展，W3C提出全新的规范，浏览器封装了现代图形API（Dx12、Vulkan、Metal）让浏览器里面直接可以调用这三个现代图形API能力，实现高质量的渲染效果，调用GPU的强大计算能力。\n\nWebGPU is available for now in Chrome Canary behind an experimental flag. You can enable it at chrome://flags/#enable-unsafe-webgpu . The API is constantly changing and currently unsafe.\n\nWebGPU学习系列目录\nWebGL也会调用GPU工作 那WebGPU技术又是为了解决什么而出现的呢现代图形API\nWebGL 是基于 2007 年的 OpenGL ES 2.0 规范，而 WebGPU 则是基于 2010 年后出现的现代图形 API\nWebGL 像一个巨大的、全局共享的“状态机”。你调用 gl.enable()、gl.blendFunc()、gl.bindTexture() 等函数时，你是在修改这个全局状态。当你调用 gl.drawArrays() 时，GPU 就使用当前所有的“全局状态”来执行绘制。\nWebGL Api 充当桥梁 一边是js环境 运行在CPU 另一边是GPU图形计算功能\n CPU 的工作部分（准备阶段）\n\n创建数据： JavaScript 代码会创建 3D 模型的数据，比如顶点位置、颜色、纹理坐标等。这些数据通常存储在 JavaScript 的 Array 或 Float32Array 中。\n组织场景： CPU 负责管理场景图，比如哪个物体在哪个位置，相机看向哪里，灯光如何设置。\n编译着色器： CPU 负责将 GLSL（OpenGL Shading Language）代码（即着色器程序）发送给显卡驱动，由驱动将其编译成 GPU 能直接理解的机器码。\n发送指令和数据： 这是最关键的一步。CPU 通过 WebGL API，将准备好的数据（顶点、纹理图片）和指令（“用这个着色器”、“画这些三角形”、“应用这个纹理”）打包，通过总线发送到 GPU 的显存中。\n\n\n可以把这个过程比作： CPU 是一个总指挥，它准备好所有的“原材料”（模型数据）和“施工图纸”（着色器），然后通过 WebG L 这个“通信系统”把它们全部送到 GPU 这个“超级工厂”。\n\nGPU 的工作部分（执行阶段）\n\n接收数据： GPU 接收 CPU 发送过来的所有数据和指令，并把它们放在自己的高速显存里。\n并行执行着色器： 一旦收到“开始渲染”的指令（如 gl.drawArrays 或 gl.drawElements），GPU 就会火力全开。\n顶点着色器： GPU 的成百上千个核心同时处理成千上万个顶点，计算它们在屏幕上的最终位置。\n光栅化： GPU 硬件自动将处理好的顶点组装成三角形，再把这些三角形转换成屏幕上的像素片段。\n片元着色器： GPU 的核心们再次同时工作，为每一个像素片段计算最终的颜色（考虑光照、纹理、阴影等）。\n\n\n输出结果： 最终，所有像素的颜色值被写入到帧缓冲区，然后显示在屏幕上。\n\nWebGPU 不再是状态机。你创建一个“命令缓冲区”（GPUCommandBuffer），然后像写日志一样，把所有要执行的命令（绑定管线、绑定资源、绘制）都记录进去。记录完成后，你将整个缓冲区一次性提交给 GPU 执行。\n"},{"title":"原生Web API","url":"/qqsnote/2020/09/03/WebAPIs/","content":"XMLHttpRequest\nXMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。尽管名称如此，XMLHttpRequest 可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 HTTP 以外的协议（包括 file:// 和 FTP），尽管可能受到更多出于安全等原因的限制。function reqListener () &#123;  console.log(this.responseText);&#125;var oReq &#x3D; new XMLHttpRequest();oReq.addEventListener(&quot;load&quot;, reqListener);oReq.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;www.example.org&#x2F;getsomething&quot;);oReq.responseType &#x3D; &quot;json&quot;;oReq.send();发送var xhr &#x3D; new XMLHttpRequest;xhr.open(&quot;POST&quot;, url, false);xhr.send(data);\n\nResizeObserver示例 ResizeObserver调用构造方法返回一个ResizeObserver对象，传入回调函数(entries)=&gt;{}，即当监听到目标width height改变时，执行该函数，参数entries为ResizeObserverEntry接口的集合，可以访问真正在观察的 Element 或 SVGElement 最新的大小const observer &#x3D; new ResizeObserver(entries&#x3D;&gt;&#123;  for (let entry of entries) &#123;    if(entry.contentBoxSize) &#123; &#x2F;&#x2F; 内容盒尺寸      h1Elem.style.fontSize &#x3D; &#96;$&#123;Math.max(1.5, entry.contentBoxSize.inlineSize &#x2F; 200)&#125;rem&#96;; &#x2F;&#x2F; 前文某标题const h1Elem &#x3D; document.querySelector(&#39;h1&#39;);      pElem.style.fontSize &#x3D; &#96;$&#123;Math.max(1, entry.contentBoxSize.inlineSize &#x2F; 600)&#125;rem&#96;; &#x2F;&#x2F; 前文某段文字const pElem &#x3D; document.querySelector(&#39;p&#39;);    &#125; else &#123;      h1Elem.style.fontSize &#x3D; &#96;$&#123;Math.max(1.5, entry.contentRect.width &#x2F; 200)&#125;rem&#96;;      pElem.style.fontSize &#x3D; &#96;$&#123;Math.max(1, entry.contentRect.width &#x2F; 600)&#125;rem&#96;;    &#125;  &#125;&#125;)\nlocalStoragelocalStorage.setItem(&#39;qqsCustomizedList&#39;， &#39;[&#39;id&#39;,&#39;name&#39;]&#39;)localStorage.getItem(&#39;qqsCustomizedList&#39;)localStorage.clear()\n关于内容盒和边框盒(存目)","tags":["Web协议"]},{"title":"越权访问","url":"/qqsnote/2023/03/03/WebDev-BrokenAccessControl/","content":"","tags":["Web开发"]},{"title":"Web开发学习路线","url":"/qqsnote/2020/07/22/WebDev-RoadMap/","content":"web开发学习路线图\nhttps://juejin.im/post/5ea39c93f265da47e84e8c8a\n阮一峰博客\nH5新增api\nnavigator.geolocation.getCurrentPosition(successCallback, errorCallback)\ndragable=true\nFileReader\nStorage\n等\n\njs单线程、异步和任务队列\n避免修改dom引起的竞争\nJavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、dom操作、定时器的计时和事件监听由浏览器提供的其他线程来完成的\n\n\n对象放在heap（堆）里，常见的基础类型和函数放在stack（栈）里，函数执行的时候在栈里执行。其中会有异步操作，这些操作可能需要调用浏览器的其他线程去处理，操作结果由相应的回调函数响应，但是要先丢到任务队列中，等栈空了，则检查任务队列，将队列中的事件函数放到栈中执行。这个过程是循环不断地\n为什么函数调用是用栈实现的\n自查","tags":["Web开发"]},{"title":"WebDev_OtherStories","url":"/qqsnote/2020/07/22/WebDev-OtherStories/","content":"js的特点\nthe part that is good is not original, and the part that is original is not good.\n\n关于浏览器从url到页面显示\n\n“user agent stylesheet”用户代理样式，浏览器默认样式，无法在开发者模式中修改\n\njs 事件\n原生js并没有document.ready事件，document.ready和window.onload\n\n前后端分离和SPA显然前后端分离不一定非要做成SPA，但是SPA被认为是前后端分离的最佳实践：前后端分离的初衷是对后台服务的优化，即将静态资源的传输移出后台逻辑，分离后前后端之间的接口只提供数据。SPA的出现是“复用一切可复用”的设计原则的体现，即根据交互仅对局部视图更新，其他部分复用。也就是说，SPA和前后端分离同样是解决可复用内容（包括页面模板）的问题，如果你的产品有必要做这个问题的优化，那么前后端分离和SPA就自然而然地成为选择。\n浏览器信息window.navigator.userAgent 参考MDN Web API输出如 “Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36”Caution! 该属性可修改 无法确保准确性\n","tags":["Web开发"]},{"title":"WebService","url":"/qqsnote/2019/11/13/WebService/","content":"比较复杂的概念：\n面向服务架构(Service Oriented Ambiguity, SOA),将紧耦合的系统，划分为面向业务的，粗粒度，松耦合，无状态的服务，服务之间彼此通信，用一组互相依赖的服务构成了SOA架构下的系统。\n\nWebService是SOA的最佳实现之一\n\nWeb service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。\n简单对象访问协议(Simple Object Access Protocol, SOAP), 基于XML在分散或分布式的环境中交换信息的简单的协议。允许服务提供者和服务客户经过防火墙在INTERNET进行通讯交互。\n\n　　SOAP的设计是为了在一个松散的、分布的环境中使用XML对等地交换结构化的和类型化的信息提供了一个简单且轻量级的机制。\n\n网络服务描述语言(Web Services Description Language, WSDL), 它是一门基于 XML 的语言，用于描述 Web Services 以及如何对它们进行访问, WSDL文件是关于如何调用Web Service的文档。\n解读WSDL文档某wsdl_prod.xml&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;wsdl:definitions  xmlns:wsx&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2004&#x2F;09&#x2F;mex&quot;  xmlns:wsa10&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2005&#x2F;08&#x2F;addressing&quot;  xmlns:soap12&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;wsdl&#x2F;soap12&#x2F;&quot;  xmlns:wsaw&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2006&#x2F;05&#x2F;addressing&#x2F;wsdl&quot;  xmlns:msc&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;ws&#x2F;2005&#x2F;12&#x2F;wsdl&#x2F;contract&quot;  xmlns:xsd&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema&quot;  xmlns:wsap&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2004&#x2F;08&#x2F;addressing&#x2F;policy&quot;  xmlns:i0&#x3D;&quot;http:&#x2F;&#x2F;sso.xxxxxxxxxxxxx.com&#x2F;DataService&#x2F;v1&quot;  xmlns:wsp&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2004&#x2F;09&#x2F;policy&quot;  xmlns:wsa&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2004&#x2F;08&#x2F;addressing&quot;  xmlns:tns&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;  xmlns:wsam&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2007&#x2F;05&#x2F;addressing&#x2F;metadata&quot; xmlns:soapenc&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;encoding&#x2F;&quot; xmlns:wsu&#x3D;&quot;http:&#x2F;&#x2F;docs.oasis-open.org&#x2F;wss&#x2F;2004&#x2F;01&#x2F;oasis-200401-wss-wssecurity-utility-1.0.xsd&quot; xmlns:soap&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;wsdl&#x2F;soap&#x2F;&quot; xmlns:wsdl&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;wsdl&#x2F;&quot; targetNamespace&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot; name&#x3D;&quot;SsoDataService&quot;&gt;-&lt;wsp:Policy wsu:Id&#x3D;&quot;CustomBinding_ISsoDataService_policy&quot;&gt;-&lt;wsp:ExactlyOne&gt;-&lt;wsp:All&gt;-&lt;sp:TransportBinding xmlns:sp&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2005&#x2F;07&#x2F;securitypolicy&quot;&gt;-&lt;wsp:Policy&gt;-&lt;sp:TransportToken&gt;-&lt;wsp:Policy&gt;&lt;sp:HttpsToken RequireClientCertificate&#x3D;&quot;false&quot;&#x2F;&gt;&lt;&#x2F;wsp:Policy&gt;&lt;&#x2F;sp:TransportToken&gt;-&lt;sp:AlgorithmSuite&gt;-&lt;wsp:Policy&gt;&lt;sp:Basic256&#x2F;&gt;&lt;&#x2F;wsp:Policy&gt;&lt;&#x2F;sp:AlgorithmSuite&gt;-&lt;sp:Layout&gt;-&lt;wsp:Policy&gt;&lt;sp:Lax&#x2F;&gt;&lt;&#x2F;wsp:Policy&gt;&lt;&#x2F;sp:Layout&gt;&lt;&#x2F;wsp:Policy&gt;&lt;&#x2F;sp:TransportBinding&gt;-&lt;sp:SignedSupportingTokens xmlns:sp&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2005&#x2F;07&#x2F;securitypolicy&quot;&gt;-&lt;wsp:Policy&gt;-&lt;sp:UsernameToken sp:IncludeToken&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2005&#x2F;07&#x2F;securitypolicy&#x2F;IncludeToken&#x2F;AlwaysToRecipient&quot;&gt;-&lt;wsp:Policy&gt;&lt;sp:WssUsernameToken10&#x2F;&gt;&lt;&#x2F;wsp:Policy&gt;&lt;&#x2F;sp:UsernameToken&gt;&lt;&#x2F;wsp:Policy&gt;&lt;&#x2F;sp:SignedSupportingTokens&gt;-&lt;sp:Wss10 xmlns:sp&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2005&#x2F;07&#x2F;securitypolicy&quot;&gt;-&lt;wsp:Policy&gt;&lt;sp:MustSupportRefKeyIdentifier&#x2F;&gt;&lt;sp:MustSupportRefIssuerSerial&#x2F;&gt;&lt;&#x2F;wsp:Policy&gt;&lt;&#x2F;sp:Wss10&gt;-&lt;sp:Trust10 xmlns:sp&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2005&#x2F;07&#x2F;securitypolicy&quot;&gt;-&lt;wsp:Policy&gt;&lt;sp:MustSupportIssuedTokens&#x2F;&gt;&lt;sp:RequireClientEntropy&#x2F;&gt;&lt;sp:RequireServerEntropy&#x2F;&gt;&lt;&#x2F;wsp:Policy&gt;&lt;&#x2F;sp:Trust10&gt;&lt;&#x2F;wsp:All&gt;&lt;&#x2F;wsp:ExactlyOne&gt;&lt;&#x2F;wsp:Policy&gt;&lt;wsdl:import location&#x3D;&quot;wsdl0.xml&quot; namespace&#x3D;&quot;http:&#x2F;&#x2F;sso.xxxxxxxxxxxxx.com&#x2F;DataService&#x2F;v1&quot;&#x2F;&gt;&lt;wsdl:types&#x2F;&gt;-&lt;wsdl:binding name&#x3D;&quot;CustomBinding_ISsoDataService&quot; type&#x3D;&quot;i0:ISsoDataService&quot;&gt;&lt;wsp:PolicyReference URI&#x3D;&quot;#CustomBinding_ISsoDataService_policy&quot;&#x2F;&gt;&lt;soap:binding transport&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;http&quot;&#x2F;&gt;-&lt;wsdl:operation name&#x3D;&quot;ValidateAccountLogin&quot;&gt;&lt;soap:operation style&#x3D;&quot;document&quot; soapAction&#x3D;&quot;http:&#x2F;&#x2F;sso.xxxxxxxxxxxxx.com&#x2F;DataService&#x2F;v1&#x2F;ISsoDataService&#x2F;ValidateAccountLogin&quot;&#x2F;&gt;-&lt;wsdl:input&gt;&lt;soap:body use&#x3D;&quot;literal&quot;&#x2F;&gt;&lt;&#x2F;wsdl:input&gt;-&lt;wsdl:output&gt;&lt;soap:body use&#x3D;&quot;literal&quot;&#x2F;&gt;&lt;&#x2F;wsdl:output&gt;&lt;&#x2F;wsdl:operation&gt;&lt;&#x2F;wsdl:binding&gt;-&lt;wsdl:service name&#x3D;&quot;SsoDataService&quot;&gt;-&lt;wsdl:port name&#x3D;&quot;CustomBinding_ISsoDataService&quot; binding&#x3D;&quot;tns:CustomBinding_ISsoDataService&quot;&gt;&lt;soap:address location&#x3D;&quot;https:&#x2F;&#x2F;sso.************.com&#x2F;DataService.svc&quot;&#x2F;&gt;&lt;&#x2F;wsdl:port&gt;&lt;&#x2F;wsdl:service&gt;&lt;&#x2F;wsdl:definitions&gt;该文档标注了大量的xml协议，包含用于SOAP header中做安全认证的协议以及格式（待日后补充解读）\n\n其中import wsdl0.xml 该文件主要是接口的协议&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;wsdl:definitions targetNamespace&#x3D;&quot;http:&#x2F;&#x2F;sso.xxxxxxxxxxxxx.com&#x2F;DataService&#x2F;v1&quot; xmlns:wsdl&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;wsdl&#x2F;&quot; xmlns:soap&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;wsdl&#x2F;soap&#x2F;&quot; xmlns:wsu&#x3D;&quot;http:&#x2F;&#x2F;docs.oasis-open.org&#x2F;wss&#x2F;2004&#x2F;01&#x2F;oasis-200401-wss-wssecurity-utility-1.0.xsd&quot; xmlns:soapenc&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;encoding&#x2F;&quot; xmlns:wsam&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2007&#x2F;05&#x2F;addressing&#x2F;metadata&quot; xmlns:tns&#x3D;&quot;http:&#x2F;&#x2F;sso.xxxxxxxxxxxxx.com&#x2F;DataService&#x2F;v1&quot; xmlns:wsa&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2004&#x2F;08&#x2F;addressing&quot; xmlns:wsp&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2004&#x2F;09&#x2F;policy&quot; xmlns:wsap&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2004&#x2F;08&#x2F;addressing&#x2F;policy&quot; xmlns:xsd&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema&quot; xmlns:msc&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;ws&#x2F;2005&#x2F;12&#x2F;wsdl&#x2F;contract&quot; xmlns:wsaw&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2006&#x2F;05&#x2F;addressing&#x2F;wsdl&quot; xmlns:soap12&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;wsdl&#x2F;soap12&#x2F;&quot; xmlns:wsa10&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2005&#x2F;08&#x2F;addressing&quot; xmlns:wsx&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;ws&#x2F;2004&#x2F;09&#x2F;mex&quot;&gt;&lt;wsdl:types&gt;\t&lt;xsd:schema targetNamespace&#x3D;&quot;http:&#x2F;&#x2F;sso.xxxxxxxxxxxxx.com&#x2F;DataService&#x2F;v1&#x2F;Imports&quot;&gt;\t\t&lt;xsd:import schemaLocation&#x3D;&quot;xsd0.xml&quot; namespace&#x3D;&quot;http:&#x2F;&#x2F;sso.xxxxxxxxxxxxx.com&#x2F;DataService&#x2F;v1&quot;&#x2F;&gt;\t\t&lt;xsd:import schemaLocation&#x3D;&quot;xsd1.xml&quot; namespace&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;2003&#x2F;10&#x2F;Serialization&#x2F;&quot;&#x2F;&gt;\t\t&lt;xsd:import schemaLocation&#x3D;&quot;xsd2.xml&quot; namespace&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;2003&#x2F;10&#x2F;Serialization&#x2F;Arrays&quot;&#x2F;&gt;\t&lt;&#x2F;xsd:schema&gt;&lt;&#x2F;wsdl:types&gt;\t&lt;wsdl:message name&#x3D;&quot;ISsoDataService_ValidateAccountLogin_InputMessage&quot;&gt;\t&lt;wsdl:part name&#x3D;&quot;parameters&quot; element&#x3D;&quot;tns:ValidateAccountLogin&quot;&#x2F;&gt;\t&lt;&#x2F;wsdl:message&gt;\t&lt;wsdl:message name&#x3D;&quot;ISsoDataService_ValidateAccountLogin_OutputMessage&quot;&gt;\t&lt;wsdl:part name&#x3D;&quot;parameters&quot; element&#x3D;&quot;tns:ValidateAccountLoginResponse&quot;&#x2F;&gt;\t&lt;&#x2F;wsdl:message&gt;\t&lt;wsdl:portType name&#x3D;&quot;ISsoDataService&quot;&gt;\t\t&lt;wsdl:operation name&#x3D;&quot;ValidateAccountLogin&quot;&gt;\t\t\t&lt;wsdl:input wsaw:Action&#x3D;&quot;http:&#x2F;&#x2F;sso.xxxxxxxxxxxxx.com&#x2F;DataService&#x2F;v1&#x2F;ISsoDataService&#x2F;ValidateAccountLogin&quot; message&#x3D;&quot;tns:ISsoDataService_ValidateAccountLogin_InputMessage&quot;&#x2F;&gt;\t\t\t&lt;wsdl:output wsaw:Action&#x3D;&quot;http:&#x2F;&#x2F;sso.xxxxxxxxxxxxx.com&#x2F;DataService&#x2F;v1&#x2F;ISsoDataService&#x2F;ValidateAccountLoginResponse&quot; message&#x3D;&quot;tns:ISsoDataService_ValidateAccountLogin_OutputMessage&quot;&#x2F;&gt;\t\t&lt;&#x2F;wsdl:operation&gt;\t&lt;&#x2F;wsdl:portType&gt;&lt;&#x2F;wsdl:definitions&gt;其中xsd1，2，3是参数定义 略\n首先须知xml语法(存目)\nxmlns:el=”url” el元素遵循url定义的规范\nWSDL 文档主要使用以下几个元素来描述某个 web service ：\nportType  “最重要的元素” 描述一个 web service、可被执行的操作，以及相关的消息。\nmessage 元素定义一个操作的数据元素。\n每个消息均由一个或多个部件组成。可以把这些部件比作传统编程语言中一个函数调用的参数。\nWSDL types\ntypes 元素定义 web service 使用的数据类型。\n为了最大程度的平台中立性，WSDL 使用 XML Schema 语法来定义数据类型。\nWSDL Bindings\nbinding 元素为每个端口定义消息格式和协议细节。\n安全认证（存目）SOAP用例SOAP结构&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;soap:Envelope xmlns:soap&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;12&#x2F;soap-envelope&quot;soap:encodingStyle&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;12&#x2F;soap-encoding&quot;&gt;  &lt;soap:Header&gt;      ...      ...  &lt;&#x2F;soap:Header&gt;  &lt;soap:Body&gt;      ...      ...      &lt;soap:Fault&gt;        ...        ...      &lt;&#x2F;soap:Fault&gt;  &lt;&#x2F;soap:Body&gt;&lt;&#x2F;soap:Envelope&gt;参考 Web Service概念梳理\n","categories":["前端技术"],"tags":["WebService"]},{"title":"WebTest","url":"/qqsnote/2020/09/03/WebTest/","content":""},{"title":"微信账号登录","url":"/qqsnote/2020/01/17/WechatAuthentication/","content":"前提 服务号注册服务号\n\n企业名称\n营业执照注册号\n验证方式\n\n","tags":["Wechat"]},{"title":"微信小程序","url":"/qqsnote/2024/10/31/WechatMiniProgram/","content":"在学习React Native时想到的微信小程序特点：\n\n自带的传播属性 依托微信分享 二维码分享\n体量小 使用方便 跨平台\n开发成本低 WXML + WXSS + js\n\n其性能逊色与React Native应用 而且只支持有限的原生API，React Native不是单纯的web应用（Hybrid），可以依托C++ Jave开发原生功能模块，以及优化运算性能等。缘于微信平台限制，微信小程序拥有有限的文件访问权限，有限的websocket实时通信功能，React Native还可以开发离线推送 APNs（Apple Push Notification Service）和 FCM（Firebase Cloud Messaging）微信小程序的推送需要通过订阅号间接实现\n更适合React Native的开发场景\n\n高性能动画和图形处理\n高性能计算和数据处理\n深度集成原生功能\n实时通信和推送通知\n文件系统和数据库操作\n第三方库和工具的集成\n\n"},{"title":"微信支付","url":"/qqsnote/2020/01/17/WechatPay/","content":""},{"title":"async await是generator的语法糖","url":"/qqsnote/2021/02/05/await2generator/","content":"async await写一个训练过程async function practise() &#123;    console.log(&#39;训练开始...&#39;)    let result;    result &#x3D; await warmup(2)    if(result) console.log(&#39;热身完成。。&#39;)    result &#x3D; await squat(5)    if(result) console.log(&#39;深蹲完成。。&#39;)    result &#x3D; await boating(3)    if(result) console.log(&#39;划船完成。。&#39;)&#125;function warmup(time)&#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;            resolve(1);        &#125;, time*1000);    &#125;);&#125;function squat(time)&#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;            resolve(1);        &#125;, time*1000);    &#125;);&#125;function boating(time)&#123;    return new Promise((resolve, reject) &#x3D;&gt; &#123;        setTimeout(() &#x3D;&gt; &#123;            resolve(1);        &#125;, time*1000);    &#125;);&#125;&#x2F;&#x2F; 执行这个‘训练’practise().then(res&#x3D;&gt;&#123;    console.log(&#39;完了&#39;)&#125;)从输出结果上看，特点是按照顺序逐步完成某动作，似乎本身就是一个generator于是把每个动作装到一个generator里function* practisePlan() &#123;    yield warmup(2)    yield squat(5)    yield boating(3)&#125;yield返回的是一个promise，promise ‘resolve’的情况下才会 ‘next’let practise &#x3D; function () &#123;    return new Promise((resolve, reject)&#x3D;&gt;&#123;        const plan &#x3D; practisePlan()        Promise.resolve(plan.next().value).then(result&#x3D;&gt;&#123;            if(result) console.log(&#39;热身完成。。&#39;)            return plan.next().value;        &#125;).then(result&#x3D;&gt;&#123;            if(result) console.log(&#39;深蹲完成。。&#39;)            return plan.next().value;        &#125;).then(result&#x3D;&gt;&#123;            if(result) console.log(&#39;划船完成。。&#39;)            resolve() &#x2F;&#x2F; &lt;--完了        &#125;)    &#125;)&#125;再看循环中的async await的栗子 —-&gt; S-为什么说 async/await是generator的语法糖？\n","tags":["ES6"]},{"title":"CMake","url":"/qqsnote/2024/07/18/cmake/","content":"CMake 是通用的自动化构建工具, 可用于构建各种类型的项目，包括C++、C、Python、Java等\nCMake 是个“链接”的工具 假设有牛人用文本编辑器写了很精妙的代码 传给了你 你在使用编译工具build出可执行文件之前 需要将离散的源代码文件 组织成IDE可以加载的项目(如vcxproject, sln)  这时便需要CMake\n将源代码文件添加到CMake 设置好生成目标(如Visual Studio 16 2019, Ninja, MinGW)\n项目的CMake构建配置文件CMakeLists.txt(文件名固定，区分大小写)形如# 指定CMake版本cmake_minimum_required(VERSION 3.10) # 指定项目名称 project(hello)  # 设置构建变量set(CMAKE_MODULE_PATH $&#123;CMAKE_MODULE_PATH&#125; &quot;$&#123;CMAKE_SOURCE_DIR&#125;&#x2F;CMake&quot;)# 添加源代码文件add_executable(hello hello.cpp)基于配置文件构建项目：mkdir build  # 创建一个build文件夹cd build  # 进入build文件夹cmake  ..  # 生成Makefile文件 ..表示去上级目录找到并使用CMakeLists.txtmake  # 编译源代码并生成可执行文件对于将使用vs开发的项目 如cmake -G &quot;Visual Studio 16 2019&quot; ..\n","categories":["工具"],"tags":["C++"]},{"title":"axios","url":"/qqsnote/2025/08/01/axios/","content":"相比fetch Api, axios 提供了更简洁、更直观的 API，使得发送 HTTP 请求和处理响应更加方便; 自动处理json对象（fetch 可以调用await response.json()）axios.post(&#39;&#x2F;api&#x2F;submit&#39;, this.editForm)        .then(response &#x3D;&gt; &#123;          console.log(&#39;Form submitted successfully:&#39;, response.data);        &#125;)        .catch(error &#x3D;&gt; &#123;          console.error(&#39;Error submitting form:&#39;, error);        &#125;);      axios.request(&#123;        url: &#39;&#x2F;api&#x2F;submit&#39;,        method: &#39;post&#39;,        data: this.editForm      &#125;).then(response &#x3D;&gt; &#123;        console.log(&#39;Form submitted successfully:&#39;, response.data);      &#125;).catch(error &#x3D;&gt; &#123;        console.error(&#39;Error submitting form:&#39;, error);      &#125;);instanceconst instance &#x3D; axios.create(&#123; baseURL: &#39;&#x2F;api&#39; &#125;);&#x2F;&#x2F; Works just like axios(config)instance(&#123;  url: &#39;&#x2F;users&#39;,  method: &#39;get&#39;&#125;);拦截器&#x2F;&#x2F; Add a request interceptoraxios.interceptors.request.use(function (config) &#123;    &#x2F;&#x2F; Do something before request is sent    return config;  &#125;, function (error) &#123;    &#x2F;&#x2F; Do something with request error    return Promise.reject(error);  &#125;,  &#123; synchronous: true, runWhen: () &#x3D;&gt; &#x2F;* This function returns true *&#x2F;&#125;);&#x2F;&#x2F; Add a response interceptoraxios.interceptors.response.use(function onFulfilled(response) &#123;    &#x2F;&#x2F; Any status code that lie within the range of 2xx cause this function to trigger    &#x2F;&#x2F; Do something with response data    return response;  &#125;, function onRejected(error) &#123;    &#x2F;&#x2F; Any status codes that falls outside the range of 2xx cause this function to trigger    &#x2F;&#x2F; Do something with response error    return Promise.reject(error);  &#125;);\n","tags":["axios"]},{"title":"color_science","url":"/qqsnote/2022/07/14/color-science/","content":"HSB模型和RGB模型，CMYK模型H色相（Hue）：色调是当人眼看一种或多种波长的光时所产生的色彩感觉，它反映颜色的种类，是决定颜色的基本特征。S饱和度(Saturability)：饱和度是指颜色的纯度即掺入白光的程度，表示颜色深浅的程度。B亮度(Brightness)：亮度是光作用于人眼所引起的明亮程度的感觉，它与被观察物体的发光强度有关。主要表现光的强和弱。 \nHSB模型 无法用于工程制造RGB模型 用于发光体 不适用于反光物体CMYK模型 青洋红黄黑 用于反光体配色\n色彩空间色域马蹄图的由来混合红绿蓝三束光 通过调节三束光的强度 使之与待测光看起来颜色一致 以红绿蓝的强度值作为待测光的“三刺激值”\n\nC(C) = R(R) + G(G) + B(B)这里在数学上等同于和向量和分量的关系，于是以R、G、B分量构建三维坐标系\n上述参数归一化 成为RGB坐标系中的色品坐标:\n\n(\\frac{R}{R+G+B},\\frac{G}{R+G+B},\\frac{B}{R+G+B})注意这里的代数可以为负值，这种情况是三原色光无论如何无法与待测光一致，需向待测光加入原色光补偿\n在这套系统上，测试/分解其他波长色光，得到一条单位平面的曲线，即光谱轨迹\n在单位平面上 有一点使R，G，B原色混合可以产生等能的白光，称为等能白点，（当R，G，B为标准原色时）该点坐标为(0.33,0.33,0.33)\n光谱轨迹坐标为负值的部分，无法用于实际生产，应做左边变换使\n色彩校准color correction matrix(CCM)\nsRGBstandard color space 标准色彩空间 为使图像在显示时使人感受与原物一致 根据三色刺激值线性变换得到的RGB色彩空间在有较高需求的领域，往往有ICC配置文件 将输出图像颜色空间映射到sRGB 或将sRGB图像数据信息 变换后输出到具体设备或环境以优化还原效果\n灰度计算和Gamma矫正\nGray = 0.299R + 0.587G + 0.114B因为人眼对不同颜色的亮度（显像功率）的感知到的不是线性关系，每种颜色的“中等深度”与人眼感受的“中等灰度”存在差距上述公式是根据人眼对不同颜色敏感度的差异来推导的，它使得灰度图像能够更好地表示原始图像中的亮度信息。\n根据三色刺激值对色彩光本身的辉度做出的调整就是Gamma矫正\n","categories":["图像处理"],"tags":["OpenCV"]},{"title":"conda","url":"/qqsnote/2023/03/06/conda/","content":"安装Anaconda后 默认只能在conda prompt中使用，若在cmd控制台使用conda命令需要将Anaconda/Scripts/目录加入环境变量\n源可以形如下添加源的命令conda config --add channels - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;freeconda config --add channels - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main\n或编辑用户目录下的.condarc文件 如channels:  - defaultsauto_activate_base: trueanaconda_upload: falseshow_channel_urls: truedefaults_channels:  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;main  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;r  - https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;msys2custom_channels:  conda-forge: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud  msys2: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud  bioconda: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud  menpo: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud  pytorch: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud  pytorch-lts: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud  simpleitk: https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud清理环境缓存conda clean -i显示channelsconda show channels\n创建指定python版本的虚拟环境conda create -n py310 python&#x3D;3.10.6\n\nTroubleShooting CondaHTTPError: HTTP 000 CONNECTION FAILED for url ＜https://repo.anaconda.com/pkgs/main/nux-64\n错误原因 D:\\Anaconda3\\DLLs_ssl.pyd会寻找依赖库OpenSSL DLLs，由于项目目录下未找到，它会去默认目录C:\\Windows\\System32查找，默认目录下存在该库，但是别的应用安装的，版本不一致，所以出现上述错误。\n解决方法：从目录D:\\Anaconda3\\Library\\bin下复制libcrypto-1_1-x64.和libssl-1_1-x64.到D:\\Anaconda3\\DLLs，这样就会在项目目录下直接查找到该库了。 参考CSDN Blog\n\n激活虚拟环境列出环境conda env list激活conda activate py310\n\nTroubleShooting  Your shell has not been properly configured to use ‘conda activate’. If using ‘conda activate’ from a batch script, change your invocation to ‘CALL conda.bat activate’.\n管理员权限打开命令行 conda init cmd.exe, 同理powershell bash等终端，重启命令行即可执行activate命令 注意conda init后需要重启命令行\n\n安装、更新、卸载包conda install pandasconda update pandasconda remove pandasconda env listconda env remove -n py310 #清除所有\nPycharm中配置python interpreter使用conda环境Settings -&gt; Project: XXXX -&gt; Python Interpreter -&gt; Add Interpreter\n弹窗中type切换成Conda 配置conda路径如D:\\Software\\Anaconda\\Scripts\\conda.exe\nreload environments\n","categories":["工具"],"tags":["Python"]},{"title":"领域驱动设计","url":"/qqsnote/2020/08/25/ddd/","content":"领域驱动设计(Domain-Driven Design, DDD), 对于复杂的系统的开发, 从需求梳理到编码实现,将涉及的专业知识转换成模型、逻辑是必不可少的环节，这些信息和知识会汇集到若干核心的“领域”，接下来的设计重心会落在核心领域范畴内，确定域界地沟通方式，迭代地在域内完成实现，而不似单纯地服务端的功能堆叠。\n"},{"title":"深拷贝","url":"/qqsnote/2019/08/12/deepcopy/","content":"之前只知道JSON.parse(JSON.stringify(obj))简单实用，可以应付一般对象的场景，其实，这种方式还是有缺陷的————抛弃了原型及构造方法（原类型变成Object），另外JSON序列化会忽略违法安全原则的类型，如undefined、function、symbol（ES6+）、RegExp对象，以及循环引用无法复制,ajson &#x3D; &#123;a:undefined,b:function()&#123;return 1;&#125;&#125; &#x2F;&#x2F;&#123;a: undefined, b: ƒ&#125;bjson &#x3D; JSON.parse(JSON.stringify(ajson))     &#x2F;&#x2F;&#123;&#125;深拷贝是各种库都会涉及的工具，也是面试老生常谈的问题\njQueryjQuery提供了拷贝DOM对象的clone()方法clone: function( dataAndEvents, deepDataAndEvents ) &#123;    dataAndEvents &#x3D; dataAndEvents &#x3D;&#x3D; null ? false : dataAndEvents;    deepDataAndEvents &#x3D; deepDataAndEvents &#x3D;&#x3D; null ? dataAndEvents : deepDataAndEvents;    return this.map( function() &#123;        return jQuery.clone( this, dataAndEvents, deepDataAndEvents );    &#125; );&#125;,.clone( [withDataAndEvents ] [, deepWithDataAndEvents ] )withDataAndEvents Type：Boolean(default: false)deepWithDataAndEvents Type: Boolean(default: value of withDataAndEvents)通过调用extend()实现深拷贝：var x&#x3D;&#123;a:1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [ 1, 2, 3 ]&#125;;var y &#x3D; $.extend(true, &#123;&#125;, x);合并对象方法，将第三个及之后的参数对象的各属性合并到target：jQuery.extend( [deep ], target, object1[, objectN ] )deep = true 则以深拷贝处理 无此参数相当于false\nlodash一个JavaScript工具库,lodash提供_.cloneDeep()方法，该方法用了大量代码实现对ES6新标准对象的支持。\n原型拷贝方式作者: Jerry Zhou 原文:深入剖析 JavaScript 的深复制该方法对各种类型进行了细致的分类处理，并且考虑到了存在环形引用关系，以及保留对象所属自定义类型定义defineMethod，用于向各种类型的原型上面添加自定义方法&#x2F;*  * protoArray需修改的原型的集合 * nameToFunc自定义方法的map *&#x2F;function defineMethods(protoArray, nameToFunc) &#123;    protoArray.forEach(function(proto) &#123;        var names &#x3D; Object.keys(nameToFunc),            i &#x3D; 0;        for (; i &lt; names.length; i++) &#123;            Object.defineProperty(proto, names[i], &#123;                enumerable: false,                configurable: true,                writable: true,                value: nameToFunc[names[i]]            &#125;);        &#125;    &#125;);&#125;关于Object.defineProperty()存目\n首先对于Number, Boolean 和 StringdefineMethods([    Number.prototype,    Boolean.prototype,    String.prototype], &#123;    &#39;$clone&#39;: function() &#123; return this.valueOf(); &#125;&#125;);私以为，按照作者的理念此处应该返回对象（String，Number，Boolean），然而valueOf()出来的都是值类型（string，number，bool），如果返回对象，需要分开写比如 function() { return new String(this.valueOf()) 像他处理Date类型一样defineMethods([ Date.prototype ], &#123;        &#39;$clone&#39;: function() &#123; return new Date(this.valueOf()); &#125;    &#125;);重点在于Object 和 Array 对象，需要递归深拷贝defineMethods([ Array.prototype, Object.prototype ], &#123;    &#39;$clone&#39;: function (srcStack, dstStack) &#123;        var obj &#x3D; Object.create(Object.getPrototypeOf(this)),            keys &#x3D; Object.keys(this),            index,            prop;        srcStack &#x3D; srcStack || [];        dstStack &#x3D; dstStack || [];        srcStack.push(this);        dstStack.push(obj);        for (var i &#x3D; 0; i &lt; keys.length; i++) &#123;            prop &#x3D; this[keys[i]];            if (prop &#x3D;&#x3D;&#x3D; null || prop &#x3D;&#x3D;&#x3D; undefined) &#123;                obj[keys[i]] &#x3D; prop;            &#125;else if()                                     if (!prop instanceOf Function) &#123;                if (prop.constructor.name&#x3D;&#x3D;&#x3D;&#39;Object&#39;) &#123;                    index &#x3D; srcStack.lastIndexOf(prop);                    if (index &gt; 0) &#123;                        obj[keys[i]] &#x3D; dstStack[index];                        continue;                    &#125;                &#125;                obj[keys[i]] &#x3D; prop.$clone(srcStack, dstStack);            &#125;        &#125;        return obj;    &#125;&#125;)注意 原生的js中没有一个可靠的方法确定对象的类型，人家本来就是这样的精神————‘弱类型’，typeof 和 instanceof 都会混淆各种类型，而上面的constructor.name返回构造方法名称，而未必就是类名，因此也是不严谨的，原文作者为每种类型定义了$isFunction、$isPlainObject等属性方法来区分类型此外$clone()还需处理RegExp对象 Function等defineMethods([ RegExp.prototype ], &#123;    &#39;$clone&#39;: function () &#123;        var pattern &#x3D; this.valueOf();        var flags &#x3D; &#39;&#39;;        flags +&#x3D; pattern.global ? &#39;g&#39; : &#39;&#39;;        flags +&#x3D; pattern.ignoreCase ? &#39;i&#39; : &#39;&#39;;        flags +&#x3D; pattern.multiline ? &#39;m&#39; : &#39;&#39;;        return new RegExp(pattern.source, flags);    &#125;&#125;);\nES6实现一个完美的深拷贝方法是很繁琐复杂甚至是没有必要的，有些轮子是必要的，而在生产实践中，不说因地制宜，实现方式的复杂度是必须考量的。探究比较深拷贝方法的优劣，其实是对原型，类型等概念的深刻理解的比较好的实践。\n","categories":["前端技术"],"tags":["javascript"]},{"title":"dotNetCore-AppStartupTime","url":"/qqsnote/2023/05/12/dotNetCore-AppStartupTime/","content":"关于冷启动启动 WPF 应用程序所需的时间可能存在极大差异。冷启动发生在系统重启后第一次启动应用程序时，或启动应用程序、将其关闭，然后在很长一段时间后再次启动应用程序时。 应用程序启动时，如果所需的页面（代码、静态数据、注册表等）不在 Windows 内存管理器的待机列表中，会发生页面错误。 需要磁盘访问权限，以便将这些页面加载到内存中。\n当已将主要公共语言运行时 (CLR) 组件的大多数页面加载到内存中时，则发生热启动，这样可节省宝贵的磁盘访问时间。 这就是为什么再次运行托管的应用程序时，该程序的启动速度更快的原因。\nQQs: 冷启动是关于app资源从硬盘到内存的访问权的unefficient\n使用初始屏幕增强体验在app启动就绪之前，渲染一个初始屏幕以安慰等待用户\n添加图像资源（BMP、GIF、JPEG、PNG 或 TIFF 格式）到项目，在解决方案资源管理器中打开图像Properties—&gt;Build Action选择SplashScreen\nI/O重新启动后，立即启动 WPF 应用程序，并决定用于显示的时间。 如果应用程序的所有后续启动（热启动）相较之下快很多，则冷启动问题很可能是 I/O 所致。\n模块加载进程资源管理器 Procexp.exe命令行工具 tasklist /M (显示进程调用的dll)\n","tags":[".Net"]},{"title":".Net Core Authentication & Authorization","url":"/qqsnote/2020/05/09/dotNetCore-Authentication/","content":"关于认证参考ASP.NET Core 中的那些认证中间件及一些重要知识点\n\n在 ASP.NET Core 中，身份验证由 IAuthenticationService 负责，而它供身份验证中间件使用。\n\n身份验证中间件\n\n已注册的身份验证处理程序及其配置选项被称为“方案（schema）”。\nAuthentication schemes are specified by registering authentication services in Startup.ConfigureServices:在startup.cs的ConfigureServices中通过注册身份认证，指定认证方案public void ConfigureServices(IServiceCollection services)&#123;    services.AddAuthentication(&quot;YourSchemaName&quot;)    .AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, options &#x3D;&gt; Configuration.Bind(&quot;JwtSettings&quot;, options))    .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, options &#x3D;&gt; Configuration.Bind(&quot;CookieSettings&quot;, options));&#125;AddAuthentication的参数是方案名称，默认值为JwtBearerDefaults.AuthenticationScheme(即”Bearer”)。\n\n可使用多种身份验证方案public void ConfigureServices(IServiceCollection services)&#123;    &#x2F;&#x2F; 认证方案    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)        .AddJwtBearer(options &#x3D;&gt;        &#123;            options.Audience &#x3D; &quot;https:&#x2F;&#x2F;localhost:5000&#x2F;&quot;;            options.Authority &#x3D; &quot;https:&#x2F;&#x2F;localhost:5000&#x2F;identity&#x2F;&quot;;        &#125;)        .AddJwtBearer(&quot;AzureAD&quot;, options &#x3D;&gt;        &#123;            options.Audience &#x3D; &quot;https:&#x2F;&#x2F;localhost:5000&#x2F;&quot;;            options.Authority &#x3D; &quot;https:&#x2F;&#x2F;login.microsoftonline.com&#x2F;eb971100-6f99-4bdc-8611-1bc8edd7f436&#x2F;&quot;;        &#125;);    &#x2F;&#x2F; 授权访问    services.AddAuthorization(options &#x3D;&gt;    &#123;        var defaultAuthorizationPolicyBuilder &#x3D; new AuthorizationPolicyBuilder(            JwtBearerDefaults.AuthenticationScheme,            &quot;AzureAD&quot;);        defaultAuthorizationPolicyBuilder &#x3D;             defaultAuthorizationPolicyBuilder.RequireAuthenticatedUser();        options.DefaultPolicy &#x3D; defaultAuthorizationPolicyBuilder.Build();    &#125;);&#125;再说方案名称（AuthenticationScheme），可使用方案名称来指定应使用哪种（或哪些）身份验证方案来对用户进行身份验证。 当配置身份验证时，通常是指定默认身份验证方案。除非资源请求了特定方案，否则使用默认方案。\n授权策略（authorization policy）下文中有使用特性注解为资源（如api）指定授权方案的栗子自定义策略提供程序-IAuthorizationPolicyProvider\n文章Asp.Net Basic Authentication自定义了使用Basic Auth进行认证的方案，配置方案如services.AddAuthentication(&quot;BasicAuthentication&quot;)    .AddScheme&lt;AuthenticationSchemeOptions, BasicAuthenticationHandler&gt;(&quot;BasicAuthentication&quot;, null);\nBasicAuthenticationHandler是自定义的身份验证处理类，派生自AuthenticationHandler\\public class BasicAuthenticationHandler : AuthenticationHandler&lt;AuthenticationSchemeOptions&gt;&#123;    private readonly IUserService _userService;    public BasicAuthenticationHandler(        IOptionsMonitor&lt;AuthenticationSchemeOptions&gt; options,        ILoggerFactory logger,        UrlEncoder encoder,        ISystemClock clock,        IUserService userService)        : base(options, logger, encoder, clock)    &#123;        _userService &#x3D; userService;    &#125;    protected override async Task&lt;AuthenticateResult&gt; HandleAuthenticateAsync()    &#123;        if (!Request.Headers.ContainsKey(&quot;Authorization&quot;))            return AuthenticateResult.Fail(&quot;Missing Authorization Header&quot;);        User user &#x3D; null;        try        &#123;            var authHeader &#x3D; AuthenticationHeaderValue.Parse(Request.Headers[&quot;Authorization&quot;]);            var credentialBytes &#x3D; Convert.FromBase64String(authHeader.Parameter);            var credentials &#x3D; Encoding.UTF8.GetString(credentialBytes).Split(new[] &#123; &#39;:&#39; &#125;, 2);            var username &#x3D; credentials[0];            var password &#x3D; credentials[1];            user &#x3D; await _userService.Authenticate(username, password);        &#125;        catch        &#123;            return AuthenticateResult.Fail(&quot;Invalid Authorization Header&quot;);        &#125;        if (user &#x3D;&#x3D; null)            return AuthenticateResult.Fail(&quot;Invalid Username or Password&quot;);        var claims &#x3D; new[] &#123;            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),            new Claim(ClaimTypes.Name, user.Username),        &#125;;        var identity &#x3D; new ClaimsIdentity(claims, Scheme.Name);        var principal &#x3D; new ClaimsPrincipal(identity);        var ticket &#x3D; new AuthenticationTicket(principal, Scheme.Name);        return AuthenticateResult.Success(ticket);    &#125;&#125;类型定义身份验证操作，负责根据请求上下文构造用户的身份。 返回一个 AuthenticateResult指示身份验证是否成功\n选择具有策略的方案.AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, options &#x3D;&gt; Configuration.Bind(&quot;JwtSettings&quot;, options))    .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, options &#x3D;&gt; Configuration.Bind(&quot;CookieSettings&quot;, options));\n\nASP.NET Core 中的授权通过 AuthorizeAttribute 和其各种参数来控制。 在最简单的形式中，将 [Authorize] 属性应用于控制器、操作或 Razor 页面，将对该组件的访问限制为任何经过身份验证的用户。namespace QQsServices.Controllers&#123;    [Authorize]    [Route(&quot;api&#x2F;v1&#x2F;[controller]&quot;)]    [ApiController]    public class UserController : ControllerBase    &#123;        ......    &#125;&#125;允许未通过验证的访问—AllowAnonymous[Authorize]public class AccountController : Controller&#123;    [AllowAnonymous]    public ActionResult Login()    &#123;    &#125;    public ActionResult Logout()    &#123;    &#125;&#125;Authorize从controller到action向下继承，而AllowAnonymous覆盖Authorize(AllowAnonymous优先级高于Authorize)\nJwtBearer持有者身份验证\nBasic Auth\nCors基于策略的授权startup.cspublic void ConfigureServices(IServiceCollection services)&#123;    services.AddControllersWithViews();    services.AddRazorPages();    services.AddAuthorization(options &#x3D;&gt;    &#123;        options.AddPolicy(&quot;PolicyBased01&quot;, policy &#x3D;&gt;            policy.Requirements.Add(new MinimumAgeRequirement(21)));    &#125;);&#125;\n指定特定授权方案参考 Authorize with a specific scheme in ASP.NET Core\n\nAn authentication scheme is named when the authentication service is configured during authentication. Startup的服务配置中, AddAuthentication后添加方案public void ConfigureServices(IServiceCollection services)&#123;    &#x2F;&#x2F; Code omitted for brevity    services.AddAuthentication()        .AddCookie(options &#x3D;&gt; &#123;            options.LoginPath &#x3D; &quot;&#x2F;Account&#x2F;Unauthorized&#x2F;&quot;;            options.AccessDeniedPath &#x3D; &quot;&#x2F;Account&#x2F;Forbidden&#x2F;&quot;;        &#125;)        .AddJwtBearer(options &#x3D;&gt; &#123;            options.Audience &#x3D; &quot;http:&#x2F;&#x2F;localhost:5001&#x2F;&quot;;            options.Authority &#x3D; &quot;http:&#x2F;&#x2F;localhost:5000&#x2F;&quot;;        &#125;);    ....&#125;使用授权属性选择方案[Authorize(AuthenticationSchemes &#x3D; JwtBearerDefaults.AuthenticationScheme)]public class MixedController : Controller.....使用策略并指定授权方案If you prefer to specify the desired schemes in policy, you can set the AuthenticationSchemes collection when adding your policy. 添加授权策略时设置AuthenticationSchemes列表，将对应的scheme添加进去services.AddAuthorization(options &#x3D;&gt;&#123;    options.AddPolicy(&quot;Over18&quot;, policy &#x3D;&gt;    &#123;        policy.AuthenticationSchemes.Add(JwtBearerDefaults.AuthenticationScheme);        policy.RequireAuthenticatedUser();        policy.Requirements.Add(new MinimumAgeRequirement());    &#125;);&#125;);在属性中使用指定策略[Authorize(Policy &#x3D; &quot;Over18&quot;)]public class RegistrationController : Controller使用多种方案the following code in Startup.ConfigureServices adds two JWT bearer authentication schemes with different issuers:颁发者不同的两种JWT Bearer认证方案public void ConfigureServices(IServiceCollection services)&#123;    &#x2F;&#x2F; Code omitted for brevity    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)        .AddJwtBearer(options &#x3D;&gt;        &#123;            options.Audience &#x3D; &quot;https:&#x2F;&#x2F;localhost:5000&#x2F;&quot;;            options.Authority &#x3D; &quot;https:&#x2F;&#x2F;localhost:5000&#x2F;identity&#x2F;&quot;;        &#125;)        .AddJwtBearer(&quot;AzureAD&quot;, options &#x3D;&gt;        &#123;            options.Audience &#x3D; &quot;https:&#x2F;&#x2F;localhost:5000&#x2F;&quot;;            options.Authority &#x3D; &quot;https:&#x2F;&#x2F;login.microsoftonline.com&#x2F;eb971100-6f99-4bdc-8611-1bc8edd7f436&#x2F;&quot;;        &#125;);    ...&#125;更新授权策略, 上面两种JWTBearer认证方案，将一个要注册到默认认证方案“JwtBearerDefaults.AuthenticationScheme”，另外的认证方案需要以唯一的方案注册（Only one JWT bearer authentication is registered with the default authentication scheme JwtBearerDefaults.AuthenticationScheme. Additional authentication has to be registered with a unique authentication scheme.）public void ConfigureServices(IServiceCollection services)&#123;    &#x2F;&#x2F; Code omitted for brevity    services.AddAuthorization(options &#x3D;&gt;    &#123;        var defaultAuthorizationPolicyBuilder &#x3D; new AuthorizationPolicyBuilder(            JwtBearerDefaults.AuthenticationScheme,            &quot;AzureAD&quot;);        defaultAuthorizationPolicyBuilder &#x3D;             defaultAuthorizationPolicyBuilder.RequireAuthenticatedUser();        options.DefaultPolicy &#x3D; defaultAuthorizationPolicyBuilder.Build();    &#125;);&#125;\n\n参考在 ASP.NET Core 中使用 IAuthorizationPolicyProvider 的自定义授权策略提供程序\n","tags":[".Net","认证&授权"]},{"title":".Net Core的持续集成","url":"/qqsnote/2020/09/08/dotNetCore-CI/","content":"显然，.Net Core开发过程中，使用Visual Studio提供的近乎完美IDE，build和deploy都非常简单，如果说是用jenkins进行持续集成，那便相当于用脚本完成更新源码—构建—部署等过程。\njenkins ant\nApache Ant，是一个将软件编译、测试、部署等步骤联系在一起加以自动化的一个工具，大多用于Java环境中的软件开发。由Apache软件基金会所提供。默认情况下，它的buildfile(XML文件)名为build.xml。——————wiki\n\nbuild.xml定义了若干步骤（即target），以xml节点格式定义每个步骤的目录，执行程序，以及参数等&lt;?xml version&#x3D;&quot;1.0&quot; ?&gt; &lt;project name&#x3D;&quot;Hello World&quot; default&#x3D;&quot;execute&quot;&gt;\t&lt;target name&#x3D;&quot;init&quot;&gt;\t\t&lt;mkdir dir&#x3D;&quot;build&#x2F;classes&quot;&#x2F;&gt;\t\t&lt;mkdir dir&#x3D;&quot;dist&quot;&#x2F;&gt;\t&lt;&#x2F;target&gt;\t&lt;target name&#x3D;&quot;compile&quot; depends&#x3D;&quot;init&quot;&gt;\t\t&lt;javac srcdir&#x3D;&quot;src&quot; destdir&#x3D;&quot;build&#x2F;classes&quot;&#x2F;&gt;\t&lt;&#x2F;target&gt;\t\t&lt;target name&#x3D;&quot;compress&quot; depends&#x3D;&quot;compile&quot;&gt;\t        &lt;jar destfile&#x3D;&quot;dist&#x2F;HelloWorld.jar&quot; basedir&#x3D;&quot;build&#x2F;classes&quot;  &#x2F;&gt;\t&lt;&#x2F;target&gt;\t&lt;target name&#x3D;&quot;execute&quot; depends&#x3D;&quot;compile&quot;&gt;\t\t&lt;java classname&#x3D;&quot;HelloWorld&quot; classpath&#x3D;&quot;build&#x2F;classes&quot;&#x2F;&gt;\t&lt;&#x2F;target&gt;&lt;&#x2F;project&gt;在Jenkins中可以配置使用Apache Ant，在构建时便可以使用build.xml来管理步骤源码目录build/build.xml:&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;project name&#x3D;&quot;PartnerPortal&quot; default&#x3D;&quot;PartnerPortal&quot; basedir&#x3D;&quot;.&quot;&gt;\t&lt;description&gt;\tPartnerPortal Daily Build File.\t&lt;&#x2F;description&gt;\t&lt;property file&#x3D;&quot;build.properties&quot;&#x2F;&gt;\t\t&lt;target name&#x3D;&quot;build_partner_portal&quot; description&#x3D;&quot;Build CS ScanFlow with Microsoft Visual Studio&quot;&gt;\t\t&lt;echo message&#x3D;&quot;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;      build CSD PP x64         &quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;MSVC    : $&#123;msbuild.exe&#125;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;root    : $&#123;root_dir&#125;&quot;&#x2F;&gt;\t\t&lt;exec dir&#x3D;&quot;.&quot; executable&#x3D;&quot;restore_dotnet.bat&quot; failonerror&#x3D;&quot;true&quot; &#x2F;&gt;\t\t&lt;exec dir&#x3D;&quot;.&quot; executable&#x3D;&quot;$&#123;msbuild.exe&#125;&quot; failonerror&#x3D;&quot;true&quot;&gt;\t\t\t&lt;arg line&#x3D;&quot;..&#x2F;CSD.PartnerPortal.sln &#x2F;property:Configuration&#x3D;Release&quot;&#x2F;&gt;\t\t&lt;&#x2F;exec&gt;\t&lt;&#x2F;target&gt;\t\t&lt;target name&#x3D;&quot;restore_envirement&quot; description&#x3D;&quot;restore dotnet&quot;&gt;\t\t&lt;echo message&#x3D;&quot;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;      restore dotnet         &quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;&quot;&#x2F;&gt;\t\t&lt;exec dir&#x3D;&quot;.&quot; executable&#x3D;&quot;restore_dotnet.bat&quot; failonerror&#x3D;&quot;true&quot; &#x2F;&gt;\t&lt;&#x2F;target&gt;\t\t&lt;target name&#x3D;&quot;publish_to_server&quot; description&#x3D;&quot;publish to server&quot;&gt;\t\t&lt;echo message&#x3D;&quot;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;      publish  start       &quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;&#x2F;&gt;\t\t&lt;echo message&#x3D;&quot;&quot;&#x2F;&gt;\t\t&lt;exec dir&#x3D;&quot;.&quot; executable&#x3D;&quot;publish.bat&quot; failonerror&#x3D;&quot;true&quot; &#x2F;&gt;\t&lt;&#x2F;target&gt;\t&lt;target name &#x3D;&quot;PartnerPortal&quot; description&#x3D;&quot;Build solution&quot;&gt;\t\t&lt;antcall target&#x3D;&quot;restore_envirement&quot; &#x2F;&gt;\t\t&lt;antcall target&#x3D;&quot;build_partner_portal&quot; &#x2F;&gt;\t\t&lt;antcall target&#x3D;&quot;publish_to_server&quot; &#x2F;&gt;\t&lt;&#x2F;target&gt;&lt;&#x2F;project&gt;build/restore_dotnet.bat:dotnet restore ..&#x2F;CSD.PartnerPortal.slnbuild/publish.bat:dotnet publish --no-build -c Release &quot;..\\CSD.PartnerPortal.csproj&quot; &#x2F;p:PublishProfile&#x3D;&quot;..\\Properties\\PUblishProfiles\\CSDPPci - Web Deploy.pubxml&quot; &#x2F;p:Password&#x3D;xxxxxxxxxxxxxxxxxxxxxxxxxxx项目的Properties目录下的 .pubxml配置：&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;Project ToolsVersion&#x3D;&quot;4.0&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;developer&#x2F;msbuild&#x2F;2003&quot;&gt;  &lt;PropertyGroup&gt;    &lt;WebPublishMethod&gt;MSDeploy&lt;&#x2F;WebPublishMethod&gt;    &lt;ResourceId&gt;&#x2F;subscriptions&#x2F;subscriptionid01&#x2F;resourceGroups&#x2F;resourcegroupname01&#x2F;providers&#x2F;Microsoft.Web&#x2F;sites&#x2F;CSDPPci&lt;&#x2F;ResourceId&gt;    &lt;ResourceGroup&gt;resourcegroupname01&lt;&#x2F;ResourceGroup&gt;    &lt;PublishProvider&gt;AzureWebSite&lt;&#x2F;PublishProvider&gt;    &lt;LastUsedBuildConfiguration&gt;Release&lt;&#x2F;LastUsedBuildConfiguration&gt;    &lt;LastUsedPlatform&gt;Any CPU&lt;&#x2F;LastUsedPlatform&gt;    &lt;SiteUrlToLaunchAfterPublish&gt;http:&#x2F;&#x2F;csdppci.azurewebsites.net&lt;&#x2F;SiteUrlToLaunchAfterPublish&gt;    &lt;LaunchSiteAfterPublish&gt;True&lt;&#x2F;LaunchSiteAfterPublish&gt;    &lt;ExcludeApp_Data&gt;False&lt;&#x2F;ExcludeApp_Data&gt;    &lt;ProjectGuid&gt;2df39477-f1f3-4522-9ca7-d0eefb5b16b7&lt;&#x2F;ProjectGuid&gt;    &lt;MSDeployServiceURL&gt;csdppci.scm.azurewebsites.net:443&lt;&#x2F;MSDeployServiceURL&gt;    &lt;DeployIisAppPath&gt;CSDPPci&lt;&#x2F;DeployIisAppPath&gt;    &lt;RemoteSitePhysicalPath &#x2F;&gt;    &lt;SkipExtraFilesOnServer&gt;True&lt;&#x2F;SkipExtraFilesOnServer&gt;    &lt;MSDeployPublishMethod&gt;WMSVC&lt;&#x2F;MSDeployPublishMethod&gt;    &lt;EnableMSDeployBackup&gt;True&lt;&#x2F;EnableMSDeployBackup&gt;    &lt;UserName&gt;$CSDPPci&lt;&#x2F;UserName&gt;    &lt;_SavePWD&gt;True&lt;&#x2F;_SavePWD&gt;    &lt;_DestinationType&gt;AzureWebSite&lt;&#x2F;_DestinationType&gt;    &lt;InstallAspNetCoreSiteExtension&gt;False&lt;&#x2F;InstallAspNetCoreSiteExtension&gt;  &lt;&#x2F;PropertyGroup&gt;&lt;&#x2F;Project&gt;\n","categories":["工具"],"tags":[".Net","Jenkins"]},{"title":".Net Core 依赖注入","url":"/qqsnote/2020/11/26/dotNetCore-DI-IoC/","content":"通常调用一个功能，将其所属类型new出一个实例，随后调用这个对象的方法，new的过程使用具体的构造方法，后来我们将接口和实现分离，调用功能的地方用接口编码，而具体实现的方法在某处独立配置，一旦需要修改实现，不至于到处替换代码。\nASP.NET Core提供内置服务容器IServiceProvider,将服务注入到使用它的类的构造函数中。 框架负责创建依赖关系的实例，并在不再需要时将其释放。\n注册服务public void ConfigureServices(IServiceCollection services)&#123;    services.AddSingleton&lt;IDateTime, SystemDateTime&gt;();    services.AddControllersWithViews();&#125;\n其中IDateTime是接口类，SystemDateTime是前者的实现类，AddSingleton(IServiceCollection, Type)方法将 serviceType 中指定类型的单一实例服务添加到指定的 IServiceCollection 中。以生命周期区分的三种方式还有services.AddScoped()的注册方式以及services.AddTransient()方式， 区别如下\n\nsingleton： IoC容器将在应用程序的整个生命周期内创建和共享服务的单个实例。\ntransient：每次您请求时，IoC容器都会创建一个指定服务类型的新实例。\nscope： IoC容器将为每个请求创建一次指定服务类型的实例，并将在单个请求中共享。构造函数注入调用接口时，将接口类作为构造函数参数public class Index2Model : PageModel&#123;    private readonly IMyDependency _myDependency;    public Index2Model(IMyDependency myDependency)    &#123;        _myDependency &#x3D; myDependency;                &#125;    public void OnGet()    &#123;        _myDependency.WriteMessage(&quot;Index2Model.OnGet&quot;);    &#125;&#125;\nFromServices attribute注入public IActionResult About([FromServices] IDateTime dateTime)&#123;    return Content( $&quot;Current server time: &#123;dateTime.Now&#125;&quot;);&#125;\nController settings注入setttings类public class SampleWebSettings&#123;    public string Title &#123; get; set; &#125;    public int Updates &#123; get; set; &#125;&#125;\n将Configuration类加入到services collectionpublic void ConfigureServices(IServiceCollection services)&#123;    services.AddSingleton&lt;IDateTime, SystemDateTime&gt;();    services.Configure&lt;SampleWebSettings&gt;(Configuration);    services.AddControllersWithViews();&#125;\n\n","tags":[".Net"]},{"title":".Net Core 数据访问","url":"/qqsnote/2020/06/11/dotNetCore-DataAccess/","content":"关于ORM参考阮一峰《ORM 实例教程》:面向对象编程（我们的后台）把所以实体看成对象（即Object），关系型数据库则是采用实体之间的关系（即Relation）连接数据，打通后台对象和关系数据库之间的关系而做的映射（Mapping）就是ORM。或者说ORM是通过对象实例语法，完成关系型数据库操作的技术。\n举个栗子SELECT id, first_name, last_name, phone, birth_date, sex FROM persons  WHERE id &#x3D; 10编程调用SQL的写法大致是res &#x3D; db.execSql(sql);name &#x3D; res[0][&quot;FIRST_NAME&quot;];ORM要实现的写法是p &#x3D; Person.get(10);name &#x3D; p.first_name;优点：\n\n数据模型都在一个地方定义，更容易更新和维护，也利于重用代码。\nORM 有现成的工具，很多功能都可以自动完成，比如数据消毒、预处理、事务等等。\n它迫使你使用 MVC 架构，ORM 就是天然的 Model，最终使代码更清晰。\n基于 ORM 的业务代码比较简单，代码量少，语义性好，容易理解。\n你不必编写性能不佳的 SQL。\n\n缺点\n\nORM 库不是轻量级工具，往往需要花很多精力学习和设置。\n对于复杂的查询，ORM 要么是无法表达，要么是性能不如原生的 SQL。\nORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL。\n\n(删除线部分QQs不是特别赞同)\n同属ORM技术的比如 Hibernate, MyBatis注\n关于ODBC开放式数据库连接(Open Database Connection),连接数据库进行查询的规范(specification)\nentity framwork,dbcontext, datarepositoryInclude, ThenInclude:result &#x3D; await _context.employees.Where(employee &#x3D;&gt; employee.level &#x3D;&#x3D; highlvl)    .Include(employee &#x3D;&gt; employee.department)    .ThenInclude(department &#x3D;&gt; department.bills).ToListAsync();多对多关系会造成循环引用(circular reference)，默认情况下序列化类会报异常，参考Add mechanism to handle circular references when serializing\n\nDapper.net","tags":[".Net"]},{"title":".Net Core 诊断工具","url":"/qqsnote/2022/09/20/dotNetCore-Diagnostics/","content":"System.Diagnostics命名空间\n提供允许你与系统进程、事件日志和性能计数器进行交互的类。\n\nusing System.Diagnostics...class Program&#123;    static void Main(string[] args)&#123;        InitLog()        Trace.WriteLine($&quot;log is here&quot;)    &#125;    private static void InitLog()&#123;        string logDirectory &#x3D; @&quot;D:\\log\\&quot;        string timestamp &#x3D; DateTime.UtcNow.ToString(&quot;yyyyMMdd_HHmmss&quot;, CultureInfo.InvariantCulture);        logDirectory &#x3D; $&quot;&#123;logDirectory&#125;_&#123;timestamp&#125;.log&quot;;        Trace.Listeners.Add(new TextWriterTraceListener(File.CreateText(logDirectory)));        Trace.AutoFlush &#x3D; true；    &#125;&#125;","categories":["后端技术"],"tags":[".Net"]},{"title":"dotNetCore 异常处理","url":"/qqsnote/2023/05/24/dotNetCore-Exceptions/","content":"QQs     ：在.net程序中，处理因网络连接问题或者服务端故障造成的请求异常，应该捕获异常类型？ChatGPT ：\n\n在处理因网络连接问题或者服务端故障造成的请求异常时，应该捕获相应的异常类型，以便能够进行正确的处理和响应。\n在.Net中，常见的网络连接相关的异常包括SocketException、WebException、HttpRequestException等。这些异常通常都是由于网络连接问题或者服务端故障造成的。\n在捕获这些异常时，可以根据具体的情况进行处理。例如，在SocketException中，可以根据不同的SocketError类型进行不同的处理，如SocketError.ConnectionReset、SocketError.ConnectionRefused等等。在WebException中，可以根据StatusCode、Response等内容进行判断和处理。\n需要注意的是，捕获网络连接异常时，不应该过于通用，而是应该针对性地捕获相关的异常类型。过于通用的捕获会导致程序无法准确地判断和处理异常，从而可能造成不必要的后果。\n\nQQs     ：开发异常处理逻辑时，如何模拟socket exception的异常场景？ChatGPT ：\n\n要模拟socket exception的异常场景，可以使用一些技巧来使网络连接不可用或出现异常。\n\n使用无效IP地址：使用一个无效的IP地址来模拟连接被拒绝的情况。可以使用“0.0.0.0”或“localhost”等无效的IP地址。\n\n使用无效的端口号：使用一个未使用的端口号来模拟连接失败的情况。可以使用大于65535或小于0的端口号，或者使用已被占用的端口号。\n\n断开网络连接：可以断开计算机连接网络的网线或关闭Wi-Fi，模拟网络连接失败的情况。\n\n阻止网络流量：可以使用网络防火墙或代理服务器等工具来阻止网络流量，模拟无法连接到网络的情况。\n\n模拟超时：可以使用延迟工具或人为地使服务器响应变慢，模拟连接超时或响应超时的情况。\n\n\n需要注意的是，在进行模拟异常的时候，应该先测试代码是否可以正确处理常规情况下的流程，避免把程序带入模拟异常的陷阱中。同时，需要保证模拟异常的环境不能影响其他程序的正常运行。\n\nQQs     ：举例的SocketException和WebException，能给出具体代码吗？ChatGPT ：\n\n当Socket遇到连接重置或连接拒绝时，可以通过SocketException捕获异常并进行相应处理。例如：\n\ntry &#123;    // Socket连接代码&#125; catch(SocketException ex) &#123;    if(ex.SocketErrorCode == SocketError.ConnectionReset) &#123;        // 处理连接重置异常    &#125; else if(ex.SocketErrorCode == SocketError.ConnectionRefused) &#123;        // 处理连接拒绝异常    &#125; else &#123;        // 处理其他Socket异常    &#125;&#125;\n\n当网络请求发生错误时，可以通过WebException捕获异常并进行相应处理。例如：\n\ntry &#123;    // 发送网络请求代码&#125; catch(WebException ex) &#123;    if(ex.Status == WebExceptionStatus.ProtocolError) &#123;        var response = ex.Response as HttpWebResponse;        if(response != null) &#123;            if(response.StatusCode == HttpStatusCode.NotFound) &#123;                // 处理页面未找到异常            &#125; else &#123;                // 处理其他HTTP状态码异常            &#125;        &#125; else &#123;            // 处理其他协议异常        &#125;    &#125; else if(ex.Status == WebExceptionStatus.ConnectFailure) &#123;        // 处理连接失败异常    &#125; else &#123;        // 处理其他WebException异常    &#125;&#125;\n\n需要注意的是，在处理异常时，需要根据具体的异常类型、异常代码等信息进行判断和处理，从而保证能够处理所有可能出现的异常情况。\n\n","tags":[".Net"]},{"title":".Net Core 缓存","url":"/qqsnote/2020/10/08/dotNetCore-MemoryCache/","content":"参考 .net core 中的缓存内存using Microsoft.Extensions.Caching.Memory;public class HomeController : Controller&#123;    private IMemoryCache _cache;    public HomeController(IMemoryCache memoryCache)    &#123;        _cache &#x3D; memoryCache;    &#125;CacheKeys APIpublic static class CacheKeys&#123;    public static string Entry &#123; get &#123; return &quot;_Entry&quot;; &#125; &#125;    public static string CallbackEntry &#123; get &#123; return &quot;_Callback&quot;; &#125; &#125;    public static string CallbackMessage &#123; get &#123; return &quot;_CallbackMessage&quot;; &#125; &#125;    public static string Parent &#123; get &#123; return &quot;_Parent&quot;; &#125; &#125;    public static string Child &#123; get &#123; return &quot;_Child&quot;; &#125; &#125;    public static string DependentMessage &#123; get &#123; return &quot;_DependentMessage&quot;; &#125; &#125;    public static string DependentCTS &#123; get &#123; return &quot;_DependentCTS&quot;; &#125; &#125;    public static string Ticks &#123; get &#123; return &quot;_Ticks&quot;; &#125; &#125;    public static string CancelMsg &#123; get &#123; return &quot;_CancelMsg&quot;; &#125; &#125;    public static string CancelTokenSource &#123; get &#123; return &quot;_CancelTokenSource&quot;; &#125; &#125;&#125;缓存一个时间DateTime cacheTiming;&#x2F;&#x2F; Look for cache key.if (!_cache.TryGetValue(CacheKeys.Entry, out cacheEntry))&#123;    cacheEntry &#x3D; DateTime.Now;    &#x2F;&#x2F; Set cache options.    var cacheEntryOptions &#x3D; new MemoryCacheEntryOptions()        &#x2F;&#x2F; Keep in cache for this time, reset time if accessed.        .SetSlidingExpiration(TimeSpan.FromSeconds(3));    &#x2F;&#x2F; Save data in cache.    _cache.Set(CacheKeys.Entry, cacheTiming, cacheEntryOptions);&#125;取出缓存var timing &#x3D; _cache.Get&lt;DateTime?&gt;(CacheKeys.Entry);可调过期（slide expiration）时间和绝对过期（absolute expiration）时间\n\n可调过期：指定一个时间，TimeSpan，指定时间内有被Get缓存时间则顺延，否则过期\n绝对到期：指定在一个固定的时间点到期使用 SetSize、Size 和 SizeLimit 限制缓存大小\n\n","tags":[".Net"]},{"title":".Net Core 中间件","url":"/qqsnote/2020/07/27/dotNetCore-Middleware/","content":"这里的中间件概念和express.js中的是一致的,\n下面栗子的代码来源： Net Core中间件封装原理示例demo解析public static class RequestIpExtensions&#123;    public static IApplicationBuilder UseRequestIp(this IApplicationBuilder builder)    &#123;        return builder.UseMiddleware&lt;RequestIPMiddleware&gt;();    &#125;&#125;\n\neach middleware extension method is exposed on IApplicationBuilder through the Microsoft.AspNetCore.Builder namespace. 通过IApplicationBuilder接口方法引入中间件，IApplicationBuilder由Microsoft.AspNetCore.Builder命名空间提供\n\n中间件的具体实现public class RequestIPMiddleware&#123;    private readonly RequestDelegate _next;    private readonly ILogger _logger;    public RequestIPMiddleware(RequestDelegate next, ILoggerFactory loggerFactory)    &#123;        _next &#x3D; next;        _logger &#x3D; loggerFactory.CreateLogger&lt;RequestIPMiddleware&gt;();    &#125;    public async Task Invoke(HttpContext context)    &#123;        _logger.LogInformation(&quot;User Ip: &quot; + context.Connection.RemoteIpAddress.ToString());        await _next.Invoke(context);    &#125;&#125;使用中间Startup.cspublic void Configure(IApplicationBuilder app, IHostingEnvironment env)&#123;    ....    app.UseRequestIp();&#125;\n","tags":[".Net"]},{"title":".Net Core OData API解决方案","url":"/qqsnote/2022/01/07/dotNetCore-ODataApiSolution/","content":"创建新解决方案 使用webapi模板 new -&gt; Project -&gt; ASP.NET Core Web API template命令行工具参考Microsoft Doc： dotnet newmkdir MyServicescd MyServicesdotnet new slnmkdir srcdotnet new webapi -lang C# -o src&#x2F;MyServices.APIdotnet sln add src&#x2F;MyServices.API&#x2F;MyServices.API.csproj添加class library项目dotnet new classlib -lang C# -o src&#x2F;MyServices.EntityManagersdotnet new classlib -lang C# -o src&#x2F;MyServices.Modelsdotnet sln add src&#x2F;MyServices.EntityManagers&#x2F;MyServices.EntityManagers.csprojdotnet sln add src&#x2F;MyServices.Models&#x2F;MyServices.Models.csproj创建详细目录，如下─src    ├───MyServices.API    │   ├───Controllers    │   ├───Infrastructure    │   │   ├───ActionFilters    │   │   ├───DbContext    │   │   ├───Helpers    │   │   ├───OData    │   │   └───Security    │   └───Properties    ├───MyServices.EntityManagers    │   ├───interfaces    │   ├───Managers    │   └───Utilities    └───MyServices.Models        ├───Contexts        ├───DTO        ├───Enums        └───Migrations安装依赖API layer\n\nMicrosoft.AspNetCore.Mvc.NewtonsoftJson\nMicrosoft.AspNetCore.OData √\nMicrosoft.OData.ModelBuilder\nMicrosoft.EntityFrameworkCore √\nMicrosoft.EntityFrameworkCore.Design √\nMicrosoft.EntityFrameworkCore.SqlServer √\nMicrosoft.EntityFrameworkCore.Tools √\nSwashbuckle.AspNetCore √EntityManager layerNoneModel layer\nMicrosoft.EntityFrameworkCore\nMicrosoft.EntityFrameworkCore.Design\nMicrosoft.EntityFrameworkCore.SqlServer\n\n","categories":["后端技术"],"tags":[".Net","OData"]},{"title":"WebView2","url":"/qqsnote/2022/09/06/dotNetCore-WebView/","content":"WebView2使用 Microsoft Edge（要知道Edge也是fork自Chromium的分发版本） 作为绘制引擎, 展示web内容的混合应用控件可以认为Electron是WebView2的前辈 二者的原理是一样的\n\nWebView2 runtime is available on most Windows 10 and Windows 11 machines by default. But it may not be available on older platforms.\n\n若缺需要查看WebView2运行时是否安装 Microsoft Docs：检测是否已安装合适的 WebView2 运行时\nwebview vs webbrowserWebBrowser类\n","tags":[".Net","WPF"]},{"title":"dotNetCore-swagger","url":"/qqsnote/2022/01/05/dotNetCore-swagger/","content":"Microsoft DOc: Swagger/OpenAPI Swagger 项目已于 2015 年捐赠给 OpenAPI 计划，自此它被称为 OpenAPI。 是一个与语言无关的规范，用于描述 REST API。 它使计算机和用户无需直接访问源代码即可了解 REST API 的功能。\nvisual stuadio创建ASP.NET Core Web API项目模板，包含Enable OpenAPI support选项 即swagger页面初始startup.cs的配置是public void ConfigureServices(IServiceCollection services)&#123;    services.AddControllers();    services.AddSwaggerGen(c &#x3D;&gt;    &#123;        c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#123; Title &#x3D; &quot;WebApplication1&quot;, Version &#x3D; &quot;v1&quot; &#125;);    &#125;);&#125;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)&#123;    if (env.IsDevelopment())    &#123;        app.UseDeveloperExceptionPage();        app.UseSwagger();        app.UseSwaggerUI(c &#x3D;&gt; c.SwaggerEndpoint(&quot;&#x2F;swagger&#x2F;v1&#x2F;swagger.json&quot;, &quot;WebApplication1 v1&quot;));    &#125;    app.UseHttpsRedirection();    app.UseRouting();    app.UseAuthorization();    app.UseEndpoints(endpoints &#x3D;&gt;    &#123;        endpoints.MapControllers();    &#125;);&#125;配置加载名为swagger.json的接口描述，记作WebApplication1 v1的接口文档\nswagger.json不会自动生成 从controller获取接口文档由下述swagger的实现包完成\nSwashbuckle.AspNetCore启用xml注释右键API项目 -&gt; Properties -&gt; Build -&gt; OutputOutput path 为空 即项目根目录勾选XML documentation file 并命名services.AddSwaggerGen(c &#x3D;&gt;&#123;    c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#123; Title &#x3D; &quot;WebApplication1&quot;, Version &#x3D; &quot;v1&quot; &#125;);    c.DocInclusionPredicate((name, api) &#x3D;&gt; api.HttpMethod !&#x3D; null);    &#x2F;&#x2F; Locate the XML file being generated by ASP.NET    var xmlFiles &#x3D; Directory.GetFiles(AppContext.BaseDirectory, &quot;WebApplication1.API.xml&quot;, SearchOption.TopDirectoryOnly);    &#x2F;&#x2F; Tell Swagger to use those XML comments.    xmlFiles.ToList().ForEach(xmlFile &#x3D;&gt; c.IncludeXmlComments(xmlFile));&#125;);详情待续 参考Microsoft Doc：Swashbuckle入门\nOData API的接口文档（存目）","categories":["后端技术"],"tags":[".Net"]},{"title":"dotNetReflector","url":"/qqsnote/2022/07/25/dotNetReflector/","content":""},{"title":".Net Core 入坑","url":"/qqsnote/2020/05/09/dotNetCore-startup/","content":".net core\n.NET Core 是一个通用的开放源代码开发平台。 可以使用多种编程语言针对 x64、x86、ARM32 和 ARM64 处理器创建适用于 Windows、macOS 和 Linux 的 .NET Core 应用。 为云、IoT、客户端 UI 和机器学习提供了框架和 API。\n\n\n运行时和SDK运行 .NET Core 应用，需安装 .NET Core 运行时。创建 .NET Core 应用，需安装 .NET Core SDK。\n命令行工具在命令行键入dotnet —help 文章ASP和SPA有所应用。\n另，代码生成器（codesmith generator studio） 和Nhibernate Template 根据数据库表生成实体类及MVC分层结构\n\nNuGet包管理工具，用于安装依赖NuGet包或用于安装模板\n\nasp.net core  经典的 .net mvc 分层：  view controller model  asp.net (asp, Active Server Pages 动态服务器页面):\n路由  模型绑定  模型验证  依赖关系注入  筛选器  Areas  Web API  Testability  Razor查看引擎  强类型视图  标记帮助程序  查看组件\nProgram.cspublic class Program&#123;    public static void Main(string[] args)    &#123;        CreateHostBuilder(args).Build().Run();    &#125;    public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;        Host.CreateDefaultBuilder(args)            .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;            &#123;                webBuilder.UseStartup&lt;Startup&gt;();            &#125;);&#125;\nHost(宿主)为app提供运行环境并负责启动,创建HostBuilder,指定Startup作为启动类\nStartup.cspublic class Startup&#123;  public void ConfigureServices(IServiceCollection services)  &#123;    services.AddControllersWithViews();    services.AddDbContext&lt;DataServiceContext&gt;(options &#x3D;&gt;      options.UseSqlServer(Configuration.GetConnectionString(&quot;DataServiceContext&quot;)));  &#125;  public void Configure(IApplicationBuilder app)  &#123;      app.UseHttpsRedirection();      app.UseStaticFiles();      app.UseMvc();  &#125;&#125;\nstartup.cs中using所需地package，包括需要加载（use）地中间件。\n另，这里引入了SQL Server需要安装并引入 Microsoft.EntityFrameworkCore;Microsoft.EntityFrameworkCore.SqlServer;\nlaunchSettings.json依赖注入Iconfigure，读取配置文件public class OidcConfigurationController : ControllerBase&#123;    private IConfiguration _configuration;    public OidcConfigurationController(IConfiguration Configuration)    &#123;        _configuration &#x3D; Configuration;    &#125;    [HttpGet]    [Route(&quot;snmapi&#x2F;[controller]&#x2F;auth&quot;)]    public CSResult GetOidcConfigure()    &#123;        var authSettings &#x3D; new JObject&#123;            &#123; &quot;client_id&quot;, _configuration[&quot;Auth:client_id&quot;] &#125;,            &#123; &quot;redirect_uri&quot;, _configuration[&quot;Auth:redirect_uri&quot;] &#125;,            &#123; &quot;post_logout_redirect_uri&quot;, _configuration[&quot;Auth:post_logout_redirect_uri&quot;] &#125;,        &#125;;    &#125;&#125;只能逐个value地取值，其他读取方法见ASP.Net Core读取配置文件的三种方法\nProperties/launchSettings.json&#123;  &quot;iisSettings&quot;: &#123;    &quot;windowsAuthentication&quot;: false,    &quot;anonymousAuthentication&quot;: true,    &quot;iisExpress&quot;: &#123;      &quot;applicationUrl&quot;: &quot;http:&#x2F;&#x2F;localhost:8080&quot;,      &quot;sslPort&quot;: 0    &#125;  &#125;,  &quot;profiles&quot;: &#123;    &quot;IIS Express&quot;: &#123;      &quot;commandName&quot;: &quot;IISExpress&quot;,      &quot;launchBrowser&quot;: true,      &quot;environmentVariables&quot;: &#123;        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;      &#125;    &#125;,    &quot;RestrictedProductMaintenance&quot;: &#123;      &quot;commandName&quot;: &quot;Project&quot;,      &quot;launchBrowser&quot;: true,      &quot;environmentVariables&quot;: &#123;        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;      &#125;,      &quot;applicationUrl&quot;: &quot;https:&#x2F;&#x2F;localhost:5001;http:&#x2F;&#x2F;localhost:5000&quot;    &#125;  &#125;&#125;这个配置似乎都是关于运行asp的IIS的。\n创建Model\nissue: Unable to cast object of type ‘System.Guid’ to type ‘System.String’.SQL Server 的 uniqueidentifier类型列，在 .net core 中直接映射为Guid类型，不存在与string的隐式转换，因此对应Model里的字段应该是Guid，在必要的场合使用toString插入GuidGuid id &#x3D; Guid.NewGuid();Model定义中的数据库特性\n\n从数据库生成模型Scaffold-DbContext  &quot;Data Source&#x3D;HostName; Initial Catalog&#x3D;DBName; Persist Security Info&#x3D;True; User ID&#x3D;UserName; Password&#x3D;******;&quot; Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models\nDBContextpublic class DataServiceContext: DbContext&#123;    public DataServiceContext(DbContextOptions&lt;DataServiceContext&gt; options) : base(options)    &#123;    &#125;    public DbSet&lt;RestrictedProductDTO&gt; RestrictedProduct &#123; get; set; &#125;&#125;\n在Startup.cs中添加 public void ConfigureServices(IServiceCollection services)&#123;    services.AddControllersWithViews();    services.AddDbContext&lt;DataContext&gt;(options &#x3D;&gt;        options.UseSqlServer(Configuration.GetConnectionString(&quot;DataContext&quot;)));&#125;ConnectionString是从appsettings.json中读取的&quot;connectionStrings&quot;: &#123;    &quot;DataContext&quot;: &quot;Server&#x3D;sqlserver01;Database&#x3D;db01;Trusted_Connection&#x3D;False;user id&#x3D;user01;password&#x3D;xxxx;&quot;  &#125;,  ...数据上下文访问SQL Server，会提示安装Microsoft.EntityFrameworkCore这个数据库上下文将被注入controlloer或model中用以获取数据\ncontroller使用Add—Add New Scaffold Item（基架项）选择  MVC controlloer with views, using Entity Framework之后在对话框中配置业务需要的Model、Data context等，此举一并生成controller views dbcontext代码，views包含index，create，detail，edit，delete，视图上的请求会自动在controller中实现接口\nError There was an error running the selected code generator:”No parameterless constructor defined for type ‘XXController’”曾现此错误，是因为待注入的Data context未配置正确（在startup中添加configureService，其中的connectionstring配置在appsettings.json中）\n创建完成的基架controllerpublic class ProductsController : Controller&#123;    private readonly DataContext _context;    public ProductsController(DataContext context)    &#123;        _context &#x3D; context;    &#125;    &#x2F;&#x2F; GET: Products    public async Task&lt;IActionResult&gt; Index()    &#123;        return View(await _context.ProductData.ToListAsync());    &#125;    &#x2F;&#x2F; GET: Products&#x2F;Details&#x2F;5    public async Task&lt;IActionResult&gt; Details(string id)    &#123;        if (id &#x3D;&#x3D; null)        &#123;            return NotFound();        &#125;        var product &#x3D; await _context.ProductData            .FirstOrDefaultAsync(m &#x3D;&gt; m.Id &#x3D;&#x3D; id);        if (product &#x3D;&#x3D; null)        &#123;            return NotFound();        &#125;        return View(product);    &#125;    &#x2F;&#x2F; GET: Products&#x2F;Create    public IActionResult Create()    &#123;        return View();    &#125;    &#x2F;&#x2F; POST: Products&#x2F;Create    &#x2F;&#x2F; To protect from overposting attacks, enable the specific properties you want to bind to, for     &#x2F;&#x2F; more details, see http:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;317598.    [HttpPost]    [ValidateAntiForgeryToken]    public async Task&lt;IActionResult&gt; Create([Bind(&quot;Id,SN,Brand,CreateTime,ProductName,Restriction&quot;)] Product product)    &#123;        if (ModelState.IsValid)        &#123;            _context.Add(product);            await _context.SaveChangesAsync();            return RedirectToAction(nameof(Index));        &#125;        return View(product);    &#125;    &#x2F;&#x2F; GET: Products&#x2F;Edit&#x2F;5    public async Task&lt;IActionResult&gt; Edit(string id)    &#123;        if (id &#x3D;&#x3D; null)        &#123;            return NotFound();        &#125;        var product &#x3D; await _context.ProductData.FindAsync(id);        if (product &#x3D;&#x3D; null)        &#123;            return NotFound();        &#125;        return View(product);    &#125;    &#x2F;&#x2F; POST: Products&#x2F;Edit&#x2F;5    &#x2F;&#x2F; To protect from overposting attacks, enable the specific properties you want to bind to, for     &#x2F;&#x2F; more details, see http:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;317598.    [HttpPost]    [ValidateAntiForgeryToken]    public async Task&lt;IActionResult&gt; Edit(string id, [Bind(&quot;Id,SN,Brand,CreateTime,ProductName,Restriction&quot;)] Product product)    &#123;        if (id !&#x3D; product.Id)        &#123;            return NotFound();        &#125;        if (ModelState.IsValid)        &#123;            try            &#123;                _context.Update(product);                await _context.SaveChangesAsync();            &#125;            catch (DbUpdateConcurrencyException)            &#123;                if (!ProductExists(product.Id))                &#123;                    return NotFound();                &#125;                else                &#123;                    throw;                &#125;            &#125;            return RedirectToAction(nameof(Index));        &#125;        return View(product);    &#125;    &#x2F;&#x2F; GET: Products&#x2F;Delete&#x2F;5    public async Task&lt;IActionResult&gt; Delete(string id)    &#123;        if (id &#x3D;&#x3D; null)        &#123;            return NotFound();        &#125;        var product &#x3D; await _context.ProductData            .FirstOrDefaultAsync(m &#x3D;&gt; m.Id &#x3D;&#x3D; id);        if (product &#x3D;&#x3D; null)        &#123;            return NotFound();        &#125;        return View(product);    &#125;    &#x2F;&#x2F; POST: Products&#x2F;Delete&#x2F;5    [HttpPost, ActionName(&quot;Delete&quot;)]    [ValidateAntiForgeryToken]    public async Task&lt;IActionResult&gt; DeleteConfirmed(string id)    &#123;        var product &#x3D; await _context.ProductData.FindAsync(id);        _context.ProductData.Remove(product);        await _context.SaveChangesAsync();        return RedirectToAction(nameof(Index));    &#125;    private bool ProductExists(string id)    &#123;        return _context.ProductData.Any(e &#x3D;&gt; e.Id &#x3D;&#x3D; id);    &#125;&#125;return View() 返回视图，路由是根据Controller名称和方法名称组成的，如这里的Product/Index，Product/Create\n\nController vs ControllerBase\n\n如果你创建一个 .net core api项目，你会发现api的controller继承ControllerBase，而asp继承ControllerController是ControllerBase的衍生类，支持asp的Views。\nViews创建Product/Index.cshtml, 这是一个列表页。顶头：@model IEnumerable\\\n\n@model 指令使你能够使用强类型的 Model 对象访问控制器传递给视图的列表。 例如，在 Index.cshtml 视图中，代码使用 foreach 语句通过强类型 Model 对象对列表项进行循环遍历 ：&lt;table class&#x3D;&quot;table&quot;&gt;    &lt;thead&gt;        &lt;tr&gt;            &lt;th&gt;SN&lt;&#x2F;th&gt;            &lt;th&gt;Brand&lt;&#x2F;th&gt;            &lt;th&gt;Actions&lt;&#x2F;th&gt;        &lt;&#x2F;tr&gt;    &lt;&#x2F;thead&gt;    &lt;tbody&gt;        @foreach (var item in Model) &#123;            &lt;tr&gt;Id                &lt;td&gt;@Html.DisplayFor(modelItem &#x3D;&gt; item.SN)&lt;&#x2F;td&gt;                &lt;td&gt;@Html.DisplayFor(modelItem &#x3D;&gt; item.Brand)&lt;&#x2F;td&gt;                &lt;td&gt;                    &lt;a asp-action&#x3D;&quot;Edit&quot; asp-route-id&#x3D;&quot;@item.Id&quot;&gt;Edit&lt;&#x2F;a&gt; |                    &lt;a asp-action&#x3D;&quot;Details&quot; asp-route-id&#x3D;&quot;@item.Id&quot;&gt;Details&lt;&#x2F;a&gt; |                    &lt;a asp-action&#x3D;&quot;Delete&quot; asp-route-id&#x3D;&quot;@item.Id&quot;&gt;Delete&lt;&#x2F;a&gt;                &lt;&#x2F;td&gt;            &lt;&#x2F;tr&gt;        &#125;    &lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;实际上，dotnet提供了视图基架Add—Add New Scaffold Item（基架项）选择  MVC  View之后在对话框中配置业务需要的Model、Data context等，选择模板（list, details, create, edit, delete）判断是否为null@foreach (var item in Model.childrenMap??new List&lt;Child&gt;())&#123;    &lt;tr&gt;        &lt;td&gt;            @Html.DisplayFor(modelItem &#x3D;&gt; item.Child.Name)        &lt;&#x2F;td&gt;    &lt;&#x2F;tr&gt;&#125;\n模型驱动数据库设计因需求变动，模型结构变化，与数据库产生冲突Code First迁移数据模型创建数据模型Model,在Nuget Package Manager —&gt; Package Manager Console中执行Add-Migration updateModelStructure&#x2F;&#x2F; updateModelStructure 是一个数据库操作的标题，是任意命名的，仅用于记录更新记录和历史Update-DatabaseAdd-Migration之后项目中生成了Migrations类，这些类阐释了如何修改数据库见 《Entity Framework》篇issue: The entity type ‘XXModel’ requires a primary key to be defined.Model类型需标注主键private Guid _id;[Key]public Guid ID&#123;    get &#123; return _id; &#125;&#125;issue “No context type was found in the assembly ‘MyServices.Models’.”在多项目解决方案中，执行Migration的是Models项目，读取Startup中的context配置， 检查Startup.cs的addDbContext配置另有命令Enable-Migrations -ProjectName MyServices.Models -StartUpProjectName MyServices.API -ContextTypeName MyServices.Models.Contexts.DataContext -Verbose issue “The type ‘xxContext’ does not inherit from DbContext. The DbMigrationsConfiguration.ContextType property must be set to a type that inherits from DbContext.”解决方法是在startup项目安装 Microsoft.EntityFrameworkCore.Tools\n\n业务API前端组件 Blazor发布到IISTroubleShooting\n\n IIS Issue: HTTP错误500.19 \n\n微软.net core 下载页面有如下加粗提示：\n\nOn Windows, we recommended installing the Hosting Bundle, which includes the .NET Core Runtime and IIS support.\n\n下载后得到dotnet-hosting-3.0.x.exe另：IIS的远程访问允许 新建防火墙规则\n另: IIS 路由站点新建IIS 的网站指向一个物理路径就可以了，右击网站添加应用程序，指向发布的文件目录，并添加别名，事实上这个别名会作为虚拟路径(子路由)，实现192.168.1.100:80/App1这样的部署。\n\nIIS Issue: Chrome 400 Bad Request某次更新服务后，在IIS上Browser website测试正常，在远程chrome上访问只能get post全部400，新打开一个ie发现是好的(实际上新打开一个chrome隐私窗口也会是好的，这个问题初步被认为与浏览器写了太多cookie有关)\n\n配置多个环境https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/environments?view=aspnetcore-3.1\nsolution和projects多项目解决方案(class library projects)\n关于多个项目启动\n关于[HttpGet][HttpPost]标注以及方法HttpMethod识别CSDN Blog WebApi进阶\n\n博主的理解是：方法名以Get开头，WebApi会自动默认这个请求就是get请求，而如果你以其他名称开头而又不标注方法的请求方式，那么这个时候服务器虽然找到了这个方法，但是由于请求方式不确定，所以直接返回给你405——方法不被允许的错误。结论：所有的WebApi方法最好是加上请求的方式（[HttpGet]/[HttpPost]/[HttpPut]/[HttpDelete]），不要偷懒，这样既能防止类似的错误，也有利于方法的维护，别人一看就知道这个方法是什么请求\n\nTargetFramework项目属性中的item，如\\net6-windows10.0.22621.0\\ Visual Studio解析为\n\nTarget framework: .Net 6.0\nTarget OS: Windows\nTarget OS version: 10.0.22621.0\n\n一般只需要.Net6即可，在 OS 特定的 TargetFramework 的末尾指定可选的 OS 版本，例如，net6.0-ios15.0。 版本指示应用或库可用的 API。 它不控制应用或库在运行时支持的 OS 版本。 它用于选择项目编译的引用程序集，并用于从 NuGet 包中选择资产。 将此版本视为“平台版本”或“OS API 版本”，可以与运行时 OS 版本进行区分。\n当特定于 OS 的 TargetFramework 不显式指定平台版本时，它具有可从基础 TargetFramework 和平台名称推断的隐含值。 例如，.NET 6 中 iOS 的默认平台值为 15.0，这意味着 net6.0-ios 是规范 net6.0-ios15.0 TargetFramework 的简写形式。\n","categories":["后端技术"],"tags":[".Net"]},{"title":"Entity Framework Migration","url":"/qqsnote/2020/06/24/ef-migration/","content":"tourial\n安装dotnet ef clidotnet tool install --global dotnet-ef\n创建‘迁移’dotnet ef migrations add QQsInitialCreate\n\nissue: No project was found. Change the current working directory or use the —project option.\n\n项目入口(startup)的csproj与models目录分离，如├───MyProduct.API│   └───startup.cs└───MyProduct.Models    └───migrations定位startup project：cd MyProduct.Modelsdotnet ef migrations add QQsInitialCreate --startup-project &quot;D:\\QQsWorkspace\\MyProduct.API&quot;更新数据库(—startup-project参数略)：dotnet ef database update参考 Microsoft Docs:Entity Framework Core 工具\n","tags":[".Net","EntityFramework"]},{"title":"electron-forge","url":"/qqsnote/2024/01/30/electron-forge/","content":"官方推荐的打包分发工具npm install --save-dev @electron-forge&#x2F;clinpx electron-forge import\n或使用electron-forge脚手架创建项目npm init electron-app@latest my-app -- --template&#x3D;webpack-typescript\n","categories":["前端技术"],"tags":["Electron"]},{"title":"electron_issues","url":"/qqsnote/2020/04/21/electron-issues/","content":"停止和退出\napp.quit未完全结束进程\n\n在exe执行中未现问题\n\nCannot find module ‘./src/….’Github Issue将文件pattern添加到electron-builder的打包规则中\n\n另外，require import的路径均不区分大小写，configure.ts被活生生编译并打包为Configure.js以及Configure.map.jsimport编译成require，找不到configure\n\n无边透明窗体显示时出现闪烁 Issue#10069\n\n该问题是由于webview plugin无法设置透明背景造成的，在BrowserWindow show过程中显示了webview的白色背景，目前的workaround可以延迟页面内容的显示function showBrowserWindow() &#123;  win.setOpacity(0);  win.show();  setTimeout(() &#x3D;&gt; &#123;    win.setOpacity(1);  &#125;, 50);&#125;\n\nrebuild failgyp ERR! clean errorgyp ERR! stack Error: EPERM: operation not permitted, unlink &#39;D:\\projxxx\\node_modules\\ref\\build\\Release\\binding.node&#39;往往是项目文件正在使用中（正在参与其他进程的编译或执行）\n\noauth2\n早先本机应用程序使用嵌入的用户代理(嵌入的web view)进行OAuth授权请求，这种方法有很多缺点，包括主机应用程序能够复制用户凭据和Cookie，以及需要在每个应用程序中从头进行身份验证的用户。IETF RFC 8252。使用浏览器被认为更加安全且容易保留认证状态+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+|          User Device          ||                               || +--------------------------+  | (5) Authorization  +---------------+| |                          |  |     Code           |               || |        Client App        |----------------------&gt;|     Token     || |                          |&lt;----------------------|    Endpoint   || +--------------------------+  | (6) Access Token,  |               ||   |             ^             |     Refresh Token  +---------------+|   |             |             ||   |             |             ||   | (1)         | (4)         ||   | Authorizat- | Authoriza-  ||   | ion Request | tion Code   ||   |             |             ||   |             |             ||   v             |             || +---------------------------+ | (2) Authorization  +---------------+| |                           | |     Request        |               || |          Browser          |---------------------&gt;| Authorization || |                           |&lt;---------------------|    Endpoint   || +---------------------------+ | (3) Authorization  |               ||                               |     Code           +---------------++~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+对于electron，渲染界面提供入口signin, 点击会调用默认浏览器打开登录页，authenticate通过后，重定向过程会将授权码或直接将access token返回到electron, 这个‘返回’过程可以使用自定义协议实现(QQs尚未实践), 亦可实现一个b/s的request &amp; response来完成。renderUIsigninWithADB2C()&#123;  const adconfig&#x3D;&#123;    clientid:&#39;3c744214-bf78-4f92-8173-49863ae8f24b&#39;,    authority:&#39;https:&#x2F;&#x2F;qqstudio.b2clogin.com&#x2F;qqstudio.onmicrosoft.com&#x2F;B2C_1_basic_sign_up_and_sign_in&#39;,    redirectUri:&#39;http:&#x2F;&#x2F;localhost:9990&#x2F;index.html&#39;,    scopes:&#39;3c744214-bf78-4f92-8173-49863ae8f24b openid&#39;  &#125;  &#x2F;&#x2F; make up &#x2F; assemble authority URL  const authorityURL &#x3D; &#96;$&#123;adconfig.authority&#125;&#x2F;oauth2&#x2F;v2.0&#x2F;authorize?client_id&#x3D;$&#123;    adconfig.clientid  &#125;&amp;redirect_uri&#x3D;$&#123;    encodeURI(adconfig.redirectUri)  &#125;&amp;scope&#x3D;$&#123;    encodeURI(adconfig.scopes)  &#125;&amp;response_type&#x3D;id_token%20token&amp;nonce&#x3D;defaultNonce&amp;prompt&#x3D;login&#96;;  &#x2F;&#x2F; call main process open URL with default browser  &#x2F;&#x2F; meanwhile launch a http server  this.ipcService.send(&#39;openinbroweser&#39;, authorityURL);  this.loading &#x3D; true;  &#x2F;&#x2F; listen Logged in message  this.ipcService.on(&#39;access_token&#39;, msg &#x3D;&gt; &#123;    &#x2F;&#x2F; TODO process user info  &#125;);&#125;main 主线程中launch一个http server，负责提供Redirect URI的页面，页面自执行request请求，请求亦由http server响应....ipcMain.on(&#39;openinbroweser&#39;, (event, args) &#x3D;&gt; &#123;  log(&#39;info&#39;, &#39;ipcmain event:openinbroweser&#39;);  if (args) &#123;    const &#123; shell &#125; &#x3D; require(&#39;electron&#39;);    shell.openExternal(args);  &#125; else &#123;    log(&#39;error&#39;, &#39;invalid website&#39;, args);  &#125;&#125;);&#x2F;&#x2F; launch a http servervar static &#x3D; require(&#39;node-static&#39;);var file &#x3D; new static.Server(&#96;$&#123;__dirname&#125;&#x2F;public&#96;);http.createServer(function (request, response) &#123;  if(request.url&#x3D;&#x3D;&#x3D;&#39;&#x2F;index.html&#39;)&#123;    request.addListener(&#39;end&#39;, function () &#123;        file.serve(request, response)    &#125;).resume();  &#125;else&#123;    const reg &#x3D; new RegExp(&quot;t&#x3D;([^&amp;]*)&quot;);    const res&#x3D; request.url.match(reg);    const token &#x3D; res[1];    console.log(&#39;t&#x3D;&#39;,token)    win.webContents.send(&#39;access_token&#39;,token)    response.write(&quot;success&quot;); &#x2F;&#x2F;close default browser  &#125;  response.end(); &#x2F;&#x2F;end the response&#125;).listen(9990)redirect page (public/index.html)&lt;html&gt;&lt;body&gt;  &lt;p&gt;serve by csportal&lt;&#x2F;p&gt;  &lt;script&gt;    (() &#x3D;&gt; &#123;      var reg &#x3D; new RegExp(&quot;#access_token&#x3D;([^&amp;]*)&quot;);      var res &#x3D; location.href.match(reg);      var token &#x3D; unescape(res[1]);      fetch(&#96;http:&#x2F;&#x2F;localhost:3000?t&#x3D;$&#123;token&#125;&#96;)        .then(function (response) &#123;          return response.json();        &#125;)        .catch(error &#x3D;&gt; console.error(&#39;Error:&#39;, error))        .then(response &#x3D;&gt; &#123;console.log(&#39;Success:&#39;, response);        window.close();      &#125;);    &#125;)();  &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;Caution! 需考虑到浏览器将token传递给client的过程，都有被第三方恶意应用占用URL Scheme或者localhost端口截取Access Token的风险。在有”显式”授权流程的方式中，浏览器传递授权码，由client凭授权码换取token，同样无法杜绝第三方拦截。了解使用带有PKCE(Proof Key for Code Exchange)支持的授权码模式\n\n","categories":["前端技术"],"tags":["Electron"]},{"title":"Electron 生命周期","url":"/qqsnote/2020/03/31/electron-lifecycle/","content":""},{"title":"Electron 入坑","url":"/qqsnote/2019/09/19/electron/","content":"\n须知，vscode是Electron应用，atom是Electron应用，GeForce Experience也是Electron应用，还有Skype。。。\n\n本质是使用chronium浏览器内核和HTML实现应用程序UI，底层业务是基于js”粘合”的，即除了require nodejs native modules之外，还可以将基于其他技术生态的组件集成进来，这里会用到webpack打包。得益于HTML UI开发的方便，和nodejs api的丰富，使得app 开发变得方便快捷，而且基于js实现了相当完美的跨平台，然而泻药如下：\n\n因为不可避免的打包浏览器内核，出品动辄100MB\n因为打包的是chrome家的内核，内存占用相当大\n\n如果是windows平台的应用需求，wpf的产品将在体积，资源占用，安全的系统访问等方面碾压electron\n知乎：为什么用 electron 开发的桌面应用那么多？\n构建项目框架\n脚手架 npm i -g angular-cli electron\n创建Angular项目 ng new ngelectron —routing \npackage.json \n主进程main.js\n\nCaution! 新版本electron嵌入了nodejs运行时，故而系统安装的nodejs环境仅用于执行npm install —save-dev electron，与之后的开发运行再无关系\n以angular-electron为例，npm run start过程，&quot;start&quot;: &quot;npm run postinstall:electron &amp;&amp; npm-run-all -p ng:serve electron:serve&quot;,&quot;postinstall:electron&quot;: &quot;node postinstall&quot;,&quot;electron:serve&quot;: &quot;wait-on http-get:&#x2F;&#x2F;localhost:4200&#x2F; &amp;&amp; npm run electron:serve-tsc &amp;&amp; electron . --serve,&quot;electron:serve-tsc&quot;: &quot;tsc -p tsconfig-serve.json&quot;,\n\n调用postinstall (postinstall.js)修改angular的webpack target \n随后运行ng serve \n连接ng serve启动的localhost:4200\n调用tsc编译main.ts此时生成了main.js\n执行electron .webpack target\n\nIPCIPC 代表 Inter-Process Communication进程间通信。Electron 使用 IPC 来在main主进程和renderer渲染进程之间传递 JSON 信息。mainrender\n资源打包关于asar vbscriptasar 是一种将多个文件合并成一个文件的类 tar 风格的归档格式。 Electron 可以无需解压整个文件，即可从其中读取任意文件内容。\n逻辑中视为文件夹const fs &#x3D; require(&#39;fs&#39;)fs.readFileSync(&#39;&#x2F;path&#x2F;to&#x2F;example.asar&#x2F;file.txt&#39;)\n单例模式 单例参数更新外观无边透明,隐藏任务栏let mainWindow &#x3D; new BrowserWindow(&#123; transparent: true, frame: false, skipTaskbar:true &#125;)实践中发现透明还需另外设置body&#123;    background:transparent&#125;\n交互保持置顶win &#x3D; new BrowserWindow(&#123;   alwaysOnTop: true &#125;);无窗口UI的拖动设置响应鼠标拖动区域，用css标记-webkit-app-region: drag参考官方文档: frameless window 可拖拽区域\nelectron-drag 方案\n命令及参数开发模式electron . [args]args &#x3D; process.argv.splice(2)执行模式app.exe [args]args &#x3D; process.argv.splice(1)\nelectron-builder部分配置&quot;productName&quot;: &quot;CSCportal&quot;,  &quot;directories&quot;: &#123;    &quot;output&quot;: &quot;release&#x2F;&quot;  &#125;,  &#x2F;&#x2F; 额外打包的资源 不会打包到\\resources\\app.asar  &#x2F;&#x2F; 以下规则将文件单独打包到\\resources\\addon  &quot;extraResources&quot;: &#123;    &quot;from&quot;: &quot;addon&#x2F;&quot;,    &quot;to&quot;: &quot;addon&#x2F;&quot;  &#125;,  &#x2F;&#x2F; 额外打包配置文件到根目录  &quot;extraFiles&quot;:[&quot;config.xml&quot;],  &#x2F;&#x2F; 打包文件的parttern表达式  &quot;files&quot;: [    &quot;**&#x2F;*&quot;,    &quot;!package.json&quot;,    &quot;!src&#x2F;&quot;,    &quot;src&#x2F;app&#x2F;shared&#x2F;*&quot;, &#x2F;&#x2F; 打包main调用的模块（.js）    &quot;!src&#x2F;app&#x2F;shared&#x2F;*.ts&quot; &#x2F;&#x2F; 忽略ts源文件  ],  &#x2F;&#x2F; windows环境  &quot;win&quot;: &#123;    &quot;target&quot;: [      &quot;nsis&quot;, &#x2F;&#x2F; 使用nsis工具生成安装包      &quot;zip&quot;   &#x2F;&#x2F; 生成zip免安装压缩包    ],    &#x2F;&#x2F; code sign（代码签名）    &quot;signingHashAlgorithms&quot;:[&quot;sha1&quot;], &#x2F;&#x2F; sign algorithms [&#39;sha1&#39;, &#39;sha256&#39;]    &quot;certificateFile&quot;:&quot;build&#x2F;cert&#x2F;XXXXX.pfx&quot;, &#x2F;&#x2F; 证书路径    &quot;certificatePassword&quot;:&quot;XXXXXXX&quot;,  &#x2F;&#x2F; 证书密码    &quot;verifyUpdateCodeSignature&quot;:false, &#x2F;&#x2F; 安装前是否验证签名可用更新（available update）    &quot;rfc3161TimeStampServer&quot;: &quot;http:&#x2F;&#x2F;timestamp.digicert.com&quot;, &#x2F;&#x2F; time stamp server    &quot;signDlls&quot;: true &#x2F;&#x2F;是否签名DLL  &#125;,  &quot;nsis&quot;:&#123;    &quot;oneClick&quot;:false, &#x2F;&#x2F; 禁用一键安装    &quot;perMachine&quot;:true, &#x2F;&#x2F; 为所有用户安装    &quot;allowToChangeInstallationDirectory&quot;:true, &#x2F;&#x2F; 自定义安装路径    &quot;include&quot;:&quot;build&#x2F;installer.nsh&quot; &#x2F;&#x2F; 包含脚本  &#125;,  &quot;mac&quot;: &#123;&#125;,  &quot;linux&quot;: &#123;&#125;&#125;How to share costom .ts file between main.ts and Angular app即将文件或目录添加到打包文件的parttern表达式中\nnsis宏命令 installer.nsh在electron-builder.json配置中引入.nsh脚本，脚本定义了NSIS打包生命周期中插入的宏指令可插入宏：\n\ncustomHeader可以配置NSIS的一些环境或运行条件，如显示详细信息框：!macro customHeader  ShowInstDetails show  ShowUninstDetails show!macroend\n详见调用源码\npreInitThis macro is inserted at the beginning of the NSIS .OnInit callback\ncustomInit\ncustomUnInit\ncustomInstall安装\ncustomUnInstall卸载\ncustomRemoveFiles\ncustomInstallMode!macro customInstall  WriteRegStr HKLM &quot;SOFTWARE\\Carestream Dental\\CSCportal&quot; &quot;InstallDir&quot; $INSTDIR!macroend\nuninstaller.nsh!macro customUnInstall    DeleteRegKey HKLM &quot;SOFTWARE\\Carestream Dental\\CSCportal&quot; &quot;InstallDir&quot;!macroend\nBUILD_RESOURCES_DIR and PROJECT_DIR are defined.\n\nbuild is added as addincludedir (i.e. you don’t need to use BUILD_RESOURCES_DIR to include files).\nbuild/x86-unicode and build/x86-ansi are added as addplugindir.Caution! 我的angular-electron6项目中，仍然要手动载入plugin，写法同《NSIS插件》笔记中的代码\nFile associations macro registerFileAssociations and unregisterFileAssociations are still defined.\nLogicLib.nsh默认已包含\nAll other electron-builder specific flags (e.g. ONE_CLICK) are still defined.\n参考 electron-builder文档nsis部分 参考NSIS相关笔记\nCaution!以上文档对应最新版本electron-builder,经实践v22.7.0可以返回build异常信息，应更新并使用新版本\n调试主进程VScode launch.json:&#123;  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    &#123;      &quot;name&quot;: &quot;Debug Main Process&quot;,      &quot;type&quot;: &quot;node&quot;,      &quot;request&quot;: &quot;launch&quot;,      &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,      &quot;runtimeExecutable&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;node_modules&#x2F;.bin&#x2F;electron&quot;,      &quot;windows&quot;: &#123;        &quot;runtimeExecutable&quot;: &quot;$&#123;workspaceRoot&#125;&#x2F;node_modules&#x2F;.bin&#x2F;electron.cmd&quot;      &#125;,      &quot;args&quot; : [&quot;.&quot;,&quot;--input&#x3D;d:\\\\temp\\\\input.xml&quot;,&quot;--output&#x3D;d:\\\\temp\\\\output.xml&quot;],      &quot;outputCapture&quot;: &quot;std&quot;    &#125;  ]&#125;此app设计为由其他客户端程序使用命令调起，传入input参数和output参数，注意调试命令的’electron .’中’.’是第一个参数。\n另外此app是webpack打包的angular electron应用，调试调用主程序js文件，每次更新代码后应使用postinstall进行编译。\n自动更新服务原理似乎是这样的，首先是build，将构建好的文件publish到一个下载中心，很多工具都封装了比如GitHub和Bintray\nelectron-builder方案\n\ninstall electron-updater \n配置publish参数一般在package.json中，已分离出electron-build.json配置的在该文件中本章未完待补充QQs\n\nError write EPIPE修改node，electron-builder版本使之兼容可解决\n[object][object]修改electron-builder版本规避\nBrowserWindow.loadURL Issuenpm ERR! code ELIFECYCLEdouble free exception,重复释放资源，错误使用app.exit()出现此异常如app.on(&#39;window-all-closed&#39;, () &#x3D;&gt; &#123;  if (process.platform !&#x3D;&#x3D; &#39;darwin&#39;) &#123;    &#x2F;&#x2F; app.quit(); &#x2F;&#x2F; safe!    app.exit(-1) &#x2F;&#x2F; ELIFECYCLE Exception!!  &#125;&#125;)\nspawn makensis,exe ENOENTelectron-builder 不支持yarn2+ 直接使用electron-builder build命令打包即可GitMemory:Electron-Userland\nrequire is not defined&#x2F;&#x2F; Create the browser window.win &#x3D; new BrowserWindow(&#123;  width: 800,  height: 600,  webPreferences: &#123;    nodeIntegration: false, &#x2F;&#x2F; is default value after Electron v5    contextIsolation: true, &#x2F;&#x2F; protect against prototype pollution    preload: path.join(__dirname, &quot;preload.js&quot;)  &#125;&#125;);\nshell.openExternal\nOpen the given external protocol URL in the desktop’s default manner. 对于系统支持的协议，以系统默认行为打开URL\n\nwindows 开始 搜索“按协议指定默认应用程序”或“Choose default apps by protocol”\n其他概念\nElectron Fiddle是由Electron开发并由其维护者支持的沙盒程序\n离屏渲染(Off-Screen Rendering)相对于当前屏幕渲染，GPU另辟缓存区为下一步的显示效果进行渲染的机制\n\n","categories":["前端技术"],"tags":["Electron"]},{"title":"Entity Framework","url":"/qqsnote/2020/06/15/entityframework/","content":"\nEntirtyFramework框架是一个轻量级的可扩展版本的流行实体框架数据访问技术,ORM工具(Object Relational Mapping 对象关系映射)\n\nEF有三种使用场景，1. 从数据库生成Class(DB First)，2.由实体类生成数据库表结构(Code First)，3.  通过数据库可视化设计器设计数据库，同时生成实体类(Model First)。\n实体类型class MyContext : DbContext&#123;    public DbSet&lt;Blog&gt; Blogs &#123; get; set; &#125;    protected override void OnModelCreating(ModelBuilder modelBuilder)    &#123;        modelBuilder.Entity&lt;Blog&gt;();    &#125;&#125;public class Blog&#123;    public int BlogId &#123; get; set; &#125;    public string Url &#123; get; set; &#125;    public List&lt;Post&gt; Posts &#123; get; set; &#125;&#125;&#x2F;&#x2F; 从模型中排除的类型[NotMapped]public class BlogMetadata&#123;    public DateTime LoadedFromDatabase &#123; get; set; &#125;&#125;\n\n按照约定，每个实体类型将设置为映射到与公开实体的 DbSet 属性同名的数据库表。 如果给定实体不存在 DbSet，则使用类名称。或使用注解 [ Table(“tableName”) ]\n实体属性public class Blog&#123;    public int BlogId &#123; get; set; &#125;    public string Url &#123; get; set; &#125;    &#x2F;&#x2F;从模型中排除的属性    [NotMapped]    public DateTime LoadedFromDatabase &#123; get; set; &#125;&#125;\n列注解：\n\n列名 [ Column(“blog_id”) ]\n数据类型 [Column(TypeName = “varchar(200)”)]\n校验  [ MaxLength(500) ] [ Required ]       \n\n\n键主键protected override void OnModelCreating(ModelBuilder modelBuilder)&#123;    modelBuilder.Entity&lt;Blog&gt;()        .HasKey(b &#x3D;&gt; b.BlogId)        .HasName(&quot;PrimaryKey_BlogId&quot;);&#125;Alternative Keyclass MyContext : DbContext&#123;    public DbSet&lt;Blog&gt; Blogs &#123; get; set; &#125;    public DbSet&lt;Post&gt; Posts &#123; get; set; &#125;    protected override void OnModelCreating(ModelBuilder modelBuilder)    &#123;        modelBuilder.Entity&lt;Post&gt;()            .HasOne(p &#x3D;&gt; p.Blog)            .WithMany(b &#x3D;&gt; b.Posts)            .HasForeignKey(p &#x3D;&gt; p.BlogUrl)            .HasPrincipalKey(b &#x3D;&gt; b.Url);    &#125;&#125;\n策略维护 多对多关系官网Doc\n\n目前尚不支持多对多关系，没有实体类来表示联接表。 但是，您可以通过包含联接表的实体类并映射两个不同的一对多关系，来表示多对多关系。class MyContext : DbContext&#123;    public DbSet&lt;Post&gt; Posts &#123; get; set; &#125;    public DbSet&lt;Tag&gt; Tags &#123; get; set; &#125;    protected override void OnModelCreating(ModelBuilder modelBuilder)    &#123;        modelBuilder.Entity&lt;PostTag&gt;()            .HasKey(t &#x3D;&gt; new &#123; t.PostId, t.TagId &#125;);        modelBuilder.Entity&lt;PostTag&gt;()            .HasOne(pt &#x3D;&gt; pt.Post)            .WithMany(p &#x3D;&gt; p.PostTags)            .HasForeignKey(pt &#x3D;&gt; pt.PostId);        modelBuilder.Entity&lt;PostTag&gt;()            .HasOne(pt &#x3D;&gt; pt.Tag)            .WithMany(t &#x3D;&gt; t.PostTags)            .HasForeignKey(pt &#x3D;&gt; pt.TagId);    &#125;&#125;public class Post&#123;    public int PostId &#123; get; set; &#125;    public string Title &#123; get; set; &#125;    public string Content &#123; get; set; &#125;    public List&lt;PostTag&gt; PostTags &#123; get; set; &#125;&#125;public class Tag&#123;    public string TagId &#123; get; set; &#125;    public List&lt;PostTag&gt; PostTags &#123; get; set; &#125;&#125;public class PostTag&#123;    public int PostId &#123; get; set; &#125;    public Post Post &#123; get; set; &#125;    public string TagId &#123; get; set; &#125;    public Tag Tag &#123; get; set; &#125;&#125;\n一对多&#x2F;&#x2F; 博客public class Blog&#123;    public int BlogId &#123; get; set; &#125;    public string Url &#123; get; set; &#125;    public List&lt;Post&gt; Posts &#123; get; set; &#125;&#125;&#x2F;&#x2F; 文章public class Post&#123;    public int PostId &#123; get; set; &#125;    public string Title &#123; get; set; &#125;    public string Content &#123; get; set; &#125;    public int BlogId &#123; get; set; &#125;    public Blog Blog &#123; get; set; &#125;&#125;\n\nPost是依赖实体\nBlog是主体实体\nBlog.BlogId是主体键（在本例中为主密钥，而不是备用密钥）\nPost.BlogId为外键\nPost.Blog是一个引用导航属性\nBlog.Posts是集合导航属性\nPost.Blog是的反向导航属性 一对一public class Blog&#123;    public int BlogId &#123; get; set; &#125;    public string Url &#123; get; set; &#125;    public BlogImage BlogImage &#123; get; set; &#125;&#125;public class BlogImage&#123;    public int BlogImageId &#123; get; set; &#125;    public byte[] Image &#123; get; set; &#125;    public string Caption &#123; get; set; &#125;    public int BlogId &#123; get; set; &#125;    public Blog Blog &#123; get; set; &#125;&#125;\n配置关系时HasForeignKey必须指定实体类型，这一点区别于上面的书写方式modelBuilder.Entity&lt;Blog&gt;()    .HasOne(b &#x3D;&gt; b.BlogImage)    .WithOne(i &#x3D;&gt; i.Blog)    .HasForeignKey&lt;BlogImage&gt;(b &#x3D;&gt; b.BlogForeignKey);\n关联关系class MyContext : DbContext&#123;    public DbSet&lt;Blog&gt; Blogs &#123; get; set; &#125;    public DbSet&lt;Post&gt; Posts &#123; get; set; &#125;    protected override void OnModelCreating(ModelBuilder modelBuilder)    &#123;        modelBuilder.Entity&lt;Post&gt;()            .HasOne&lt;Blog&gt;()            .WithMany()            .HasForeignKey(p &#x3D;&gt; p.BlogId);    &#125;&#125;关联关系有Reqiuired和Optional之分，前者的情况下，对主体实体的删除会导致依赖实体被级联删除，而对于后者，默认不被配置为级联删除而将外键属性置为null\n关联查询public async Task&lt;IActionResult&gt; Details(string code)&#123;    if (code &#x3D;&#x3D; null)    &#123;        return NotFound();    &#125;    &#x2F;&#x2F; Blog &lt;&gt;--- ReferenceMap ---&lt;&gt; Theme    var Blog &#x3D; await _context. Blogs                    .Include(blog &#x3D;&gt; blog.ReferenceMap)                    .ThenInclude(map &#x3D;&gt; map.Theme)                    .FirstOrDefaultAsync(m &#x3D;&gt; m.Code &#x3D;&#x3D; code);    if (Blog &#x3D;&#x3D; null)    &#123;        return NotFound();    &#125;    return View(Blog);&#125;\nInclulde 被称为 预先加载 eager load使用ThenInclude关联多个层次Include可以包含过滤, 如下取得曾发表带’敏感’词标题文章的所有博客，以及相应的文章var restrictBlogs &#x3D; _context.Blogs.Include(blog &#x3D;&gt; blog.Posts.Where(post &#x3D;&gt; post.Title.Contains(&quot;敏感&quot;))).ToList()\n\n\n\n显式加载(explicit load)var blog &#x3D; _context.Blogs.Single(blog&#x3D;&gt;blog.Author&#x3D;&#x3D;&quot;QQs&quot;) &#x2F;&#x2F; 此处关联属性Posts为null...var posts &#x3D; _context.Entry(blog).Collection(blog &#x3D;&gt; blog.Posts).Query().Where(post &#x3D;&gt; post.Title.Contains(&quot;敏感&quot;)).ToList() &#x2F;&#x2F; 此时blog对象的Posts属性被填充（仅过滤结果）不返回结果posts可以直接Load_context.Entry(blog).Collection(blog &#x3D;&gt; blog.Posts).Load()QQs：私以为这与预先加载并无多大区别\n延迟加载（lazy load）见Microsoft Docs：相关数据的延迟加载\n关联存储here向导航属性（blog.Posts）中添加新实体，EF自动发现关联实体并将其插入数据库await using (var context &#x3D; new BloggingContext())&#123;    var blog &#x3D; await context.Blogs.Include(b &#x3D;&gt; b.Posts).FirstAsync();    var post &#x3D; new Post &#123; Title &#x3D; &quot;Intro to EF Core&quot; &#125;;    blog.Posts.Add(post);    await context.SaveChangesAsync();&#125;自动更改外键列await using (var context &#x3D; new BloggingContext())&#123;    var blog &#x3D; new Blog &#123; Url &#x3D; &quot;http:&#x2F;&#x2F;blogs.msdn.com&#x2F;visualstudio&quot; &#125;;    var post &#x3D; await context.Posts.FirstAsync();    post.Blog &#x3D; blog;    await context.SaveChangesAsync();&#125;上面的代码没有显式操作外键post.blogId，但EF会自动更新，并且将所需的新实体blog插入数据库\nCRUD使用数据库上下文修改模型(包括新增和移除)，并执行SaveChanges，相当于commit&#x2F;&#x2F; createcontext.Add(new Student&#123;    FirstName&#x3D;&quot;Jack&quot;,    SurName&#x3D;&quot;Ma&quot;&#125;);context.SaveChanges();&#x2F;&#x2F; selectvar MaYun &#x3D; context.Students            .Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; GetName()).ToList();&#x2F;&#x2F; updateMaYun.Age&#x3D;8;context.Update(MaYun)context.SaveChanges()&#x2F;&#x2F; deletecontext.Remove(MaYun);context.SaveChanges()一般在web应用中使用异步&#x2F;&#x2F; createcontext.Add(new Student&#123;    FirstName&#x3D;&quot;Jack&quot;,    SurName&#x3D;&quot;Ma&quot;&#125;);context.SaveChangesAsync();&#x2F;&#x2F; selectvar MaYun &#x3D; context.Students            .Where(s &#x3D;&gt; s.FirstName &#x3D;&#x3D; GetName()).ToListAsync();&#x2F;&#x2F; updateMaYun.Age&#x3D;8;context.SaveChangesAsync()&#x2F;&#x2F; deletecontext.Remove(MaYun);context.SaveChangesAsync()Caution! 在对DbContext的多次操作中，如果前面一次SaveChanges出错，如Add操作违反唯一约束而失败，需要将该实体类实例从DbContext中移除(或修正)，否则出错的命令会一直在提交队列中，反复报错try&#123;    _context.Add(newBlog);    await _context.SaveChangesAsync();&#125;catch (Microsoft.EntityFrameworkCore.DbUpdateException dbEx)&#123;    &#x2F;&#x2F; TODO the result description is not properly rigorous.    if (null !&#x3D; dbEx.InnerException        &amp;&amp; dbEx.InnerException.Message.Contains(&quot;constraint&quot;))    &#123;        System.Console.WriteLine(&quot;Blog exists;&quot;);    &#125;    else    &#123;        &#x2F;&#x2F; other error handle    &#125;    _context.Remove(newBlog);&#125;DBContext.Add成功后 若主键id使用数据库策略生成 Add成功后即可从对象中取到\nDBcontext和connectionstringstartup.cspublic void ConfigureServices(IServiceCollection services)&#123;    services.AddDbContext&lt;BloggingContext&gt;(options &#x3D;&gt;        options.UseSqlServer(Configuration.GetConnectionString(&quot;DBConnection&quot;)));&#125;\n重连数据库如SQL Server的provider程序，可以识别可重试（retry）的异常类型public void ConfigureServices(IServiceCollection services)&#123;    services.AddDbContext&lt;PicnicContext&gt;(        options &#x3D;&gt; options.UseSqlServer(            Configuration.GetConnectionString(&quot;DBConnection&quot;),            providerOptions &#x3D;&gt; providerOptions.EnableRetryOnFailure()));&#125;\n事务额外的，Transaction commit failure\n对于多项实体操作(CRUD)后SaveChanges，SaveChanges是事务性的，意味着前面所有操作成功或失败，而不会产生部分成功部分失败\nLazy load访问导航属性（外键）时再次查询数据库using (var dbContext &#x3D; new CategoryEntities())&#123;    dbContext.Configuration.LazyLoadingEnabled &#x3D; true; &#x2F;&#x2F; 默认是true，针对导航属性        var categoryList &#x3D; dbContext.Set&lt;Category&gt;().Where(p &#x3D;&gt; p.CategoryId &#x3D;&#x3D; 3);        &#x2F;&#x2F; 只会在数据库里面查询Category表，不会查询ProductDetail表        foreach(var category in categoryList)        &#123;            Console.WriteLine(&quot;CategoryId:&quot;+category.CategoryId+ &quot;,CategoryName:&quot;+category.CategoryName);            &#x2F;&#x2F; 这时才会去数据库查询ProductDetail表            foreach (var product in category.ProductDetails)            &#123;                Console.WriteLine(&quot;ProductName:&quot;+product.ProductName);            &#125;        &#125;&#125;不再继续查询using (var dbContext &#x3D; new CategoryEntities())&#123;    dbContext.Configuration.LazyLoadingEnabled &#x3D; false; &#x2F;&#x2F; 不延迟加载,不会再次查询了    var categoryList &#x3D; dbContext.Set&lt;Category&gt;().Where(p &#x3D;&gt; p.CategoryId &#x3D;&#x3D; 3);    &#x2F;&#x2F; 只会在数据库里面查询Category表，不会查询ProductDetail表    foreach (var category in categoryList)    &#123;        Console.WriteLine(&quot;CategoryId:&quot; + category.CategoryId + &quot;,CategoryName:&quot; + category.CategoryName);        &#x2F;&#x2F; 这时不会去数据库查询了，所以用户全是空的        foreach (var product in category.ProductDetails)        &#123;            Console.WriteLine(&quot;ProductName:&quot; + product.ProductName);        &#125;    &#125;&#125;一次性完成查询&#x2F;&#x2F; 显示加载using (var dbContext &#x3D; new CategoryEntities())&#123;    &#x2F;&#x2F; 不延迟加载，指定Include，一次性加载主表和从表的所有数据    var categoryList &#x3D; dbContext.Set&lt;Category&gt;().Include(&quot;ProductDetails&quot;).Where(p &#x3D;&gt; p.CategoryId &#x3D;&#x3D; 3);    foreach (var category in categoryList)    &#123;        Console.WriteLine(&quot;CategoryId:&quot; + category.CategoryId + &quot;,CategoryName:&quot; + category.CategoryName);        &#x2F;&#x2F; 不会再查询        foreach (var product in category.ProductDetails)        &#123;            Console.WriteLine(&quot;ProductName:&quot; + product.ProductName);        &#125;    &#125;&#125;\n\nissue: Data is Null. This method or property cannot be called on Null values.\n一个很简单的出错原因是model的基本类型（非对象，不能设置为null）如int，Guid等的属性，其对应的table field为null。应以int?,Guid?作为属性类型以支持null\nParent/Child对应于使用id，parentid组织的父子关系表，常见的组织机构树，职能头衔树等public class Group&#123;    public Guid ID &#123; get; set; &#125;    public string Name &#123; get; set; &#125;    public Guid? ParentID &#123; get; set; &#125;    public Group Parent &#123; get; set; &#125;        public ICollection&lt;Group&gt; Children &#123; get; &#125; &#x3D; new List&lt;Group&gt;();&#125;查询子树var data &#x3D; (await _context.Group.ToListAsync())            .Where(g &#x3D;&gt; g.ID &#x3D;&#x3D; new Guid(groupId))            .ToList();\nHierarchy Data参考Using SQL Server HierarchyId with Entity Framework Corepackage: \n\nMicrosoft.EntityFrameworkCore.SqlServer\nEntityFrameworkCore.SqlServer.HierarchyId数据库上下文需要配置启用HierarchyId，否则出现下述异常The property is of type ‘HierarchyId’ which is not supported by current database provider. Either change the property CLR type or ignore the property using the ‘[NotMapped]’ attribute or by using ‘EntityTypeBuilder.Ignore’ in ‘OnModelCreating’.\n\n\n在Startup.cs,配置启用HierarchyId public void ConfigureServices(IServiceCollection services)&#123;    ...    services.AddDbContext&lt;DataContext&gt;(options &#x3D;&gt;        options.UseSqlServer(Configuration.GetConnectionString(&quot;DataContext&quot;), conf&#x3D;&gt;            &#123;                conf.UseHierarchyId();            &#125;        ));    ...&#125;model定义public class Group&#123;    public Guid ID &#123; get; set; &#125;    public string Name &#123; get; set; &#125;    public HierarchyId GroupLevel &#123; get; set; &#125;        public ICollection&lt;Group&gt; Children &#123; get; &#125; &#x3D; new List&lt;Group&gt;();&#125;查询linqpublic async Task&lt;List&lt;Group&gt;&gt; GetChildrenByGroupIDAsync(Guid groupID)&#123;    Group self &#x3D; await _context.Groups.FindAsync(groupID);    List&lt;Group&gt; groups &#x3D; await _context.Groups        .Where(g &#x3D;&gt; g.GroupLevel.IsDescendantOf(self.GroupLevel))        .ToListAsync();    return groups; &#x2F;&#x2F;.FindAll(g &#x3D;&gt; g.ID !&#x3D; groupID);&#125;其他查询见文章SQLServer\nTransient Error\nException: An exception has been raised that is likely due to a transient failure. Consider enabling transient error resiliency by adding ‘EnableRetryOnFailure()’ to the ‘UseSqlServer’ call.\n\n见StackOverflow: Getting transient errors when making calls against Azure SQL Database from Azure Function\n数据库系统偶现Transient Error，这种暂时性错误的根本原因（underlying cause）很快就能自行解决，且在错误抛出时，.net程序会抛出上述的SqlException，为了处理这些错误，可应用程序代码中实现重试逻辑，而不是以应用程序错误的形式呈现给用户。在Startup.cs,配置启用RetryOnFailure public void ConfigureServices(IServiceCollection services)&#123;    ...    services.AddDbContext&lt;DataContext&gt;(options &#x3D;&gt;        options.UseSqlServer(Configuration.GetConnectionString(&quot;DataContext&quot;), conf&#x3D;&gt;            &#123;                conf.EnableRetryOnFailure();            &#125;        ));    ...&#125;但是这里有个bug System.ArgumentException thrown when EnableRetryOnFailure is used. 该bug已在dotNet 5版本修复\n分页List&lt;customers&gt; _customers &#x3D; (from a in db.customers select a).ToList();var _dataToWebPage &#x3D; _customers.Skip(50).Take(50);\nStackOverflow:C# entity framework pagination\nORM注意事项EF O/RM 注意事项\n日志startup.csservices.AddDbContext&lt;MyDBContext&gt;(options &#x3D;&gt; &#123;    options.UseSqlServer(Configuration.GetConnectionString(&quot;MyDBContext&quot;), conf &#x3D;&gt; &#123;        conf.UseHierarchyId();        conf.EnableRetryOnFailure();    &#125;);    options.LogTo(System.Console.WriteLine);&#125;);Docs:简单的日志记录日志委托和日志级别：options.LogTo(Console.WriteLine, LogLevel.Information;\nException：this sqltransaction has completed it is no longer usable[HttpPost][Route(&quot;api&#x2F;[controller]&#x2F;create&quot;)]public async Task&lt;Result&gt; Create([FromBody] QModel model)&#123;    ...    try&#123;        _context.Add(model);        await _context.SaveChangesAsync();    &#125;catch(Exception ex)&#123;        &#x2F;&#x2F; ...    &#125;&#125;\n如上一个insert数据的接口，在有限的并发条件下（也就是for循环几条请求），个别错误数据可以造成其他正常数据插入失败报 this sqltransaction has completed it is no longer usable 以及 zombie check等解释查了2天资料未能解决次日反思 问题或许出在多条线程同时向数据库上下文中推数据（即_context.Add）其中一个错误数据的出错，事务自动回滚，导致了其他线程中访问该事务已不可用。此处使用_context.AddAsync方法可以解决即，该问题就是个ef方法的线程安全的问题，可见StackOverflow: AddAsync vs Add那么我一个需求要添加user并为其分配新的group，一个事务里两个add操作怎么办呢，另起一小节：\n一个事务多个操作的线程安全其实在官方文档最初的概述中，强调了DbContext的线程不安全 见Microsoft Docs: DBContext Lifetime\n\nDbContext 不是线程安全的。 不要在线程之间共享上下文。 请确保在继续使用上下文实例之前，等待所有异步调用。\n\n关于以事务作为上下文生命周期的配置, 见StackOverflow:Configuring Dbcontext as Transient 然而!经实践同一接口的并发测试 仍然会出现this sqltransaction has completed it is no longer usable的异常依赖注入的DBContext在Startup的ConfigureServices中注册MyDBContext服务提供程序：services.AddDbContext&lt;MyDBContext&gt;(    options &#x3D;&gt; options.UseSqlServer(Configuration.GetConnectionString(&quot;MyDBContext&quot;),                                conf &#x3D;&gt; &#123; conf.UseHierarchyId();                                    conf.EnableRetryOnFailure();                                &#125;), ServiceLifetime.Transient);注入DBContext:public class GroupsController : ControllerBase&#123;    private readonly MyDBContext _context;    private IGroupTreeService _groupTreeService;    public GroupsController(MyDBContext context, IGroupTreeService groupTreeService)    &#123;        _context &#x3D; context;        _groupTreeService &#x3D; groupTreeService;    &#125;    ...&#125;控制DBContext生命周期在函数内部官方Doc：启用RetryOnFailue情形下的手动事务方式public interface IWorker&#123;    void DoWork(Func&lt;MyDbContext&gt; dbFactory);&#125;public class WorkerRunner&#123;    private readonly DbContextOptions&lt;MyDbContext&gt; _dbOptions;    private readonly List&lt;IWorker&gt; _workers;    public WorkerRunner(DbContextOptions&lt;MyDbContext&gt; dbOptions, List&lt;IWorker&gt; workers)    &#123;        _dbOptions &#x3D; dbOptions;        _workers &#x3D; workers;    &#125;    public void RunWorkers()    &#123;        using (var context &#x3D; new MyDbContext(_dbOptions))        &#123;            using (var tran &#x3D; context.Database.BeginTransaction())            &#123;                foreach (var worker in _workers)                    worker.DoWork(() &#x3D;&gt;                    &#123;                        &#x2F;&#x2F; This won&#39;t work                        var db &#x3D; new MyDbContext(_dbOptions);                        &#x2F;&#x2F; And this one will even throw exception when used with in-memory database (during unit testing)                        db.Database.UseTransaction(tran.GetDbTransaction());                        return context;                    &#125;);                tran.Commit();            &#125;        &#125;    &#125;&#125;就是new一个DBContext用， Caution! 经测单靠new DBContext不能阻止transaction Error\n自动生成id[Table(&quot;User&quot;)]public class User&#123;    [Key]    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]    public string Id &#123; get; set; &#125;&#125;\n默认值protected override void OnModelCreating(ModelBuilder modelBuilder)&#123;    modelBuilder.Entity&lt;User&gt;()        .Property(e &#x3D;&gt; e.Role)        .HasDefaultValue(1);&#125;","categories":["后端技术"],"tags":[".Net","EntityFramework"]},{"title":"font-icon","url":"/qqsnote/2020/11/30/font-icon/","content":"将图标转为字体格式icomoon\n将图标封装到css伪类.icon.icon-add&#123;\tposition: relative;    padding-left: 22px;    margin-left: 4px;\t&amp;::before&#123;\t\tcontent: &#39;&#39;;\t\tposition: absolute;\t\tleft: 0px;\t\tbottom: calc(50% - 10px);\t\tbackground: url(.&#x2F;assets&#x2F;image&#x2F;icon_add.svg) no-repeat top left;\t\twidth: 18px;\t\theight: 18px;\t&#125;&#125;","categories":["前端技术"],"tags":["css"]},{"title":"FastDFS","url":"/qqsnote/2020/06/05/fastDFS/","content":"\nFastDFS是国人大神开发的用于小文件（&lt;500Mb）存储的分布式文件管理系统\n\nGithub: happyfish100/fastdfs\n戳—&gt;详细配置步骤，超级详细，傻瓜式，环境是Centos。对于ubuntu，安装编译环境的方式会有不同\ncentos编译环境yum install git gcc gcc-c++ make automake autoconf libtool pcre pcre-devel zlib zlib-devel openssl-devel wget vi -y\nubuntu编译环境apt install git gcc g++ make automake autoconf libtool libpcre3 libpcre3-dev zlib1g zlib1g-dev  libssl-dev wget vi\ntracker和storage如配置步骤所述，fdfs安装好后有tracker配置文件和storage配置文件，前者配置tracker用于上传下载的调度，后者配置storage作为文件存储。tracher监听storage的状态同步消息，使当client上传或下载时，提供可用的storage路径storage可以配置为group，相同group的文件会相互拷贝（这个是需要一定时间的，在集群方案中需要考虑）\n上传文件为使业务应用服务器实现上传fDFS，应实现client功能，即\n\n请求tracker 获取可用storage的 ip port等\n调用相应的storage接口上传文件，接受返回的file_id信息\n\n下载文件\n如图，client实现下载，需\n\n请求tracker 获拉取下载的storage的 ip port等\n调用相应的storage接口下载文件\n\n","tags":["FastDFS"]},{"title":"ESLint","url":"/qqsnote/2020/12/18/eslint/","content":"安装并初始化既有项目npm eslint --init\n安装后自动运行cli提示，选择所需的运行环境(node.js vs browser),模块化风格(es import/export vs CommonJS),是否使用typescript等之后会向package.json添加并安装@typescript-eslint/eslint-plugin eslint-plugin-react @typescript-eslint/parser eslint等\n配置cli(commandline interface)package.json&quot;lint&quot;: &quot;eslint --ext .js src&#x2F;&quot;\n\nIssue: ‘global’ is not defined对于使用webpack打包的web app其编译环境是node.js的，因此可以配置&quot;env&quot;: &#123;    &quot;browser&quot;: true,    &quot;node&quot;: true&#125;,ESLint：环境参数\n\nIssues:\nArrow function expected no return value. (consistent-return)\n141:7 error React Hook useEffect has a missing dependency: ‘render’. Either include it or remove the dependency array react-hooks/exhaustive-deps\n\nrender 方法中包含state属性 应改为useCallback 加入依赖state属性， 然后把render加入报错的副作用的依赖中\n\nExpected ‘this’ to be used by class method ‘getValBetweenFms’. (class-methods-use-this)\n\n改为static方法\n\nExpected to return a value at the end of method ‘getValBetweenFms’. (consistent-return)\n\n函数在循环体中某条件达成时返回 运行时必定返回 但静态类型检查不通过 应在函数末尾return undefined\n","categories":["工具"],"tags":["ESLint"]},{"title":"form-data 以及 basic auth","url":"/qqsnote/2020/04/03/form-data/","content":"PostmanNode.js Serverconst express &#x3D; require(&#39;express&#39;);const app &#x3D; express();var multer &#x3D; require(&#39;multer&#39;);var upload &#x3D; multer();&#x2F;&#x2F; Parse URL-encoded bodies (as sent by HTML forms)app.use(express.urlencoded());&#x2F;&#x2F; for parsing multipart&#x2F;form-dataapp.use(upload.array()); app.use(express.static(&#39;public&#39;));app.post(&#39;&#x2F;&#39;, function(request, response)&#123;    console.log(request.body);    response.json(&#123;res:&#39;ok&#39;,data:request.body&#125;)&#125;);const listener &#x3D; app.listen(process.env.PORT || 3000, function () &#123;console.log(&#39;Your app is listening on port &#39; + listener.address().port);&#125;);Node.js clientconst http &#x3D; require(&#39;http&#39;)const FormData &#x3D; require(&#39;form-data&#39;)function btoa(str) &#123;    return Buffer.from(str).toString(&#39;base64&#39;)&#125;const formData &#x3D; new FormData();formData.append(&#39;username&#39;, &#39;QQs&#39;);formData.append(&#39;password&#39;, btoa(&#39;*****&#39;));const authorizationData &#x3D; &#39;Basic &#39; + btoa(&#39;authorizationID:authorizationPassword&#39;);const options &#x3D; &#123;    hostname: &#39;localhost&#39;,    port: 3000,    path: &#39;&#39;,    method: &#39;POST&#39;,    headers: formData.getHeaders(),    auth: authorizationData&#125;;const req &#x3D; http.request(options, (res) &#x3D;&gt; &#123;    res.setEncoding(&#39;utf8&#39;);    res.on(&#39;data&#39;, (chunk) &#x3D;&gt; &#123;        console.log(&#96;BODY: $&#123;chunk&#125;&#96;);    &#125;);    res.on(&#39;end&#39;, () &#x3D;&gt; &#123;        console.log(&#39;No more data in response.&#39;);    &#125;);&#125;);req.on(&#39;error&#39;, (e) &#x3D;&gt; &#123;    console.error(&#96;problem with request: $&#123;e.message&#125;&#96;);&#125;);formData.pipe(req);Angular httpclientconst formData &#x3D; new FormData();formData.append(&#39;username&#39;, &#39;QQs&#39;);formData.append(&#39;password&#39;, btoa(&#39;*****&#39;));const postUrl &#x3D; &#39;http:&#x2F;&#x2F;loacalhost:3000&#x2F;&#39;;const authorizationData &#x3D; &#39;Basic &#39; + btoa(&#39;authorizationID:authorizationPassword&#39;);const headers &#x3D; new HttpHeaders(&#123;    &#39;Authorization&#39;: authorizationData&#125;);return this.http.post(postUrl, postData, &#123; headers: headers &#125;).pipe(    map(response &#x3D;&gt; &#123;    &#125;))html form&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;authorizationID:authorizationPassword@localhost:3000&#x2F;&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; id&#x3D;&quot;username&quot;&gt;    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot;&gt;    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Post&quot;&gt;&lt;&#x2F;form&gt;\n","categories":["前端技术"],"tags":["Web开发"]},{"title":"forntend-performance","url":"/qqsnote/2021/09/08/forntend-performance/","content":"RAIL模型使用 RAIL 模型衡量性能 即对于应用的 相应 — 动画 — 空闲 — 加载 四种不同场景，用户会对性能有不一样的期望\n\n以用户为中心的性能指标\n\nFirst Paint 首次绘制（FP） 记录从空白页到任意像素的呈现所需时间\nFirst contentful paint 首次内容绘制 (FCP) 首次页面加载完成\nLargest contentful paint 最大内容绘制 (LCP) 任意访问和交互过程中 呈现内容所需的最长时间\nFirst input delay 首次输入延迟 (FID) 从第一次交互到第一次响应\nTime to Interactive 可交互时间 (TTI) 衡量页面从内容渲染完成到可以相应用户交互所需时间\nTotal blocking time 总阻塞时间 (TBT) 即FCP与TTI之间的时差\nCumulative layout shift 累积布局偏移 (CLS) 这是一个评分 衡量页面出现意外的加载内容偏移的程度\n\n页面渲染的过程\n优化http2\n内存泄漏clearTimeout, clearInterval, removeEventListenerThree.js dispose apibrowser - performance - memory\n ","categories":["前端技术"],"tags":["Web开发","性能","http2"]},{"title":"Apache虚拟主机","url":"/qqsnote/2019/01/08/frontEndSeparation/","content":"\nweb服务器&lt;VirtualHost *:80&gt;    DocumentRoot &quot;E:&#x2F;wamp&#x2F;www&quot;    ServerName localhost    ServerAlias localhost&lt;&#x2F;VirtualHost&gt;\n访问权限浏览器报You don’t have permission to access /index.html on this server.&lt;Directory &#x2F;&gt;             Options FollowSymLinks             AllowOverride All             Order deny,allow          Deny from all             Satisfy all&lt;&#x2F;Directory&gt;上述配置是没毛病的，然而只是Apache22语法，Apache24不支持服务器启动报Invalid command Order等\n\nApache2.4版本中，提供了由mod_authz_host支持的新的访问控制配置语法。而2.2版本中的Order、Allow等命令在新版本中也可以得到兼容，实现这个兼容功能的模块就是mod_access_compat。所以Load这个模块后，apache2.4就能识别这些语句了。\n还有，一般情况下，http.conf中可能有其他关于访问权限的配置，如默认有AllowOverride noneRequire all denied\n\n解决跨域\n\n","categories":["前端技术"],"tags":["Apache"]},{"title":"formatjs","url":"/qqsnote/2021/04/14/formatjs/","content":"安装yarn add react-intlyarn add -D @formatjs&#x2F;ts-transformer\n\nwe highly recommend declaring defaultMessages inline along with their usages because of the following reasons: 建议使用声明内联的defaultMessages， 连同他们的usage，原因如下\n\n\nMessages colocated with their usages become self-managed, as their usages change/removed, so are the messages. 搭配usage的Message成为自治的 当usage更改或移除，Message亦同\nMessages are highly contextual. We’ve seen a lot of cases where developers assume a certain grammar when they write their messages. Buttons/Call-To-Actions and labels are also translated differently. Message高度关联上下文， 杜绝为message发明新语法或编规则\nText styling is also dependent on the message itself. Things like truncation, capitalization… certainly affect the messages themselves. 会与样式相关\nBetter integrations with toolchains. Most toolchains cannot verify cross-file references to validate syntax/usage. 易于工具链集成\n\n格式化语法import * as React from &#39;react&#39;import &#123;IntlProvider, FormattedMessage, FormattedNumber&#125; from &#39;react-intl&#39;&lt;IntlProvider messages&#x3D;&#123;messagesInFrench&#125; locale&#x3D;&quot;fr&quot; defaultLocale&#x3D;&quot;en&quot;&gt;    &lt;p&gt;    &lt;FormattedMessage        id&#x3D;&quot;myMessage&quot;        defaultMessage&#x3D;&quot;Today is &#123;ts, date, ::yyyyMMdd&#125;&quot;        values&#x3D;&#123;&#123;ts: Date.now()&#125;&#125;    &#x2F;&gt;    &lt;br &#x2F;&gt;    &lt;FormattedNumber value&#x3D;&#123;19&#125; style&#x3D;&quot;currency&quot; currency&#x3D;&quot;EUR&quot; &#x2F;&gt;    &lt;&#x2F;p&gt;&lt;&#x2F;IntlProvider&gt;\n\nError: [React Intl] Could not find required ‘intl’ object.  IntlProvider needs to exist in the component ancestry\n\n当没有IntlProvider父组件时报上述异常\n提取文本映射yarn add -D @formatjs&#x2F;cli\npackage.json中添加脚本命令&quot;extract&quot;: &quot;formatjs extract&quot;执行yarn extract &#39;src&#x2F;**&#x2F;*.ts*&#39; --out-file lang&#x2F;en.json --id-interpolation-pattern &#39;[sha512:contenthash:base64:6]&#39;或npm run extract -- &#39;src&#x2F;**&#x2F;*.ts*&#39; --out-file lang&#x2F;en.json --id-interpolation-pattern &#39;[sha512:contenthash:base64:6]&#39;将待翻译的message保存为指定语言的json文件，没id的message自动编码id\n分发将翻译好的多语言lang/*.json编译为Intl使用的格式package.json中添加脚本命令&quot;compile&quot;: &quot;formatjs compile&quot;执行yarn compile lang&#x2F;fr.json --ast --out-file compiled-lang&#x2F;fr.json或npm run compile -- lang&#x2F;fr.json --ast --out-file compiled-lang&#x2F;fr.json\n切换语言代码import * as React from &#39;react&#39;import * as ReactDOM from &#39;react-dom&#39;import &#123;IntlProvider&#125; from &#39;react-intl&#39;function loadLocaleData(locale: string) &#123;  switch (locale) &#123;    case &#39;fr&#39;:      return import(&#39;compiled-lang&#x2F;fr.json&#39;)    default:      return import(&#39;compiled-lang&#x2F;en.json&#39;)  &#125;&#125;function App(props) &#123;  return (    &lt;IntlProvider      locale&#x3D;&#123;props.locale&#125;      defaultLocale&#x3D;&quot;en&quot;      messages&#x3D;&#123;props.messages&#125;    &gt;      &lt;MainApp &#x2F;&gt;    &lt;&#x2F;IntlProvider&gt;  )&#125;async function bootstrapApplication(locale, mainDiv) &#123;  const messages &#x3D; await loadLocaleData(locale)  ReactDOM.render(&lt;App locale&#x3D;&#123;locale&#125; messages&#x3D;&#123;messages&#125; &#x2F;&gt;, mainDiv)&#125;\n切换语言触发IntlProvider下的组件初始化，将本地化的messages词条传入组件上下文\nuseIntl钩子返回当前语言的provider对象，提供formatData,formatMessage等方法，从messages词条中映射字符串const intl &#x3D; useIntl()return (  &lt;span title&#x3D;&#123;intl.formatDate(date)&#125;&gt;    &lt;FormattedDate value&#x3D;&#123;date&#125; &#x2F;&gt;  &lt;&#x2F;span&gt;)带参数的格式化MessagedragAreaSupportTip(format: string) &#123;  const messages &#x3D; defineMessages(&#123;    supportTip: &#123;      id: &#39;dragArea.supportTip&#39;,      defaultMessage: &#39;Only supports &#123;format&#125; files&#39;,    &#125;,  &#125;)  return intl.formatMessage(messages.supportTip, &#123; format &#125;);&#125;formatjs extract和compile命令可以在此使用switch case 场景translateEnums(name:string)&#123;  name &#x3D; name.replace(&#x2F; &#x2F;g, &#39;_&#39;)  const messages &#x3D; defineMessages(&#123;    transName: &#123;      id: &#39;enums.name&#39;,      defaultMessage: &#96;&#123;name, select,        dog &#123;dog&#125;        cat &#123;cat&#125;        King_Kong &#123;King Kong&#125;        other &#123;&#123;name&#125;&#125;      &#125;&#96;,    &#125;,  &#125;)  const translatedName &#x3D; this.intl.formatMessage(messages.transName, &#123; name:name &#125;);  return translatedName.replace(&#x2F;_&#x2F;g, &#39; &#39;)&#125;格式是{key, select, 选项..}的样子，见format.js Doc:select format 选项是’value {text}的格式，value据说遵循Unicode Pattern_Syntax 然而我并没有找到空格的表示法，如上’金刚’的名字用下划线替换了空格，另外匹配失败返回原字符串，变量key需再加大括号括起来\n","categories":["前端技术"],"tags":["多语言"]},{"title":"golang","url":"/qqsnote/2024/01/10/golang/","content":"Go编程语言是Google中一些大牛（尤其是有着plan9前科的大牛们）如Rob Pike，Ken Thomason这两位赫赫有名的程序高手、技术作于2007年9月开始建造。 Pike指出，Go代码的编译基本上可以达到C语言的速度，几乎可以在瞬间完成，“就像是在使用交互式语言”。现有的语言都没有针对多核心处理器 进行优化，为了解决此类编程问题，Google工程师们开发了Go语言。从源文件的copyright可以看到，很多基础代码来自plan9. Go 已在Google公司内部测试过，现在已经发布 Go 1 RC1 版本。Google开放Go的代码，希望籍此帮助Go语言的发展。首席软件工程师Rob Pike说：我们开发Go，是因为近10年左右开发程序之难让我们有点沮丧。Google两年前开始开发Go，1年前开始有一只团队专职于此。目前只支持 unix平台， windows平台的支持由于资源的原因，需要更多的参与者来移植。 Go的定位 是系统编程，比如Web服务器、存储系统和数据库等，但也欢迎在其它方面的应用。 Go 语言官方网站\njava 和 go，谁才是最终答案java优势：\n\n1.1 比较强大的地方是那个jvm，他让你有一些字节码增强的技，jvm层面的语言自带的aop。\n1.2 有泛型。\n1.3 有annotation技术，这个貌似是java5才出来的。\n1.4 面向对象语言。\n1.5 有threadlocal技术\n\ngo的优势：\n\n1.1 go有多协程的能力，有select和channel让协程能通讯。\n1.2 可以定义对象为指针还是对象本体，如果返回对象本体则肯定不会出现空指针。而且go的空对象调用方法也不一定会npe，因为空对象本身不是真的空，是有类型的空对象。\n1.3 面向接口的语言，有些面向对象的设计模式不太好写，不过不是重点。\n1.4 方法能返回多个对象，编程不会再创建这么多class去包对象了。\n1.5 异常处理机制比较特别，go官方建议大家每个函数返回err，这样当你调用方法的时候，会强制让你回答：”如果这个方法异常，你应该怎么做”。不像java，都是throw出去，所以go编程的异常case会少一些。不过这样也让代码很臃肿，到处都是if err!= nil 。\n\n","tags":["Go"]},{"title":"graphQL","url":"/qqsnote/2021/05/14/graphQL/","content":"OData和GraphQL用了微软家的OData，就不得不再看一遍GraphQL，两者都让前端调用api获得了很大的自由度相比OData的底层渗透性，GraphQL只在Http接口层做文章，实际上将底层模型封装成schema，开放给接口，这个过程更大程度上做到了安全性和前端业务的可控。\nQuick Start见官方GraphQL Doc：各种语言实现var express &#x3D; require(&#39;express&#39;);var &#123;graphqlHTTP&#125; &#x3D; require(&#39;express-graphql&#39;);var &#123; buildSchema &#125; &#x3D; require(&#39;graphql&#39;);var schema &#x3D; buildSchema(&#96;  type Query &#123;    heros: [Hero]    battle(name:String): String    random: Float!  &#125;  type Hero&#123;    name:String    abilities: [String]&#125;&#96;);var root &#x3D; &#123; heros: () &#x3D;&gt; ([        &#123;            name: &#39;Luke skywalker&#39;,            abilities: [&#39;light sward&#39;, &#39;force&#39;]        &#125;,        &#123;            name: &#39;Anakin skywalker&#39;,            abilities: [&#39;light sward&#39;, &#39;force&#39;, &#39;dark&#39;]        &#125;    ]),    battle: (name) &#x3D;&gt; &#123;        return &#39;I am your father&#39;;      &#125;,      random: () &#x3D;&gt; &#123;        return Math.random();      &#125; &#125;;var app &#x3D; express();app.use(&#39;&#x2F;graphql&#39;, graphqlHTTP(&#123;  schema: schema,  rootValue: root,  graphiql: true,&#125;));app.listen(3000, () &#x3D;&gt; console.log(&#39;Now browse to localhost:3000&#x2F;graphql&#39;));关于graphqlHTTP(也就是GraphiQL客户端)的Options：schema是查询涉及的类型声明， rootValue api的查询方法的集，详见下文章节\nschema 类型声明var schema &#x3D; buildSchema(&#96;    type Hero &#123;        name: String!        abilities: [String!]!        length(unit: LengthUnit &#x3D; METER): Float    &#125;&#96;);\n标量类型\n\nID\nString\nBoolean\nInt Float注意 ！表示非空枚举enum Episode &#123;  NEWHOPE  EMPIRE  JEDI&#125;\n\n\n接口和实现接口的类型type Human implements Character &#123;  id: ID!  name: String!  friends: [Character]  appearsIn: [Episode]!  starships: [Starship]  totalCredits: Int&#125;\n联合类型union SearchResult &#x3D; Human | Droid | Starship\n操作类型\nquery 查询：获取数据、查找\nmutation 变更：对数据进行变更，比如增加、删除、修改\nsubstription 订阅：当数据发生更改，进行消息推送\n\nGraphQL client前面的express-graphQL启动后打开GraphiQL页面，GraphiQL就是一个客户端，使用GraphQL client向 GraphQL 服务器上的入口端点发送一个 HTTP POST 请求，其中将 GraphQL 查询作为 JSON 载荷的 query 字段，就能调用 GraphQL 服务器。其js实现大致是fetch(&#39;&#x2F;graphql&#39;, &#123;  method: &#39;POST&#39;,  headers: &#123;    &#39;Content-Type&#39;: &#39;application&#x2F;json&#39;,    &#39;Accept&#39;: &#39;application&#x2F;json&#39;,  &#125;,  body: JSON.stringify(&#123;query: &quot;&#123; hello &#125;&quot;&#125;)&#125;)  .then(r &#x3D;&gt; r.json())  .then(data &#x3D;&gt; console.log(&#39;data returned:&#39;, data));\n查询参数schema 中的 Query声明了若干查询方法，查询方法的具体实现在root中定义，其参数类型的指定格式与typescript相同！调用格式如下&#123;  battle(name:&quot;dark lord&quot;)&#125;\n","tags":["GraphQL"]},{"title":"Hexo TroubleShooting","url":"/qqsnote/2019/04/22/hexo-troubleshooting/","content":"hexo d\n\nError: spawn git ENOENThexo scannot GET \n\n自定义js放在/themes/next/source/js/, 官网说的根路径scripts文件夹并不行\n","categories":["前端技术"],"tags":["hexo"]},{"title":"HTTP","url":"/qqsnote/2021/09/13/http/","content":"\nGet和Post的区别总结：get 用于获取信息，无副作用，幂等，且可缓存。post 用于修改服务器上的数据，有副作用，非幂等，不可缓存\n\n其实HTTP协议本身并没有对URL和BODY的长度限制，对URL限制的大多是浏览器和服务端自己限制的。\n传参方式不受TCP传输限制 Get使用url Post使用Body的方式是约定俗成 服务端可自行制定规则从header或body获取参数\n\n幂等性 (Idempotence)Put vs PostData URL最初见于css插入图片资源 data协议数据格式形如data:[&lt;mediatype&gt;][;base64],&lt;data&gt;其中mediatype 是个 MIME 类型的字符串，例如 ‘image/jpeg’ 表示 JPEG 图像文件。如果被省略，则默认值为 text/plain;charset=US-ASCII。\n","categories":["前端技术"],"tags":["http"]},{"title":"一个Download的实现","url":"/qqsnote/2019/12/06/httpdownload/","content":"fetch download CORS issueconst fetchDCM &#x3D; async (url:string) &#x3D;&gt; &#123;const response &#x3D; await fetch(url, &#123; method: &quot;GET&quot; &#125;)if (response.ok) &#123;    const buffer &#x3D; await response.arrayBuffer()    const data &#x3D; parseLoadData(buffer);    ......&#125;&#125;;\n浏览器中点击直接下载文件的链接，放在fetch方法中会有跨域问题\n浏览器中点击下载文件的链接时，这被视为用户的直接操作，浏览器允许这类导航请求执行，因为它符合用户的意图且风险较低。\nfetch属于AJAX请求范畴，会受到同源策略的严格限制。即使请求的目标是下载一个文件，浏览器也会将其视为脚本试图访问跨域资源，从而可能触发跨域资源共享（CORS）检查。如果服务器没有正确配置CORS响应头，允许你的源域名发起请求，浏览器就会阻止这次请求或者请求成功但无法访问响应体中的数据。\nCORS（跨域资源共享）主要是为了保护客户端（即用户的浏览器）的安全和隐私，同时也为服务器端提供了一定程度上的控制权。其工作原理是通过在浏览器层面实施安全策略，确保来自不同源的Web内容不能随意访问或操作其他源的资源，除非得到服务器的明确许可。\n具体来说，当一个网页尝试通过JavaScript等客户端脚本从不同的源加载数据时，CORS机制会要求浏览器在实际发送请求之前，先向服务器发起一个预检（preflight）请求，询问服务器是否允许这样的跨域操作。服务器通过在响应头中添加特定的CORS相关字段，如Access-Control-Allow-Origin，来指示浏览器哪些来源的请求是可以接受的。如果服务器不允许该请求，浏览器则会阻止客户端脚本获取响应数据，从而防止了潜在的安全威胁，如跨站脚本攻击（XSS）和数据泄露等。\n因此，虽然CORS规则是由服务器设置并返回给客户端的，其主要目的还是在于保护客户端免受恶意第三方网站的侵害，同时给予服务器对资源访问权限的精细控制。&#x2F;&#x2F; Manual CORS Configurationapp.use((req, res, next) &#x3D;&gt; &#123;    res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);    res.header(&#39;Access-Control-Allow-Headers&#39;,                &#39;Origin, X-Requested-With, Content-Type, Accept&#39;);    next();&#125;);app.get(&#39;&#x2F;download&#x2F;:filename&#39;, (req, res) &#x3D;&gt; &#123;    const filePath &#x3D; path.join(__dirname, &#39;public&#39;, req.params.filename);    res.setHeader(&#39;Content-Disposition&#39;, &#39;attachment;&#39;);    const readStream &#x3D; fs.createReadStream(filePath);    readStream.pipe(res);&#125;);\n需求：导出列表一个服务端分页的可检索列表，页面只缓存当前页的数据，导出功能无法完全在前端，点击export将现有检索条件传到后端，由后端查询数据库并生成excel文件，传到前端。\n后端实现(Express.js)app.post(&#39;&#x2F;list&#x2F;export&#39;, (req,res)&#x3D;&gt;&#123;    const data &#x3D; getDataFromDB(req.body)        generateExcel(results, ()&#x3D;&gt;&#123;            res.download(path.join(__dirname,&#39;list.xlsx&#39;));        &#125;)    &#125;, err &#x3D;&gt; &#123;        res.json(err)    &#125;)&#125;)const columns &#x3D; [    &#123; header: &#39;ID&#39;, key: &#39;id&#39;, width: 32 &#125;,    &#123; header: &#39;Name&#39;, key: &#39;name&#39;, width: 32 &#125;];const generateExcel &#x3D; function(data, callback)&#123;    const excel &#x3D; require(&#39;exceljs&#39;);    &#x2F;&#x2F; create excel workbook    var options &#x3D; &#123;        filename:path.join(__dirname, &#39;list.xlsx&#39;),        useStyles: true,        useSharedStrings: true    &#125;;    const workbook &#x3D; new excel.stream.xlsx.WorkbookWriter(options);    workbook.creator &#x3D; &#39;QQs&#39;;    workbook.created &#x3D; new Date();    workbook.modified &#x3D; new Date();    &#x2F;&#x2F; views    workbook.views &#x3D; [        &#123;            x: 0, y: 0, width: 10000, height: 20000,            firstSheet: 0, activeTab: 1, visibility: &#39;visible&#39;        &#125;    ]    &#x2F;&#x2F; add worksheet    const sheet &#x3D; workbook.addWorksheet(&#39;List&#39;);    &#x2F;&#x2F; define columns    sheet.columns &#x3D; columns;    &#x2F;&#x2F; add rows    &#x2F;*    数据量大的情况下考虑到nodejs内存分配瓶颈    *应限制每次select的条数分批addRow并且Row.commit    *&#x2F;    data.forEach(record &#x3D;&gt; &#123;        const row &#x3D; record;        &#x2F;&#x2F; TODO data convertor        sheet.addRow(row).commit();    &#125;);    sheet.commit();    workbook.commit().then(callback);&#125;\n生成Excel用到了第三方库exceljs，该库实现了流式写excel的方法，可以在数据量较大的情况下缓解IO压力(待考证)\nresponse.download(filename)方法以Blob方式返回数据\n前端实现(Angular8)export() &#123;    const postParams &#x3D; new Object();    &#x2F;&#x2F; TODO collect query parameters    this.httpClient      .post(&#39;list&#x2F;export&#39;, postParams, &#123;        responseType: &#39;blob&#39;,        headers: new HttpHeaders().append(&#39;Content-Type&#39;, &#39;application&#x2F;json&#39;),      &#125;)      .subscribe(res &#x3D;&gt; &#123;        this.downloadFile(res);      &#125;);  &#125;  &#x2F;**   * 创建blob对象，并利用浏览器打开url进行下载   * @param data 文件流数据   *&#x2F;  downloadFile(data) &#123;    &#x2F;&#x2F; 下载类型 xls    const contentType &#x3D; &#39;application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet&#39;;    const blob &#x3D; new Blob([data], &#123; type: contentType &#125;);    const url &#x3D; window.URL.createObjectURL(blob);    &#x2F;&#x2F; 打开新窗口方式进行下载    &#x2F;&#x2F; window.open(url);    &#x2F;&#x2F; 以动态创建a标签进行下载    const a &#x3D; document.createElement(&#39;a&#39;);    a.href &#x3D; url;    &#x2F;&#x2F; a.download &#x3D; fileName;    a.download &#x3D; &#39;list.xlsx&#39;;    a.click();    window.URL.revokeObjectURL(url);  &#125;\n接受请求必须设置response headers，否则默认设置无法取得返回值并进入next回调。\n单次下载限制浏览器下载线程有限制，通常同一时间下载不超过10个文件，超过数量的请求直接被无视\n解决方案一是设置时间间隔 避免同时下载二是zip一下打包下载 jszip\n","categories":["前端技术"],"tags":["Angular","Node.js"]},{"title":"关于Upload功能的概述","url":"/qqsnote/2021/02/01/httpupload/","content":"file input前端文件上传入口一律使用input type=”file”, 关于UI的优化可参考Angular-Tips\n图片以base64存放关系数据库File对象转Uri&lt;input type&#x3D;&quot;file&quot; (change)&#x3D;&quot;handleUpload($event)&quot;&gt;————————————————————————————handleUpload(event) &#123;    const fileInput &#x3D; event.target;    const imgFile: File &#x3D; fileInput.files[0];    if (imgFile.type !&#x3D;&#x3D; &#39;image&#x2F;jpeg&#39; &amp;&amp; imgFile.type !&#x3D;&#x3D; &#39;image&#x2F;png&#39;) &#123;        this.msgService.error(&#39;You can only upload JPG file or PNG file.&#39;);        return;    &#125;    if (imgFile.size! &#x2F; 1024 &gt; this.logoSizeLimit) &#123;        this.msgService.error(&#96;Image must smaller than $&#123;this.logoSizeLimit&#125;k.&#96;);        return;    &#125;    const reader &#x3D; new FileReader();    reader.onload &#x3D; (e) &#x3D;&gt; &#123;        this.logoUri &#x3D; e.target.result;    &#125;    reader.readAsDataURL(imgFile);&#125;logoUri即图片经Bese64编码的字符串，可以直接存入数据库字段，可放入img：src作为上传预览\n文件和流\nBlob 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 来用于数据操作。\n\nFile继承Blob, File作为特殊的Blob，可以用在任意的 Blob 类型的 context 中。比如FileReader, URL.createObjectURL(), createImageBitmap(), 及 XMLHttpRequest.send() \n上一节使用的FileReader.readAsDataURL方法,读取指定的 Blob 或 File 对象。读取操作完成的时候，readyState 会变成已完成DONE，并触发 loadend 事件，同时 result 属性将包含一个data:URL格式的字符串（base64编码）以表示所读取文件的内容。\nURL.createObjectURL(object)返回一个DOMString，其包含object的URL，console中输出的话所谓的DOMString形如blob:https:&#x2F;&#x2F;localhost:44362&#x2F;fd57b5f3-a3b9-47ae-bd9d-56fc9012fb83其生命周期与当前document相同，调用URL.revokeObjectURL释放\ncanvas.toBlobfunction canvas2file()&#123;    var image &#x3D; document.querySelector(&#39;img&#39;);    var canvas &#x3D; document.createElement(&quot;canvas&quot;);    canvas.width &#x3D; image.width;    canvas.height&#x3D; image.height;    var ctx &#x3D; canvas.getContext(&quot;2d&quot;);    ctx.drawImage( image, 0, 0 );    console.log(canvas.toBlob());&#x2F;&#x2F;转换成bold类型    console.log(canvas.toDataURL());&#x2F;&#x2F;转换成dataURL类型&#125;格物致知：从响应式编程理解‘流’nodejs_stream\n大文件分片上传\n","categories":["前端技术"],"tags":["上传"]},{"title":"ionic","url":"/qqsnote/2019/09/09/ionic/","content":"npm install -g cordave ionic\n说明一下ionic和cordaveionic 是一款开源的Html5移动App开发框架,是Angular移动端解决方案,Ionic以流行的跨平台移动app开发框架phoengap为蓝本，让开发者可以通过命令行工具快速生成android、ios移动app应用。将项目打包生成移动app应用，需要用到phoengap，而cordave是phoengap的开源发行版。\n新建项目:ionic start myApp tabs运行项目:cd myAppionic serve&#x2F;&#x2F; 打包成单页面项目运行在微信&#x2F;web浏览器:$ ionic build&#x2F;&#x2F; 打包成混合app项目:$ ionic build$ ionic cordova platform add ios$ ionic cordova run android &#x2F;&#x2F; Run an Ionic project on a connected device使用cordova构建移动app 还有额外开发环境要求，如Android SDK toolsJava\n","categories":["前端技术"],"tags":["Angular","ionic"]},{"title":"jenkins参数化","url":"/qqsnote/2020/04/09/jenkins-parameterize/","content":"使用Git Parameter简化GitFlow工作方式的持续集成\n\n安装Git Parameter Plugin\n设置 Jenkins Job ‘this project is parameterized’\n设置变量BRANCH_NAME，变量类型为Branch or Tag, 默认为master\n设置 Source Code Management - Branches to build 为 $BRANCH_NAME\n\n完成后可使用该项目的build with Parameters功能，即选择特定分支进行构建\n","categories":["工具"],"tags":["Jenkins"]},{"title":"jenkins-pipeline","url":"/qqsnote/2023/03/02/jenkins-pipeline/","content":"Jenkins Pipeline 提供了一套可扩展的工具，用于将“简单到复杂”的交付流程实现为“持续交付即代码”。Jenkins Pipeline 的定义通常被写入到一个文本文件（称为 Jenkinsfile ）中，该文件可以被放入项目的源代码控制库中。 \n","categories":["工具"],"tags":["Jenkins"]},{"title":"jenkins-slave","url":"/qqsnote/2023/04/20/jenkins-slave/","content":"Jenkins的Master/Slave相当于Server和agent的概念，Master提供web接口让用户来管理Job和Slave，Job可以运行在Master本机或者被分配到Slave上运行。一个Master可以关联多个Slave用来为不同的Job或相同的Job的不同配置来服务。\n其显而易见的意义在于使用同一个管理界面调用不同的开发环境 \n新建节点在开发环境上安装一个jenkins作为slave在服务器jenkins上添加slave node: Dashboard &gt; Manage Jenkins &gt; Manage Nodes and Cloudscreate后进行slave node配置\n\nRemote root directory 这个是slave上的jenkins工作目录，job会在此拉取项目并构建\nLabels 标签 将多个slave标记为一组 用于创建job时选择宜用的slave如果需要调用slave机器上应用，可能需要设置环境变量，如使用某路径下的签名软件对构建的程序打签名，路径变量在此处调用git拉取代码也要指定路径，否则会在master上看到无法定位到git\n\n保存后会提供 连接命令，需要在slave端执行\n使用slave构建","categories":["工具"],"tags":["Jenkins"]},{"title":"Jenkins对Node.js项目的持续集成","url":"/qqsnote/2019/10/24/jenkinsNodejs/","content":"安装NodeJSManage Jenkins菜单 —&gt; Manage Plugins添加Node.js 并重启Jenkins进入 Manage Jenkins —&gt; Global Tool Configuration找到NodeJS installations 此处可以配置安装多个版本的NodeJS如有需要填写Global npm packages to install项如@angular&#x2F;cli@8.2.2 electron@6.0.2 electron-builder@21.2.0 node-gyp@6.1.0\n添加和使用credentials 有用户名密码模式 ssh模式等ssh模式粘贴private key即可\n建立Job 选择Freestyle project配置git并选择credentialsBuild Environment中 勾选 “Provide Node &amp; npm bin/ folder to PATH” 并选择已安装的版本否则jenkins所在系统无法识别nodejs命令\n最后 Build 步骤可以直接用 “Windows batch command” 或者 “execuate shell”调用npm install &amp;&amp; npm run build\n注意 npm 命令是安装了node包管理工具之后的命令行指令，并非是nodejs命令,否则报 syntaxerror unexpected identifier\n","categories":["工具"],"tags":["Node.js","Jenkins"]},{"title":"Date","url":"/qqsnote/2018/12/31/jsDate/","content":"\n\n\n\n方法\n描述\n\n\n\n\ngetDate()\n从 Date 对象返回一个月中的某一天 (1 ~ 31)。\n\n\ngetDay()\n从 Date 对象返回一周中的某一天 即星期几 (0 ~ 6)。\n\n\ngetMonth()\n从 Date 对象返回月份 (0 ~ 11)。\n\n\ngetFullYear()\n从 Date 对象以四位数字返回年份。\n\n\ngetHours()\n返回 Date 对象的小时 (0 ~ 23)。\n\n\ngetMinutes()\n返回 Date 对象的分钟 (0 ~ 59)。\n\n\ngetSeconds()\n返回 Date 对象的秒数 (0 ~ 59)。\n\n\ngetMilliseconds()\n返回 Date 对象的毫秒(0 ~ 999)。\n\n\ngetTime()\n返回 1970 年 1 月 1 日至今的毫秒数。\n\n\ngetTimezoneOffset()\n返回本地时间与格林威治标准时间 (GMT) 的分钟差。\n\n\ngetUTCDate()\n根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。\n\n\ngetUTCDay()\n根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。\n\n\ngetUTCMonth()\n根据世界时从 Date 对象返回月份 (0 ~ 11)。\n\n\ngetUTCFullYear()\n根据世界时从 Date 对象返回四位数的年份。\n\n\ngetUTCHours()\n根据世界时返回 Date 对象的小时 (0 ~ 23)。\n\n\ngetUTCMinutes()\n根据世界时返回 Date 对象的分钟 (0 ~ 59)。\n\n\ngetUTCSeconds()\n根据世界时返回 Date 对象的秒钟 (0 ~ 59)。\n\n\ngetUTCMilliseconds()\n根据世界时返回 Date 对象的毫秒(0 ~ 999)。\n\n\nparse()\n返回1970年1月1日午夜到指定日期（字符串）的毫秒数。\n\n\nsetDate()\n设置 Date 对象中月的某一天 (1 ~ 31)。\n\n\nsetMonth()\n设置 Date 对象中月份 (0 ~ 11)。\n\n\nsetFullYear()\n设置 Date 对象中的年份（四位数字）。\n\n\nsetYear()\n请使用 setFullYear() 方法代替。\n\n\nsetHours()\n设置 Date 对象中的小时 (0 ~ 23)。\n\n\nsetMinutes()\n设置 Date 对象中的分钟 (0 ~ 59)。\n\n\nsetSeconds()\n设置 Date 对象中的秒钟 (0 ~ 59)。\n\n\nsetMilliseconds()\n设置 Date 对象中的毫秒 (0 ~ 999)。\n\n\nsetTime()\n以毫秒设置 Date 对象。\n\n\nsetUTCDate()\n根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。\n\n\nsetUTCMonth()\n根据世界时设置 Date 对象中的月份 (0 ~ 11)。\n\n\nsetUTCFullYear()\n根据世界时设置 Date 对象中的年份（四位数字）。\n\n\nsetUTCHours()\n根据世界时设置 Date 对象中的小时 (0 ~ 23)。\n\n\nsetUTCMinutes()\n根据世界时设置 Date 对象中的分钟 (0 ~ 59)。\n\n\nsetUTCSeconds()\n根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。\n\n\nsetUTCMilliseconds()\n根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。\n\n\ntoSource()\n返回该对象的源代码。\n\n\ntoString()\n把 Date 对象转换为字符串。\n\n\ntoTimeString()\n把 Date 对象的时间部分转换为字符串。格式如：09:58:59 GMT+0800 (China Standard Time)\n\n\ntoDateString()\n把 Date 对象的日期部分转换为字符串。格式如：Wed Nov 10 2021\n\n\n~~toGMTString()\n请使用 toUTCString() 方法代替。~~\n\n\ntoUTCString()\n根据世界时，把 Date 对象转换为字符串。Wed, 10 Nov 2021 02:00:48 GMT\n\n\ntoLocaleString()\n根据本地时间格式，把 Date 对象转换为字符串。11/10/2021, 10:01:19 AM\n\n\ntoLocaleTimeString()\n根据本地时间格式，把 Date 对象的时间部分转换为字符串。10:01:19 AM\n\n\ntoLocaleDateString()\n根据本地时间格式，把 Date 对象的日期部分转换为字符串。11/10/2021\n\n\nUTC()\n根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。\n\n\nvalueOf()\n返回 Date 对象的原始值。\n\n\n\n\n月份的英文缩写\n\n使用数组[‘Jan’, ‘Feb’, ‘Mar’, ‘Apr’, ‘May’, ‘June’, ‘July’, ‘Aug’, ‘Sept’, ‘Oct’, ‘Nov’, ‘Dec’][(new Date()).getMonth()]\n使用格式化字符串(new Date()).toDateString().split(“ “)[1]\n\n星期同理Date.property.format&#x3D;function(format)&#123;    &#x2F;&#x2F; eg: format&#x3D;&quot;yyyy-MM-dd hh:mm:ssS&quot;    var o &#x3D; &#123;        &quot;M+&quot;: this.getMonth() + 1,        &quot;d+&quot;: this.getDate(),        &quot;h+&quot;: this.getHours(),        &quot;m+&quot;: this.getMinutes(),        &quot;s+&quot;: this.getSeconds(),        &quot;q+&quot;: Math.floor((this.getMonth() + 3)&#x2F;3), &#x2F;&#x2F;quarter        &quot;S&quot;: this.getMilliseconds()    &#125;;    if(&#x2F;(y+)&#x2F;.test(format))&#123;        format &#x3D; format.replace(RegExp.$1,(this.getFullYear) + &quot;&quot;).substr(4 - RegExp.$1.length)    &#125;    for(var k in o)&#123;        if(new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(format))&#123;            format &#x3D; format.replace(RegExp.$1, RegExp.$1.length &#x3D;&#x3D; 1?o[k]:(&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length));        &#125;    &#125;    return format;&#125;\n","categories":["前端技术"],"tags":["javascript"]},{"title":"jenkins issues","url":"/qqsnote/2019/09/11/jenkinsissues/","content":"submodules首先submodule就是个坑，在包含submodule的项目中通过配置.gitmodules文件与子模块仓库建立联系。\n\n配置包含submodule的项目job\n\n退出、重启等域名+exit/restart\nwindows的启动、停止和重启 ———— 在安装目录下执行cmd命令 jenkins.exe start/stop/restart\nenv: ‘node’: No such file or directory现于docker jenkins-blueocean，找到nodejs安装路径如“/var/jenkins_home/tools/jenkins.plugins.nodejs.tools.NodeJSInstallation/nodejs_v10/bin”之下的npm命令，执行个npm -v，显示相同提示。据说是镜像bug JENKINS-34815# 进入jenkins对应容器中# docker exec -it [对应容器id] bash # 安装nodejs# apk add --no-cache nodejs # 检查node# node -v\n构建完成后拷贝文件到目标服务器关于插件publish over ssh配置中填的是jenkins这边的私钥，应为jenkins生成ssh key 或使用jenkins所在服务器的ssh private keyssh-keygen -t rsa -C &quot;jenkins&quot; -f ~&#x2F;.ssh&#x2F;jenkins上述命令可以生成以名字区分的ssh key，而不覆盖其他的key\n公钥复制到远程服务器，粘贴到~/.ssh/authorized_keys 这个文件没有就创建一个chmod 700 ~&#x2F;.ssh&#x2F;authorized_keys为使ssh agent生效 QQs重启了远程服务器。。。回到jenkins配置中，完成接下来的远程服务器配置username是登录远程服务器的用户名，与key无关Caution！ 拷贝文件时,如果包含文件夹，Source files路径通配符应写为dist/**\n","categories":["工具"],"tags":["Jenkins"]},{"title":"JavaScript getter setter","url":"/qqsnote/2019/08/13/jsGetterSetter/","content":"“修改默认操作”面试题：对于对象o有N个属性，不修改下面代码，编写一段程序获取到对象o的所有属性。var foo &#x3D; (function()&#123;    var o &#x3D; &#123;       a: 1,       b: 2,       &#x2F;**更多属性**&#x2F;    &#125;;    return function(key) &#123;        return o[key];    &#125;&#125;)();对象o只是函数作用域中的一个局部变量，而对外提供的唯一接口foo(key)可以获取到对象o单独的某个key对应的value，如：foo(‘a’)返回1。但是这里要求获取一个未知属性个数对象o的所有属性。\n\n在 ES5 中可以使用 getter 和 setter 部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上。getter是一个隐藏函数，会在获取属性值时调用。setter也是一个隐藏函数，会在设置属性值时调用。\n\nvar test &#x3D; &#123;    get o()&#123;        console.log(&#39;监听到正在获取属性o的值&#39;);        return this._o;    &#125;,    set o(v)&#123;        console.log(&#39;监听到正在设置属性o的值为：&#39; + v);        this._o &#x3D; v;        return this._o;    &#125;&#125;test.o &#x3D; 14; &#x2F;&#x2F; 监听到正在设置属性o的值为：14console.log(test.o); &#x2F;&#x2F; 监听到正在获取属性o的值\n答题提示：添加一个属性，并且借助修改其默认get方法暴露this （闭包应用）答案：Object.defineProperty(Object.prototype, &#39;self&#39;, &#123;    get() &#123;        return this;    &#125;&#125;);var o &#x3D; foo(&#39;self&#39;);console.log(Object.keys(o)); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;]\n\n评论：因为o上的属性有若干个，你不确定o上是否存在属性名为self的的属性，如果存在，你就获取不到原型上的self了，所以最好使用Symbol。改进：var key &#x3D; Symbol();Object.defineProperty(Object.prototype, key, &#123;    get() &#123;        return this;    &#125;&#125;);var o &#x3D; foo(key);console.log(Object.keys(o)); &#x2F;&#x2F; [&#39;a&#39;, &#39;b&#39;]\n触发其他操作搞一个方块，移动10像素var box &#x3D;document.createElement(&quot;div&quot;);box.setAttribute(&quot;id&quot;,&quot;box&quot;);box.setAttribute(&quot;style&quot;,&quot;width:30px;height:30px;background:red;&quot;);var transformText &#x3D; &#39;translateX(&#39; + 10 + &#39;px)&#39;;box.style.transform &#x3D; transformText;封装让方块移动的操作 当然可以这样function moveBox(distance)&#123;    box.style.transform &#x3D; &#39;translateX(&#39; + distance + &#39;px)&#39;;&#125;其实也可以这样Object.defineProperty(box, &#39;move&#39;, &#123;    set: function(value) &#123;        var transformText &#x3D; &#39;translateX(&#39; + value + &#39;px)&#39;;        box.style.webkitTransform &#x3D; transformText;        box.style.transform &#x3D; transformText;    &#125;&#125;)&#x2F;&#x2F;调用box.move &#x3D; 100;\n熔断逻辑Express.js 版本弃用一些旧版本的中间件，为了让用户能够更好地发现，有下面这段代码，通过修改get属性方法，让用户调用废弃属性时抛错并带上自定义的错误信息。[  &#39;json&#39;,  &#39;urlencoded&#39;,  &#39;bodyParser&#39;,  &#x2F;* 此处省略很多包名 **&#x2F;].forEach(function (name) &#123;  Object.defineProperty(exports, name, &#123;    get: function () &#123;      throw new Error(&#39;Most middleware (like &#39; + name + &#39;) is no longer bundled with Express and must be installed separately. Please see https:&#x2F;&#x2F;github.com&#x2F;senchalabs&#x2F;connect#middleware.&#39;);    &#125;,    configurable: true  &#125;);&#125;);参考原文：关于Object的getter和setter &#160;&#160;不会Object.defineProperty你就out了\n\n","categories":["前端技术"],"tags":["javascript"]},{"title":"作用域链","url":"/qqsnote/2018/12/27/jsScopeChain/","content":"基本概念\n作用域\n词法作用域\n函数级作用域和块级作用域\n作用域提升\n作用域闭包\n\n作用域简单地理解就是变量的可访问范围，词法作用域也称静态作用域，强调编码决定作用域范围而与运行时无关，js使用的是词法作用域\n函数级作用域指函数内定义的变量在函数体范围内有效\nlet const具备块级作用域，通常是大括号的范围\nvar在运行时具有声明提前的作用，但不会突破函数级作用域或者块级作用域\n题目1function t1()&#123;    console.log(str1);    console.log(str2);    var str1=&quot;xx1&quot;;    str2=&quot;xx2&quot;&#125;\n调用t1();输出\nundefinedUncaught ReferenceError: str2 is not defined\n关键字var提示js编译器词法分析对变量进行声明，没有该关键字，分析认为是单纯赋值操作；执行时自上而下，输出str1时未赋值，其值为undefined，而str2为未声明。\n题目2var i=10;function t2()&#123;    i=20;    for(var i=0;i&lt;6;i++)&#123;    &#125;    console.log(this.i);&#125;\n调用t2()输出10。this指向window对象\n题目3关于闭包闭包的作用和垃圾回收\n","categories":["前端技术"],"tags":["javascript"]},{"title":"JavaScript MDN","url":"/qqsnote/2021/04/25/jsMDN/","content":"replace常规用法str.replace(&#39;_&#39;,&#39;&#39;)str.replace(&#x2F;[^0-9a-zA-Z]&#x2F;g,&quot;&quot;);指定函数作为参数即第二个参数为函数见于hexo源码 /node_modules/hexo/lib/hexo/post.js line 42, line 25restoreCodeBlocks(str) &#123;    return str.replace(rCodeBlockPlaceHolder, _restoreContent(this.cache));&#125;const _restoreContent &#x3D; cache &#x3D;&gt; (_, index) &#x3D;&gt; &#123;  assert(cache[index]);  const value &#x3D; cache[index];  cache[index] &#x3D; null;  return value;&#125;;rCodeBlockPlaceHolder是一串正则表达式，replace对str中符合正则表达式的结果(即str.match(rCodeBlockPlaceHolder))应用参数二方法，方法执行结果替换相应的字符串值得注意的是，_restoreContent(this.cache)返回一个带迭代的方法，index对应str.match(rCodeBlockPlaceHolder)的次序\n","categories":["前端技术"],"tags":["javascript"]},{"title":"原型和面向对象","url":"/qqsnote/2018/12/25/jsprototype/","content":"创建对象1 工厂方式function createPerson(name, age, job)&#123;     var o &#x3D; new Object(); o.name &#x3D; name; o.age &#x3D; age; o.job &#x3D; job;    o.sayName &#x3D; function()&#123;         alert(this.name);        &#125;;    return o; &#125;var person1 &#x3D; createPerson(&quot;Nicholas&quot;, 29&quot;Software Engineer&quot;);var person2 &#x3D; createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n工厂模式虽然解决了创建 多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）\n2构造方法function Person(name, age, job)&#123;     this.name &#x3D; name; this.age &#x3D; age;     this.job &#x3D; job;    this.sayName &#x3D; function()&#123; alert(this.name);&#125;; &#125;var person1 &#x3D; new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);var person2 &#x3D; new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n构造的对象属于同一类型alert(person1.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;true alert(person2.constructor &#x3D;&#x3D; Person); &#x2F;&#x2F;truealert(person1 instanceof Object); &#x2F;&#x2F;true alert(person1 instanceof Person); &#x2F;&#x2F;true alert(person2 instanceof Object); &#x2F;&#x2F;truealert(person2 instanceof Person); &#x2F;&#x2F;true其实有这么一个问题：不同实例上的同名函数是不相等的即person1.sayName == person2.sayName为false\n3原型方式function Person()&#123; &#125;Person.prototype.name &#x3D; &quot;Nicholas&quot;; Person.prototype.age &#x3D; 29;Person.prototype.job &#x3D; &quot;Software Engineer&quot;; Person.prototype.sayName &#x3D; function()&#123; alert(this.name);&#125;;var person1 &#x3D; new Person(); person1.sayName();var person2 &#x3D; new Person(); person2.sayName();\n所有对象可以通过引用Person.prototype属性，从而实现共享属性和方法\n原型对象，对象属性和原型属性无论什么时候，只要创建了一个新函数（如上文Person），就会根据一组特定的规则为该函数创建一个原型对象prototype，在默认情况下，所有原型对象都会自动获得一个 constructor，该构造方法指向 prototype 属性所在函数（即Person.prototype.constructor=Person）。通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（__proto__,注，ECMA-262第5版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持属性 proto ；而在其他实现中，这个属性对脚本则是完全不可见的），指向构造函数的原型对象（即person1.__proto__=Person.prototype）。\n![prototype](https://upload-images.jianshu.io/upload_images/3140250-a75fde4f80938b58.PNG \"prototype\")在无法访问[[Prototype]]的情形下（QQs尚未接触到不支持__proto__的环境），可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系，有Person.prototype.isPrototypeOf(person1)返回true,另ES5提供Object.getPrototypeOf，有Object.getPrototypeOf(person1) == Person.prototype为true。\n代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先 从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到， 则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这 个属性，则返回该属性的值。也就是说，在我们调用 person1.sayName()的时候，会先后执行两次搜 索。首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。”然后，它继续搜索，再 问：“person1 的原型有 sayName 属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。\n可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们 在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。而delete对象实例的这个属性，会重新暴露原型对象的属性Person.prototype.name &#x3D; &quot;Nicholas&quot;;var person1 &#x3D; new Person(); person1.name &#x3D; &quot;Greg&quot;; alert(person1.name); &#x2F;&#x2F;&quot;Greg&quot;——来自实例 delete person1.name; alert(person1.name);&#x2F;&#x2F;&quot;Nicholas&quot;——来自原型使用hasOwnProperty()方法可以检测一个属性是存在于实例中(true)，还是存在于原型中(false)。检测属性（无论实例属性或是原型属性）是否存在可以用in，即”name” in person1返回true。\n从in说到for in，遍历所有能够通过对象访问的、可枚举的（enumerated）属性，其中 既包括存在于实例中的属性，也包括存在于原型中的属性。“可枚举”相当于”可以出现在对象属性的遍历中”，在数组上使用for in遍历，不仅会包含所有数值索引，还会包含所有可枚举属性，。最好只在对象上应用 for in 循环，如果要遍历数组就使用传统的 for 循环来遍历数值索引Object.propertyIsEnumerable()方法可以检查给定属性名是否直接存在于实例中且enumerable = true不可枚举属性，即将 [[Enumerable]]标记为 false 的属性，而屏蔽不可枚举属性的实例属性也会遍历到。Object.keys()返回所有可枚举属性的字符串数组。Object.getOwnPropertyNames()返回所有属性的数组，无论是否可以枚举\n更多创建对象姿势动态原型模式function Person(name, age, job)&#123; &#x2F;&#x2F;属性    this.name &#x3D; name; this.age &#x3D; age;    this.job &#x3D; job;    if (typeof this.sayName !&#x3D; &quot;function&quot;)&#123;            Person.prototype.sayName &#x3D; function()&#123;             alert(this.name);        &#125;;     &#125;&#125;\n原型对象方法sayName在第一次调用构造方法Person时执行。\n寄生构造方法模式function Person(name, age, job)&#123;     var o &#x3D; new Object();     o.name &#x3D; name;     o.age &#x3D; age;     o.job &#x3D; job;    o.sayName &#x3D; function()&#123;         alert(this.name);    &#125;;     return o; &#125;var friend &#x3D; new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\n注意这种方式不能依赖 instanceof 操作符来确定对象类型\n稳妥构造函数模式function Person(name, age, job)&#123; &#x2F;&#x2F;创建要返回的对象    var o &#x3D; new Object();    &#x2F;&#x2F;可以在这里定义私有变量和函数     &#x2F;&#x2F;添加方法    o.sayName &#x3D; function()&#123;         alert(name);    &#125;;    &#x2F;&#x2F;返回对象     return o;&#125;var friend &#x3D; Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;); friend.sayName(); &#x2F;&#x2F;&quot;Nicholas&quot;\n对象实例只能调用闭包内函数以返回name，而无法直接访问任何属性\n原型链和继承原型链假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。function SuperType()&#123;     this.property &#x3D; true;&#125;SuperType.prototype.getSuperValue &#x3D; function()&#123;     return this.property;&#125;;function SubType()&#123; &#125;SubType.prototype &#x3D; new SuperType();&#x2F;&#x2F;继承了 SuperType SubType.prototype.getSubValue &#x3D; function ()&#123;     return this.subproperty;&#125;;var instance &#x3D; new SubType(); alert(instance.getSuperValue());&#x2F;&#x2F;trueSubType 继承了 SuperType。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于基类型的实例中的所有属性和方法，现在也存在于衍生类原型对象中了。注意，所有引用类型的对象都继承了Object，这个继承也是通过原型链实现的。\n![inherit](https://upload-images.jianshu.io/upload_images/3140250-998e96f2cdff75a3.PNG \"inherit\")两个问题缺点：父类包含的引用类型属性，随实例共享到子类的所有实例，这可能并不是我们期望的；子类原型引用的是父类实例，不能向超类型的构造函数中传递参数（在ES6中可以在子类constructor中通过超类型super调用父类方法）。子类原型对象的constructor指向父类构造方法\n借用构造方法constructor stealingfunction SuperType()&#123;     this.colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; &#125;function SubType()&#123;     &#x2F;&#x2F;继承了 SuperType     SuperType.call(this);&#125;var instance1 &#x3D; new SubType(); instance1.colors.push(&quot;black&quot;); alert(instance1.colors);&#x2F;&#x2F;&quot;red,blue,green,black&quot;var instance2 &#x3D; new SubType(); alert(instance2.colors);&#x2F;&#x2F;&quot;red,blue,green&quot;\n传参function SuperType(name)&#123;     this.name &#x3D; name;&#125;function SubType()&#123;     SuperType.call(this, &quot;Nicholas&quot;);&#x2F;&#x2F;调用SuperType构造方法    this.age &#x3D; 29; &#x2F;&#x2F;实例属性 &#125;var instance &#x3D; new SubType(); alert(instance.name); &#x2F;&#x2F;&quot;Nicholas&quot;;alert(instance.age);&#x2F;&#x2F;29无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的。\n组合构造function SuperType(name)&#123;     this.colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];     this.name&#x3D;name;&#125;SuperType.prototype.sayName&#x3D;function()&#123;alert(this.name)&#125;;function SubType(name,age)&#123;     &#x2F;&#x2F;继承了 SuperType     SuperType.call(this,name);    this.age&#x3D;age;&#125;SubType.prototype&#x3D;new SuperType();SubType.prototype.constructor&#x3D;SubType;&#x2F;&#x2F; 注@SubType.prototype.sayAge&#x3D;function()&#123;alert(this.age)&#125;;var instance1 &#x3D; new SubType(); instance1.colors.push(&quot;black&quot;); alert(instance1.colors);&#x2F;&#x2F;&quot;red,blue,green,black&quot;var instance2 &#x3D; new SubType(); alert(instance2.colors);&#x2F;&#x2F;&quot;red,blue,green&quot;\n在注@这一行，将原型对象的构造方法指向到SubType，因为之前该对象根据继承关系图示，作为SuperType实例，其[[prototype]]指向SuperType.prototype，故而SubType.prototype.constructor原先为SuperType方法。\n组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof 和 isPrototypeOf()也能够用于识别基于组合继承创建的对象。\n原型式继承浅复制方法function object(o)&#123;     function F()&#123;&#125;    F.prototype &#x3D; o;     return new F();&#125;关于ES5 Object.create();\n操作符instanceOffunction instance_of(L, R) &#123;&#x2F;&#x2F;L 表示左表达式，R 表示右表达式 var O &#x3D; R.prototype;&#x2F;&#x2F; 取 R 的显示原型 L &#x3D; L.__proto__;&#x2F;&#x2F; 取 L 的隐式原型 while (true) &#123;    if (L &#x3D;&#x3D;&#x3D; null)      return false;    if (O &#x3D;&#x3D;&#x3D; L)&#x2F;&#x2F; 这里重点：当 O 严格等于 L 时，返回 true      return true;    L &#x3D; L.__proto__;  &#125; &#125;\n","categories":["前端技术"],"tags":["javascript"]},{"title":"js线程和多线程js——worker.js","url":"/qqsnote/2019/01/16/jsthread/","content":"多线程 worker.js\n同源限制： worker线程运行的脚本 必须与主线程脚本文件同源(QQs按：这里应该指的是同域)\n无法访问dom 不能调用阻塞主线程的alert confirm等\n通过postmessage/onmessage与主线程通讯\n无法访问文件系统file：// Worker可用的Web Api\n\n单线程和事件循环js是单线程的 但是‘同时’能做很多事情 如js逻辑执行不影响交互事件的响应，可以设置定时器而不是阻塞在等待时间上\n我们可以将整个事件循环机制拆解为几个核心部分来理解：\n1. 核心组件\n\n调用栈：一个后进先出的数据结构，用于追踪当前正在执行的函数。所有同步代码都在这里执行。\n堆：用于存储对象、数组等非结构化数据的内存区域。\nWeb APIs (或 Node.js APIs)：由浏览器或 Node.js 环境提供的线程，用于处理异步操作（如 setTimeout、DOM 事件、网络请求）。它们不属于 JS 引擎本身。\n任务队列：这是一个总称，它至少包含两种不同优先级的队列：\nMacrotask Queue (宏任务队列)：有时也被称为 Task Queue 或 Callback Queue。这是我们通常所说的“事件队列”。\n来源：setTimeout、setInterval、I/O (如文件读取、网络请求 fetch)、UI 渲染、DOM 事件（如点击、键盘事件）。\n\n\nMicrotask Queue (微任务队列)：一个优先级更高的队列。\n来源：Promise.then() / Promise.catch() / Promise.finally()、queueMicrotask()、MutationObserver。2. 事件循环的运行规则\n\n\n\n\n\n第一步：执行同步代码\n\nJS 引擎从全局代码开始执行，将所有同步函数调用压入 调用栈 中，依次执行。\n在执行过程中，如果遇到异步操作（如 setTimeout、Promise.resolve().then()），JS 引擎会将其交给 Web APIs 处理，然后立即继续执行调用栈中的下一条同步代码，不会等待。\n\n第二步：Web APIs 处理异步任务\n\nWeb APIs 在后台执行相应的操作。例如：\nsetTimeout 会启动一个计时器。\nfetch 会发起网络请求。\n\n\n当异步操作完成时（例如，计时器到期、网络数据返回），Web APIs 不会立即将回调函数放入任务队列。它会将对应的回调函数推入到相应的任务队列中。\nsetTimeout 的回调进入 Macrotask Queue。\nPromise.then() 的回调进入 Microtask Queue。\n\n\n\n第三步：主线程空闲，开始事件循环\n\n当 调用栈 为空时（意味着所有同步代码都已执行完毕），事件循环 开始工作。\n\n第四步：执行 Microtask Queue（关键！）\n\n事件循环会首先检查 Microtask Queue。\n如果 Microtask Queue 中有任务，事件循环会一次性执行完所有存在的微任务，直到微任务队列为空。\n在执行微任务的过程中，如果产生了新的微任务，它们会被添加到微任务队列的末尾，并在当前循环中被继续执行。这可能导致微任务的无限循环（需谨慎）。\n只有当 Microtask Queue 完全清空后，事件循环才会进行下一步。\n\n第五步：执行 Macrotask Queue\n\n事件循环检查 Macrotask Queue。\n如果 Macrotask Queue 中有任务，事件循环会只取出队列中的第一个任务，将其放入调用栈中执行。\n注意：每次循环只执行一个宏任务。\n\n第六步：循环往复\n\n当这一个宏任务执行完毕，调用栈再次为空。事件循环会重新回到第四步，再次检查并清空 Microtask Queue。\n这个“执行一个宏任务 -&gt; 执行所有微任务”的循环会不断重复，构成了完整的事件循环。\n\n总结核心要点修正：\n\n不是两个队列，而是至少两个（宏任务和微任务）。\n微任务队列优先级远高于宏任务队列。\n每次事件循环只执行一个宏任务，但会执行所有可用的微任务。\nPromise.then 等产生微任务，setTimeout 等产生宏任务。代码示例验证：console.log(&#x27;1. 同步代码开始&#x27;);setTimeout(() =&gt; &#123;  console.log(&#x27;4. 宏任务: setTimeout&#x27;);&#125;, 0);Promise.resolve().then(() =&gt; &#123;  console.log(&#x27;2. 微任务: Promise.then 1&#x27;);&#125;).then(() =&gt; &#123;  console.log(&#x27;3. 微任务: Promise.then 2&#x27;);&#125;);console.log(&#x27;1. 同步代码结束&#x27;);\n执行顺序分析：\n同步代码：console.log(&#39;1. 同步代码开始&#39;) 和 console.log(&#39;1. 同步代码结束&#39;) 执行。输出 1. 同步代码开始 和 1. 同步代码结束。\n遇到异步：\nsetTimeout 交给 Web APIs，其回调被推入 Macrotask Queue。\nPromise.resolve().then() 的两个回调被推入 Microtask Queue。\n\n\n调用栈为空，事件循环开始：\n检查 Microtask Queue：发现有两个微任务。\n执行第一个：console.log(&#39;2. 微任务: Promise.then 1&#39;)。输出 2。\n执行第二个：console.log(&#39;3. 微任务: Promise.then 2&#39;)。输出 3。\nMicrotask Queue 现在为空。\n\n\n检查 Macrotask Queue：\n发现一个宏任务 (setTimeout 的回调)。\n取出并执行：console.log(&#39;4. 宏任务: setTimeout&#39;)。输出 4。\n\n\n本次循环结束，等待下一次循环。最终输出：1. 同步代码开始1. 同步代码结束2. 微任务: Promise.then 13. 微任务: Promise.then 24. 宏任务: setTimeout\n这个结果清晰地展示了微任务在当前宏任务结束后、下一个宏任务开始前被全部执行的特性。\n\n与typescript集成定义一个common module&#x2F;&#x2F; worker-loader.d.tsdeclare module &quot;worker-loader!*&quot; &#123;    class WebpackWorker extends Worker &#123;        constructor();    &#125;    export default WebpackWorker;&#125;worker&#x2F;&#x2F; MyWorker.tsconst worker :Worker &#x3D; self as any;worker.postMessage(&#123; foo: &quot;foo&quot;&#125;);worker.addEventListener(&quot;message&quot;, (event)&#x3D;&gt;console.log(evnet));调用worker&#x2F;&#x2F; index.tsimport Worker from &quot;worker-loader!.&#x2F;Worker&quot;;const worker &#x3D; new Worker();worker.postMessage(&#123; a: 1 &#125;);worker.onmessage &#x3D; (event) &#x3D;&gt; &#123;&#125;;worker.addEventListener(&quot;message&quot;, (event) &#x3D;&gt; &#123;&#125;)\n","categories":["前端技术"],"tags":["javascript"]},{"title":"login","url":"/qqsnote/2019/11/27/login/","content":"在ng-alain脚手架项目中，默认存token到localstorage（也可以配置为其他存储类型），运行期间不再改动配置。\n\n不应该把 Remember me 当作实际授权有效期的条件，Token 该什么时候过期就应该什么时候过期， Remember me 一般是用于支持自动无感刷新 Token。\n\nredis value中存token，expire time，remember，当remember为false，应校验前端传来的token并核对expire time，当remember为true，应在token过期时自动刷新，并将新的token保存到前端\n","categories":["协议和规范"],"tags":["login"]},{"title":"JWT","url":"/qqsnote/2020/10/15/jwt/","content":"解析JWT token —&gt;  jwt.io\n\nJSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. \n\n“紧凑地、自包含地形式” 自包含即中间部分包含部分用户信息\n通过JSON形式作为web应用中的令牌，用于在各方之间安全地传输信息\n\n\n结构：以.分隔地三个部分：标头header，载荷payload，签名signature 三部分均以base64编码\n标头：如下的编码描述&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;载荷：可以放user profile中的非敏感信息签名：将前两部分信息连同加密salt使用密钥加密生成签名，如HMACSHA256(base64UrlEncode(header)+’.’+base64UrlEncode(payload).secret)\n解析后的json形如&#123;  &quot;iss&quot;: &quot;https:&#x2F;&#x2F;csdentaldevb2c.b2clogin.com&#x2F;ea520207-3fcd-4afc-9b75-90139cd87407&#x2F;v2.0&#x2F;&quot;,  &quot;exp&quot;: 1632306604,  &quot;nbf&quot;: 1632303004,  &quot;aud&quot;: &quot;5d91d9f1-d3f0-44bb-93ab-1db127a11b35&quot;,  &quot;idp&quot;: &quot;LocalAccount&quot;,  &quot;oid&quot;: &quot;ae0dff61-7c3d-460e-87ad-f2567dd17b6f&quot;,  &quot;sub&quot;: &quot;ae0dff61-7c3d-460e-87ad-f2567dd17b6f&quot;,  &quot;emails&quot;: [    &quot;csdealer@yopmail.com&quot;  ],  &quot;tfp&quot;: &quot;B2C_1_CloudFx-ROPC&quot;,  &quot;scp&quot;: &quot;User.Standard&quot;,  &quot;azp&quot;: &quot;23ed21b8-c34d-4319-896e-0ced35ea6701&quot;,  &quot;ver&quot;: &quot;1.0&quot;,  &quot;iat&quot;: 1632303004&#125;json中的这些属性成为claim\n\niss 即issuer 令牌的发布服务\nexp 即expiration time 有效期 \nnbf 即not valid before 生效期\naud 即audience 令牌的接受者，或者受众\n\n","categories":["协议和规范"],"tags":["认证&授权"]},{"title":"loopback","url":"/qqsnote/2019/07/24/loopback/","content":"LoopBack 是一个可扩展的开源Node.js 框架。它可以让我们\n\n无需写任何代码(或少量的代码)来创建REST API\n访问任意数据库中的数据甚至是外部的REST API\n可以在API上定义关系型数据模型和访问限制(ACL)\n在移动APP中使用地理位置，文件访问和推送消息\n提供 Android, iOS 和 JavaScript SDKs快速创建有数据支持的应用程序\n方便的应用部署，无论在云上还是自己的服务器\n\nnpm install -g @loopback&#x2F;cli\nlb4 app","categories":["前端技术"],"tags":["loopback"]},{"title":"matplotlib","url":"/qqsnote/2022/09/01/matplotlib/","content":"正态分布拟合\n","tags":["OpenCV"]},{"title":"ngrok","url":"/qqsnote/2025/11/01/ngrok/","content":"公众号内网穿透方案\n","categories":["工具"],"tags":["ngrok","内网穿透"]},{"title":"node-ffi","url":"/qqsnote/2020/04/16/node-ffi/","content":"node-ffi (Node.js Foreign Function Interface)\ninstall:npm i ffi如果install的ffi有问题，可以拉source下来编译compile:npm i -g node-gypgit clone git:&#x2F;&#x2F;github.com&#x2F;node-ffi&#x2F;node-ffi.gitcd node-ffinode-gyp rebuildNode FFI Tutorial\n\nnode-ffi 停止更新当前不支持最新版本node.js，事实上 经QQs实践基于node10的electron6无法与之集成构建，Github上有替代方案 node-ffi-napi\n\n"},{"title":"Monorepo","url":"/qqsnote/2025/10/15/monorepo/","content":"","tags":["Monorepo"]},{"title":"node.js stream","url":"/qqsnote/2021/02/05/node-stream/","content":"Node.js Streams: Everything you need to know(译文)\n在 Node.js 中有四种基本的流类型：Readable（可读流），Writable（可写流），Duplex（双向流），Transform（转换流）。\n\n可读流是数据可以被消费的源的抽象。一个例子就是 fs.createReadStream 方法。\n可写流是数据可以被写入目标的抽象。一个例子就是 fs.createWriteStream 方法。\n双向流即是可读的也是可写的。一个例子是 TCP socket。\n转换流是基于双向流的，可以在读或者写的时候被用来更改或者转换数据。一个例子是 zlib.createGzip 使用 gzip 算法压缩数据。你可以将转换流想象成一个函数，它的输入是可写流，输出是可读流。你或许也听过将转换流成为“通过流（through streams）”。\n\n所有的流都是 EventEmitter 的实例。触发它们的事件可以读或者写入数据，然而，我们可以使用 pipe 方法消费流的数据。\n从流到流"},{"title":"npm","url":"/qqsnote/2020/04/27/npm/","content":"npm lsnpm prune 清理无关packagenpm i —prefixissue: npm ERR! Error: EPERM: operation not permitted, renameuse ‘npm cache clean’npm install fails on Windows: “Error: EPERM: operation not permitted, rename” #10826\n\n疑杀毒软件问题\n\nnpxnpx是npm的命令，创建React App时使用了如下命令npx create-react-app my-appnpm 用于包管理（安装、卸载、调用已安装的包blabla），npx在此基础上提高使用包的体验，实际上，调用上述命令时，npm依次查找create-react-app的依赖，无法找到则从网络安装，随后调用创建项目，并在包命令执行结束后删除。\nnpm link用软链接共享node_modules须知node_modules使用Portable的方式管理依赖，规避了依赖树上的版本冲突，见 知乎：每个项目文件夹下都需要有node_modules吗？mklink &#x2F;d D:\\project\\B\\node_modules D:\\project\\A\\node_modules\n源npm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install \n设置npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org\npnpm为什么现在我更推荐 pnpm 而不是 npm/yarn?\nBilibili npm yarn pnpm的区别\nnpm 早期版本 递归安装依赖 会产生重复下载 依赖包深度嵌套的问题 现代版本中引入了扁平化管理 遗留问题：串行安装速度慢 每个项目都安装庞大的node_modules\nyarn 并行安装 因不适用项目下node_modules 很多代码提示/补全工具可能失明 \npnpm 提供极致的磁盘空间效率 特定的依赖包版本在磁盘上只会保存一份(pnpm store); 硬链接 + 软连接\n","categories":["工具"],"tags":["npm"]},{"title":"oidc-client package","url":"/qqsnote/2020/11/20/oidc-client/","content":"包如其名，是对openID connection协议的实现\n包主要提供基于两个class的功能，UserManager和OidcClient。UserManager提供登录/登出，管理OIDC provider返回的用户信息（user claims），管理access token等，是oidc-client package的主要功能。OidcClient是更底层的协议实现，并被UserManager调用。\nUserManager初始化UserManager使用OIDC provider的相关配置进行初始化readonly setting &#x3D; &#123;    client_id: &quot;c5a333eb-fbbd-4643-b8fb-846e0c82ca03&quot;, &#x2F;&#x2F; Required！    authority: &quot;https:&#x2F;&#x2F;qqstudio.b2clogin.cn&#x2F;qqstudio.onmicrosoft.com&#x2F;B2C_1_pp_userflow&#x2F;v2.0&#x2F;&quot;, &#x2F;&#x2F; 即&#123;tenant&#125;&#x2F;&#123;directory&#125;&#123;userflow&#125; Required！      response_type: &quot;id_token token&quot;, &#x2F;&#x2F; string, default: &#39;id_token&#39; Required！    scope: &quot;openid&quot; &#x2F;&#x2F; Required！OIDC provider授权的scope    redirect_uri: &quot;https:&#x2F;&#x2F;localhost:44362&#x2F;signin-callback.html&quot;, &#x2F;&#x2F; 返回的token将被链在这个url后面 Required！    silent_redirect_uri: &quot;https:&#x2F;&#x2F;localhost:44362&#x2F;silent-callback.html&quot;,    automaticSilentRenew: true&#125;var _userManager &#x3D; new UserManager(settings);其他参数见oidc-client wiki\n跳转到登录当access_token缺失或过期，抑或由api发现失效而返回401时，可以调用UserManager的下述方法跳转到登录this._userManager.signinRedirect(&#123; state: location.href, prompt: &quot;login&quot; &#125;).then(function () &#123;    console.log(&#39;signinRedirect done&#39;);&#125;).catch(function (err) &#123;    console.log(err);&#125;);方法支持传键值对作为参数，这些参数将拼接在登录地址的url parameter中形如&amp;prompt=login，登录成功重定向回到app时可以取回这些参数，从而继续被登录中断的操作。\n重定向回到App在signin-callback.html页面的初始化方法中调用userManager的signinRedirectCallback，该方法从url的parameter取出access token以及前文所述的其他登录跳转参数（这些参数可以用回调函数取出处理）this._userManager.signinRedirectCallback((user: User) &#x3D;&gt; &#123;    if (user &amp;&amp; user.state) &#123;    this.router.navigateByUrl(user.state).then(b &#x3D;&gt; &#123;        console.log(&quot;navigate to url&quot;, user.state, &quot; return&quot;, b);    &#125;)    &#125;&#125;);实际上callback url后带的是形如&amp;state=b2983fd692b94528852297782ef93bbf的参数，推测此为指向原value的标记，原value存于localstorage\nUser调用getUser方法取用户信息, 部分信息是从access token中解析得出，部分可能需要配置其他workflow比如profileclass User &#123;  constructor(settings: UserSettings);  &#x2F;** The id_token returned from the OIDC provider *&#x2F;  id_token: string;  &#x2F;** The session state value returned from the OIDC provider (opaque) *&#x2F;  session_state?: string;  &#x2F;** The access token returned from the OIDC provider. *&#x2F;  access_token: string;  &#x2F;** Refresh token returned from the OIDC provider (if requested) *&#x2F;  refresh_token?: string;  &#x2F;** The token_type returned from the OIDC provider *&#x2F;  token_type: string;  &#x2F;** The scope returned from the OIDC provider *&#x2F;  scope: string;  &#x2F;** The claims represented by a combination of the id_token and the user info endpoint *&#x2F;  profile: Profile;  &#x2F;** The expires at returned from the OIDC provider *&#x2F;  expires_at: number;  &#x2F;** The custom state transferred in the last signin *&#x2F;  state: any;  toStorageString(): string;  static fromStorageString(storageString: string): User;  &#x2F;** Calculated number of seconds the access token has remaining *&#x2F;  readonly expires_in: number;  &#x2F;** Calculated value indicating if the access token is expired *&#x2F;  readonly expired: boolean;  &#x2F;** Array representing the parsed values from the scope *&#x2F;  readonly scopes: string[];&#125;调用removeUser 清除localstorage中的登录信息 非常的方便~\n","tags":["认证&授权"]},{"title":"Node.js运行时环境","url":"/qqsnote/2024/04/11/nodejs-runtime/","content":"Node.js 是一个开源的、跨平台的 JavaScript 运行时环境。\n所谓运行时runtime，是指程序声明周期中从开始执行到完成退出的阶段，除了运行时，还时有提及的编译阶段是 compile time，链接阶段是 link time，在前面的阶段预先做了通常在后面才方便做的事叫 ahead of time\nNode.js 是一个异步事件驱动运行时 (asynchronous event-driven JavaScript runtime) 与\n"},{"title":"Learn OpenGL","url":"/qqsnote/2025/08/09/openGL-learnopengl/","content":"OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。\n切换到绘制线段/图形 —&gt; 绘制参数 —&gt; 更新\nGLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。如创建窗口、处理输入（如键盘、鼠标、游戏手柄）以及管理 OpenGL 上下文，GLFW是开发 OpenGL 应用程序的常用工具之一\nGLFW window hint 枚举\n","categories":["图形学"],"tags":["OpenGL"]},{"title":"Three.js WebGL OpenGL","url":"/qqsnote/2019/09/02/openGL/","content":"OpenGL官方：Learn OpenGL中文：LearnOpenGL CN\n\n事实上OpenGL本身并不是一个API，它仅仅是一个由Khronos组织制定并维护的规范(Specification)\n\n该规范严格规定了每个函数如何执行，以及他们的输出。至于内部具体实现由OpenGL库的开发者自行决定。实际的OpenGL库的开发者通常是显卡的生产商。你购买的显卡所支持的OpenGL版本都为这个系列的显卡专门开发的,因此OpenGL版本的bug通常以升级显卡驱动的方式修复。\n\nOpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。\nOpenGL ES裁剪后的嵌入式设备版本 \n\n完全的可编程管线技术\nWebGL\nWebGL 是一种 3D 绘图标准，这种绘图技术标准允许把 JavaScript 和 OpenGL ES 2.0 结合在一起，通过增加 OpenGL ES 2.0 的一个 JavaScript 绑定，WebGL 可以为 HTML5 Canvas 提供硬件 3D 加速渲染，这样 Web 开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了\nWebGL 的出现使得在浏览器上面实时显示 3D 图像成为，WebGL 本质上是基于光栅化的 API ,而不是基于 3D 的 API。\n\nwebGL是比canvas.getContext(‘2d’)更加底层的图形绘制接口。而它的工作原理，实际上就是遍历每一个像素点，然后给各个像素点填充颜色，然后才构成一幅2d或者3d的图像。\nWebGL的实现是基于HTMLCanvasElement的。\n什么是光栅化WebGL重建三维图像的步骤大致包括\n\n获取顶点坐标\n图元装备 顶点之间存在关系，直观体现为由三个顶点构成一个三角形，称为图元\n光栅化 将图元进一步具象填充，生成片元\n\n光栅化（Rasterization）是把顶点数据转换为片元的过程，把物体的数学描述以及与物体相关的颜色信息转换为屏幕上用于对应位置的像素及用于填充像素的颜色\n着色器webGL工作的基本单位是着色器（shaders）。着色器编程使用glsl语言，运行在显卡中，webgl标准使用js拼装着色器代码，编译成二进制包并塞入显卡执行\n着色器如同笔刷 由顶点着色器决定绘制在哪里 由片元着色器决定用什么笔触/颜色等要素填充\nThree.jsThree.js对WebGL工作步骤进一步封装，提供方便理解的绘图API以操作WebGL接口\n参考理解 图解WebGL&amp;Three.js工作原理\n关于学习Web3D相关技术的经验介绍：如何学习WebGL和Three.js\nThree.js 支持具有骨骼的动画 see SkinnedMesh\nBabylon.js词义巴比伦，被认为相比于Three.js 更为工程化的web 3d框架 更偏向动画游戏场景而非渲染\nCeicum地理位置坐标库\nEnable WebGL in your browser参考\nAli HiloCUDA\nCUDA is a parallel computing platform and programming model developed by NVIDIA for general computing on its own GPUs\n\nvulkan“次世代OpenGL行动”, Vulkan针对实时3D程序设计，提供高性能和低CPU管理负担\nVulkan是个显式的API，也就是说，几乎所有的事情你都需要亲自负责。驱动程序是一个 软件，用于接收 API调用传递过来的指令和数据，并将它们进行转换，使得硬件可以理解。\nunitywebXRWebGPU随着计算机图形运算能力的提高，实际OpenGL已被vulkan、DirectX等取代，而裁剪过的OpenGL ES更无法发挥现代计算机的渲染能力，为弥补这部分功能欠缺，Khronos Group(OpenGL和vulkan的制定组织)着手开发webgpu，以支持调用GPU的图形渲染功能（实际上是提供api访问vulkan、Metal驱动）\nchrome率先在浏览器层面支持webgpu\nThree.js Babylon.js库逐步对支持访问webgpu做了适配，使用一般不需要学习额外的编程方法\n","categories":["图形学"],"tags":["WebGL"]},{"title":"pillow","url":"/qqsnote/2022/06/27/pillow/","content":"\nPIL（ Python Imaging Library）是 Python 的第三方图像处理库，由于其功能丰富，API 简洁易用，因此深受好评。由于 PIL 库更新缓慢，目前仅支持 Python 2.7 版本，这明显无法满足 Python3 版本的使用需求。于是一群 Python 社区的志愿者（主要贡献者：Alex Clark 和 Contributors）在 PIL 库的基础上开发了一个支持 Python3 版本的图像处理库，它就是 Pillow。\n\nPillow 提供了丰富的图像处理功能，可概括为两个方面：图像归档图像处理图像归档，包括创建缩略图、生成预览图像、图像批量处理等；而图像处理，则包括调整图像大小、裁剪图像、像素点处理、添加滤镜、图像颜色处理等。\nPillow 库可以配合 Python GUI（图形用户界面）工具 Tkinter 一起使用。\n","categories":["图像处理"],"tags":["Python"]},{"title":"pm2","url":"/qqsnote/2020/07/10/pm2/","content":"directivespm2 start index.jspm2 stop allpm2 logspm2 delete all\nenv variables将node.js应用封装成模块ecosystem.config.js （也可以直接用json）module.exports &#x3D; &#123;  apps : [      &#123;        name: &quot;myapp&quot;,        script: &quot;.&#x2F;app.js&quot;,        watch: true,        env: &#123;            &quot;PORT&quot;: 3000,            &quot;NODE_ENV&quot;: &quot;development&quot;        &#125;,        env_production: &#123;            &quot;PORT&quot;: 80,            &quot;NODE_ENV&quot;: &quot;production&quot;,        &#125;      &#125;  ]&#125;在启动命令时使用env_后面的字符串作为标识pm2 start ecosystem.config.js --env production\npm2 plusknow more about pm2.io\n开机自启键入下面的命令生成startup脚本pm2 startup提示执行配置命令,如[PM2] To setup the Startup Script, copy&#x2F;paste &gt;the following command:&quot;, sudo env &gt;PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;bin &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules&#x2F;pm2&#x2F;bin&#x2F;pm2 startup systemd -u username --hp &#x2F;home&#x2F;username按照提示执行提示的命令, 执行后终端列出已安装的服务信息\nCaution！升级nodejs对startup有影响pm2 unstartuppm2 startup\n","tags":["进程守护"]},{"title":"Point to Point Protocal","url":"/qqsnote/2020/01/06/ppp/","content":"概念参考：Android 上网概述\n使用3g/4g/5g网络的移动设备，通过ppp协议与蜂窝网络的基站建立通信\nppp协议是链路层协议\nLinux对PPP数据链路的建立过程进行抽象，实现了pppd拨号应用程序，专门用于管理PPP数据链路的建立与关闭，见下图。pppd是一个后台服务进程(daemon)，实现了所有鉴权、压缩/解压和加密/解密等扩展功能的控制协议，负责把要发送的数据包传递给PPP协议处理模块，设置PPP协议的参数，用来建立/关闭连接。\n\n链路建立的大致过程：\n","categories":["通信协议"],"tags":["4G"]},{"title":"渐进式web开发","url":"/qqsnote/2021/04/16/pwa/","content":"Progressing Web Applicationhttps://create-react-app.dev/docs/making-a-progressive-web-app/https://web.dev/progressive-web-apps/\n渐进式意使是网站根据浏览器的功能相应地呈现，高级的浏览器呈现高级的效果。就目前来看主要表现是对于版本比较高的 chrome，firefox 等浏览器，pwa 可以使用 add to home screen 的功能，使网络应用固定在桌面、移动设备主屏幕，成为独立应用\n脱机使用的渐进式web应用更快速也更可靠，还具备更吸引人的移动端体验，比如在网络不佳的场景下使用，还有添加到主屏幕的功能\n网络应用清单 manifest.json参考PWA manifest 配置&#123;  &quot;short_name&quot;: &quot;MY APP&quot;,  &quot;name&quot;: &quot;MY APP Full Name&quot;,  &quot;icons&quot;: [      &#123;      &quot;src&quot;: &quot;icon&#x2F;lowres.webp&quot;,      &quot;sizes&quot;: &quot;48x48&quot;,      &quot;type&quot;: &quot;image&#x2F;webp&quot;    &#125;,&#123;      &quot;src&quot;: &quot;icon&#x2F;lowres&quot;,      &quot;sizes&quot;: &quot;48x48&quot;    &#125;,&#123;      &quot;src&quot;: &quot;icon&#x2F;hd_hi.ico&quot;,      &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot;    &#125;,&#123;      &quot;src&quot;: &quot;icon&#x2F;hd_hi.svg&quot;,      &quot;sizes&quot;: &quot;257x257&quot;    &#125;  ],  &quot;start_url&quot;: &quot;&#x2F;&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;theme_color&quot;: &quot;#000000&quot;,  &quot;background_color&quot;: &quot;#FFB71B&quot;,  &quot;url&quot;: &quot;&#x2F;&quot;,  &quot;manifestUrl&quot;: &quot;&#x2F;manifest.json&quot;,  &quot;lang&quot;: &quot;en&quot;,  &quot;description&quot;: &quot;blabla&quot;,  &quot;scope&quot;: &quot;.&quot;&#125;manifest的生成可以借助webpack plugin生成\nService Worker\nService Worker 是一直在浏览器后台运行的worker线程，设置其拦截用户的请求（如加载脚本和图片）进而可以改变请求行为，如不访问服务器直接返回， 再如从缓存加载资源 以提升在离线或加载繁重的应用场景\n\n如下注册Service Worker，Service Worker必须由HTTPS协议载入，Service Worker脚本须与网站同域if (&#39;serviceWorker&#39; in navigator) &#123;&#x2F;&#x2F; register service worker navigator.serviceWorker.register(&#39;.&#x2F;sw.js&#39;, &#123;scope: &#39;.&#x2F;&#39;&#125;) &#x2F;&#x2F; 参数1：注册提供的脚本URL 参数2：导航匹配.then(()&#x3D;&gt;&#123;    console.log(&#39;注册成功&#39;)&#125;).catch(()&#x3D;&gt;&#123;    console.log(&#39;注册失败&#39;)&#125;);&#125;\nsw.js\n&#x2F;&#x2F; 缓存静态文件self.addEventListener(&#39;install&#39;, (event) &#x3D;&gt; &#123;    event.waitUntil(caches.open(&#39;myapp&#39;).then((cache) &#x3D;&gt;  cache.addAll([&#39;**&#x2F;*&#39;])));&#125;);&#x2F;&#x2F; 缓存接口数据self.addEventListener(&#39;fetch&#39;, (event) &#x3D;&gt; &#123;    event.respondWith(caches.match(event.request).then((response) &#x3D;&gt; &#123;        &#x2F;&#x2F; 匹配到请求        if (response !&#x3D;&#x3D; undefined) &#123;            return response;        &#125; else &#123;            return fetch(event.request).then((response) &#x3D;&gt; &#123;                &#x2F;&#x2F; 缓存响应数据                let responseClone &#x3D; response.clone();                caches.open(&#39;v1&#39;).then((cache) &#x3D;&gt; &#123;                    cache.put(event.request, responseClone);                &#125;);                return response;            &#125;).catch(() &#x3D;&gt; &#123;                return caches.match(&#39;&#x2F;gallery&#x2F;myLittleVader.jpg&#39;);            &#125;);        &#125;    &#125;));&#125;);&#x2F;&#x2F; 更新缓存self.addEventListener(&#39;activate&#39;, (event) &#x3D;&gt; &#123;    event.waitUntil(        caches.keys().then((cacheNames) &#123;            return Promise.all(                cacheNames.map(function(cacheName) &#123;                    &#x2F;&#x2F; 如果有更新                    if (cacheName !&#x3D;&#x3D; &#39;v1&#39;) &#123;                        return caches.delete(cacheName);                    &#125;                &#125;)            );        &#125;).then(function()&#123;            return self.clients.claim()        &#125;)    );&#125;);\nService Worker生命周期：\n如index.html中 加载应用时即注册service worker，注册成功即触发安装事件(install event)，见sw.js代码，在安装事件的响应中，处理应用缓存\n安装成功后激活service worker触发激活事件(active event)\n激活成功后service worker进入idle状态 在该状态下所有请求会触发fetch event 直到应用关闭\nService Worker的更新：\n触发更新\n\n导航到作用域内页面时\n某事件触发后24h未下载Service Worker\n\n若Service Worker下载后被发现是新文件，无论Service Worker内容是否与现有的相同，都将触发install\n如果是第一次安装Service Worker，如上所述安装成功后触发激活，但对于更新，Service Worker已启用的情形，会等待所有已加载的页面不再依赖旧的Service Worker后，触发激活\n添加到主屏幕（a2hs）使应用支持a2hs:\n\nhttps\n正确配置的manifest.json\n合适的图标\n注册service worker注册service worker是作为a2hs条件的，但是可以a2hs，未必可以离线使用\n\n框架支持react pwanpx create-react-app my-app --template cra-template-pwa\n","tags":["PWA","ServiceWorker"]},{"title":"redis","url":"/qqsnote/2019/04/10/redis/","content":"概念(略)\n方法keys *redis-cli set key valueget keydel keyhget key fieldnamehget allflushall\nredis作为认证token数据库ticket=(accountid, token)\ncentos安装Redis参考：Linux 平台将 Redis 设置为服务并开机自启动\n\n服务部署好之后，若无法远程访问\n首先检查防火墙设置systemctl status firewalld # 查看防火墙状态firewall-cmd --zone&#x3D; public --query-port&#x3D;6379&#x2F;tcp # 查询防火墙端口状态firewall-cmd --zone&#x3D;public --add-port&#x3D;6379&#x2F;tcp --permanent # 永久开发端口及协议确认是否绑定服务主机ip 参考 处理CentOS 7.2 x64端口不通的问题\n远程访问修改/etc/redis/redis.conf# 注释掉或将其改为服务器静态ip# bind 127.0.0.1 ::1\n\nDENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients…..\n\n受保护的模式,改为noprotected-mode no\n","categories":["工具"],"tags":["redis"]},{"title":"SCSS","url":"/qqsnote/2019/01/29/scss/","content":"\nSCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。\n\n将Angular项目样式由css改为scss安装 node-sass sass-loader修改angular.json&quot;styles&quot;: [    &quot;src&#x2F;styles.scss&quot;],&quot;default&quot;: &#123;    &quot;styleExt&quot;:&quot;scss&quot;&#125;,上面的修改也就看看，不做实操指导，新建ng项目时可以选择样式类型，当时选scss便可，免得多事\n\nSCSS嵌套结构样式优先级高于非嵌套结构样式，因此可以用某元素父元素嵌套的写法覆盖该元素样式\n常用新语法map类型$pie:(    width:125px    height:140px)\nwidth:map-get($pie, width)\n@import @mixin定义一个Mixin模块@mixin button&#123;    font-size:1em;    padding:0.5em;    color:#fff&#125;调用.button-green&#123;    @include button;    back-ground:green&#125;\n@extend引用已定义的样式.button-green-mini&#123;    @extend .button-green;    width:2em&#125;\n循环语句创建样式$lvlcolors:(    1:$color-danger    2:$color-orange    3:$color-warning    4:$color-blue)@for $lvl from 1 through 4&#123;    .lvl#&#123;$lvl&#125; &#123;background: map-get($lvlcolors, $lvl)&#125;&#125;\neach：$icons: (&quot;eye&quot;: &quot;\\f112&quot;, &quot;start&quot;: &quot;\\f12e&quot;, &quot;stop&quot;: &quot;\\f12f&quot;);@each $name, $glyph in $icons &#123;  .icon-#&#123;$name&#125;:before &#123;    display: inline-block;    font-family: &quot;Icon Font&quot;;    content: $glyph;  &#125;&#125;issue: scss variables are not working in calc.main &#123;\twidth: 100%;\theight: calc(100% - #&#123;$header-height&#125;);\tbackground: #313030;&#125;伪类 icon$icon:(  add:&quot;%3Csvg%20width%3D%2218%22%20height%3D%2218%22%20viewBox...&quot;,  edit:&quot;%3Csvg%20width%3D%2230%22%20height%3D%2230%22%20viewBox...&quot;,  delete:&quot;%3Csvg%20width%3D%2230%22%20height%3D%2230%22%20viewBox...&quot;,  refresh:&quot;%3Csvg%20width%3D%2230%22%20height%3D%2230%22%20viewBox...&quot;)@each $key, $val in $icon&#123;\t.qqs-design-icon.icon-#&#123;$key&#125;&#123;\t\tposition: relative;\t\tpadding-left: 22px;\t\tmargin-left: 4px;\t\t&amp;::before&#123;\t\t\tcontent: &#39;&#39;;\t\t\tposition: absolute;\t\t\tleft: 0px;\t\t\tbottom: calc(50% - 10px);\t\t\tbackground: url(&quot;data:image&#x2F;svg+xml,&quot; + $val + &quot;&quot;) no-repeat top left;\t\t\twidth: 25px;\t\t\theight: 25px;\t\t&#125;\t&#125;&#125;\n拼接url$sites: (&quot;twitter.com&quot;, &quot;facebook.com&quot;, &quot;linkedin.com&quot;);@each $site in $sites &#123;  a[href*&#x3D;&quot;#&#123;$site&#125;&quot;] &#123;    background-image: url(&quot;&#x2F;images&#x2F;&quot; + $site + &quot;.png&quot;);  &#125;&#125;\n总结一下就是#{}这个符号用于将变量拼接在css选择器上，包括class名，属性名等，在样式的值中，字符串与变量的拼接可以直接用“+”连接\nissuesjenkins build failnpm i -g node-sass以下理解未必完全正确，但包含了若干方面的可能因素，可日后进一步探究（QQs：不太会探究）：jenkins 在打包angular过程中为webpack的sass-loader安装所需包node-sass，但是缺少node-gyp，python等工具链的调用权限，因而build失败，至于npm install为什么会build，electron编译过程中也遇到过，编译对象是package中调用的c++库。对此的解决方案之一是在jenkins所在的物理机上全局安装node-sass，当下的默认版本是5.0.0，曾尝试在项目package.json中将node-sass更新为5.0.0，然而angular9中的sass-loader似乎是支持node-sass^4.0.0，因此出现“Node Sass version 5.0.0 is incompatible with ^4.0.0”的报错，应在全局重装npm i -g node-sass@4\n\n参考node-sass troubleshooting#Running with sudo or as rootstackoverflow:Error: Node Sass version 5.0.0 is incompatible with ^4.0.0node-sass issues#941\nCannot download “https://github.com/sass/node-sass/releases/download/v4.13.1/win32-x64-83_binding.node”package-lock指定了node-sass@4.13.1, 关于node-sass的release版本没有win32-x64-83_binding.node, ‘-83’为node 14的支持模块，而4.13的node-sass不支持node 14，见Node version support policy. 即此问题是由于编译环境升级到node14造成的，解决方法是安装支持node14的4.14+\n参考\n","categories":["前端技术"],"tags":["CSS"]},{"title":"服务升级的用户体验","url":"/qqsnote/2022/07/01/server_maintainance/","content":"系统正在维护中方案一nginx.confserver &#123;    listen 80    server_name localhost    # rewrite ^(.*)$ &#x2F;maintainace_page.html break;&#125;方案二拦截503如何优雅告知用户，网站正在升级维护\n不间断升级维护“蓝绿部署”\n熔断降级","categories":["前端技术"],"tags":["UE"]},{"title":"SQL Server 触发器","url":"/qqsnote/2021/07/13/sqlserver-trigger/","content":"\n触发器是一类存储过程\n由数据表的事件(如insert update delete)触发，而不是手动调用\n\n登录触发器官网例子 场景：如果登录名login_test 已经创建了三个用户会话，触发器将拒绝该用户的登录尝试USE master;  GO  CREATE LOGIN login_test WITH PASSWORD &#x3D; N&#39;3KHJ6dhx(0xVYsdf&#39; MUST_CHANGE,      CHECK_EXPIRATION &#x3D; ON;  GO  GRANT VIEW SERVER STATE TO login_test;  GO  CREATE TRIGGER connection_limit_trigger  ON ALL SERVER WITH EXECUTE AS N&#39;login_test&#39;  FOR LOGON  AS  BEGIN  IF ORIGINAL_LOGIN()&#x3D; N&#39;login_test&#39; AND      (SELECT COUNT(*) FROM sys.dm_exec_sessions              WHERE is_user_process &#x3D; 1 AND                  original_login_name &#x3D; N&#39;login_test&#39;) &gt; 3      ROLLBACK;  END;可知登录触发器在身份认证之后，建立会话之前触发多个触发器的顺序，即支持指定the first和the last 见Microsoft Docs\nDDLdata define language 数据定义语言即在使用会改变数据库数据结构的语句时触发，如CREATE、ALTER、DROP、GRANT、DENY、REVOKE 或 UPDATE STATISTICS 开头的 Transact-SQL 语句场景\n\n防止对数据库架构进行某些更改。\n希望数据库中发生某种情况以响应数据库架构的更改。\n记录数据库架构的更改或事件。DMLdata manipulation language (DML) 数据操作语言  INSERT、UPDATE 或 DELETE 语句after 触发器CREATE TRIGGER schemaA.SyncData    ON  schemaA.TableA   AFTER INSERTAS BEGIN\t-- SET NOCOUNT ON added to prevent extra result sets from\t-- interfering with SELECT statements.    -- Insert statements for trigger here\tinsert into schemaB.TableB(Name,TrustedId,EmailAddress,Logo,Type,Enable,RecordStatus,RecordCreated,RecordLastUpdated)\tselect name,record_pk,email,logo,&#39;1&#39;,0,0,SYSDATETIME(),SYSDATETIME() from schemaA.TableA\tSET NOCOUNT ON;ENDGO\ninstead of 触发器\n\n","categories":["数据库"],"tags":["触发器"]},{"title":"SQL Server","url":"/qqsnote/2020/06/15/sqlserver/","content":"命令sqlcmd -S .\\SqlExpressNET START&#x2F;PAUSE&#x2F;CONTINUE&#x2F;STOP&#x2F; MSSQLSERVER\nQQs未能成功实践。。或者，任务管理器手动启动 MSSQL$SQLEXPRESS \nschema在MySQL中schema的概念和database一致但是微软搞什么都要多加点概念，sqlserver中，表名前带有schema标记如dbo.table1,这里的dbo指数据库的默认用户database owner导出表结构（create table）语句时会带着schemacreate table [ent].[tabletemp](\t[Id] [uniqueidentifier] NOT NULL,\t[Name] [nvarchar](50) NULL,PRIMARY KEY CLUSTERED (\t[Id] ASC)WITH (PAD_INDEX &#x3D; OFF, STATISTICS_NORECOMPUTE &#x3D; OFF, IGNORE_DUP_KEY &#x3D; OFF, ALLOW_ROW_LOCKS &#x3D; ON, ALLOW_PAGE_LOCKS &#x3D; ON) ON [PRIMARY]) ON [PRIMARY]迁移时执行该语句会提示”The specified schema name “env” either does not exist or you do not have permission to use it.”创建schemacreate schema ent变更schemaALTER SCHEMA ent TRANSFER OBJECT::dbo.table1;  \n创建新用户及授权访问参考原文\n\n配置登录名 Database Server —&gt; Security —&gt; Logins —&gt; 右键New Login\n常规General标签页中，配置认证方式等\n服务器角色（Server Roles）添加 public sysadmon\n用户映射（User Mapping）添加创建的新用户\n安全对象（Securable）搜索 —&gt; 选择 The Server(当前数据库服务器名)\n状态默认\n\nServerNamesqlserver实例默认以计算机名+服务提供者命名，如SHAL400/SQLEXPRESS, 甚至用ip代替计算机名都会导致无法连接.配置sqlserver支持远程访问:\n\n从本地SSMS连接数据库，右键服务器—Facets—Server Configuration—RemoteAccessEnable=true\n打开SQL Server Configuration Manager(SSCM) SQL Server Browser Running, \nSSCM—SQL Server Network Configuration—Protocols for SQLEXPRESS—TCP/IP Enable, 然后右键打开Properties设置ip及端口如下（注意IPAll的TCP Dynamic Ports不要写死） \n配置防火墙略\n\n调用存储过程EXEC storedProcedure1 @param&#x3D;&#39;01&#39;\n约束ConstraintCREATE TABLE [dbo].[Group](\t[ID] [uniqueidentifier] NOT NULL,\t[CreateTime] [datetime2](7) NULL,\t[Name] [nvarchar](80) NULL,\t[Valid] [bit] NOT NULL,\t[UpdateTime] [datetime2](7) NULL,\t[Comment] [nvarchar](500) NULL,    CONSTRAINT [AK_Group_Name] UNIQUE ([Name])) ON [PRIMARY]\n关于大小写据说sqlserver 安装过程中有是否区分大小写的选项，默认情况下无论表名、列名、字段、参数都不区分大小写，更过分的是查询条件的值也不区分————where name=’abc’和where name=’AbC’是一样的结果。如果要区分查询条件的大小写，中文网络上建议如下例子，追加条件select * from table1 where name&#x3D;&#39;abc&#39; collate Chinese_PRC_CS_AI_WS Chinese_PRC_CS_AI_WS实际表示中国大陆UNICODE字符集规则（Chinese PRC），区分大小写（Case Sensitive，CS），不区分重音（Accent Insensitive，AI），区分宽度（Width Sensitive，WS，半角/全角字符受此条件影响）类似的还有SQL_Latin1_General_CP1_CS_AILatin1_General_CS_AI查询当前默认规则SELECT SERVERPROPERTY(N&#39;Collation&#39;)查询支持的字符集规则SELECT * from ::fn_helpcollations()\n内置对象的表\nsys.schemas\n\n执行历史\nSELECT TOP 1000 QS.creation_time, SUBSTRING(ST.text, \t\t(QS.statement_start_offset &#x2F; 2) + 1, \t\t((CASE QS.statement_end_offset \t\t\tWHEN - 1 THEN DATALENGTH(st.text) \t\t\tELSE QS.statement_end_offset \t\t\tEND - QS.statement_start_offset) &#x2F; 2) + 1)\t\t\tAS statement_text, \t\tST.text, \t\tQS.total_worker_time, \t\tQS.last_worker_time, \t\tQS.max_worker_time, \t\tQS.min_worker_timeFROM        sys.dm_exec_query_stats QS CROSS APPLY sys.dm_exec_sql_text(QS.sql_handle) STWHERE   1&#x3D;1 \nedit dataSSIS提供了Edit Top 200 Rows,但是写入表格内容各种格式不正确，宜Script Table to…Insert toGuid用NEWID(),时间就用SYSDATETIME()\nSTUFF\n\nSTUFF ( character_expression , start , length , character_expression )\nCAST &amp; CONVERT数据类型转换SELECT CAST(t1.num AS varchar) from t1;SELECT CONVERT(varchar, t1.num) from t1;\n将自然键替换为人工键原实体以序列号为主键，现添加ID列并填充GUIDALTER TABLE dbo.Table1 DROP CONSTRAINT PK_Table1 &#x2F;&#x2F; 移除原主键ALTER TABLE dbo.Table1 DROP COLUMN SerialNumber &#x2F;&#x2F; 移除列ALTER TABLE dbo.Table1 ADD ID uniqueidentifier NOT NULL default newID()\n\nexception The object ‘DFTable1ID__34C8D9D1’ is dependent on column ‘ID’. ALTER TABLE DROP COLUMN failed because one or more objects access this column\n\nID作为列名会默认添加CONSTRAINT，如上所提及的DFTable1ID34C8D9D1 因此要删除这个ID列需要先 ALTER TABLE dbo.Table1 DROP CONSTRAINT DFTable1ID34C8D9D1\n层次结构数据具有父级、子级关系的层次结构数据Oracle的递归查询语法:select  * from t_dw CONNECT BY PRIOR id &#x3D; parentID START WITH id&#x3D;&#39;dw001&#39;SqlServer中没有上述语法，而使用内置hierarchyid简化层次结构数据的存储和查询，\nhttps://www.meziantou.net/using-hierarchyid-with-entity-framework-core.htm\n-- 根节点 &#x2F;update t_dw set orgLvl&#x3D;HierarchyID::GetRoot() where parentID is null-- 子树   &#x2F;1&#x2F;,&#x2F;2&#x2F;update t_dw set orgLvl&#x3D;HierarchyID::Parse(&#39;&#x2F;1&#x2F;&#39;) where name&#x3D;&#39;dw1&#39;update t_dw set orgLvl&#x3D;HierarchyID::Parse(&#39;&#x2F;2&#x2F;&#39;) where name&#x3D;&#39;dw2&#39;-- 叶    &#x2F;1&#x2F;3&#x2F;update t_dw set orgLvl&#x3D;HierarchyID::Parse(&#39;&#x2F;1&#x2F;1&#x2F;&#39;) where name&#x3D;&#39;dw1-a&#39;\n插入insert t_dw (id,name,ParentID,orgLvl) values(newid(),&#39;dw1-b&#39;,&#39;xxxxxxxxxxxxxxx&#39;,HierarchyID::Parse(&#39;&#x2F;1&#x2F;&#39;).GetDescendant(CAST(&#39;&#x2F;1&#x2F;1&#x2F;&#39; AS hierarchyid), NULL))得到/1/2/ dw1-b 即在/1/的子节点，左树为/1/1/右树为null位置插入新节点\n层级SELECT CAST(&#39;&#x2F;1&#x2F;2&#x2F;&#39; AS hierarchyid).GetLevel() -- 结果：2后代SELECT name, orgLvl.ToString()FROM t_dwWHERE orgLvl.IsDescendantOf(CAST(&#39;&#x2F;1&#x2F;&#39; AS hierarchyid)) &#x3D; 1IsDescendant为1(表示true)返回所有后代(实际上也包括‘/1/’自己), 0返回所有非后代（父代，sibling树）SELECT name, orgLvl.ToString()FROM t_dwWHERE orgLvl.GetAncestor(2) &#x3D; HierarchyID::Parse(&#39;&#x2F;1&#x2F;&#39;)GetAncestor返回指定层级的后代，参数为层级：0返回‘/1/’自己；1返回所有子节点，2返回所有孙子节点\n移动DECLARE @CurrentNode hierarchyid , @OldParent hierarchyid, @NewParent hierarchyid select  @CurrentNode&#x3D;orgLvl from t_dw where name&#x3D;&#39;dw_x&#39;; -- &#x2F;1&#x2F;1&#x2F;select  @OldParent&#x3D;orgLvl from t_dw where name&#x3D;&#39;dw_old&#39;; -- &#x2F;1&#x2F;select  @NewParent&#x3D;orgLvl from t_dw where name&#x3D;&#39;dw_new&#39;; -- &#x2F;3&#x2F;UPDATE t_dw  SET OrgNode &#x3D; @CurrentNode.GetReparentedValue(@OldParent, @NewParent)   WHERE OrgNode &#x3D; @CurrentNode ; -- &#x2F;3&#x2F;1&#x2F; GO  其他进阶操作：查找祖先列出祖先)移动子树\n获取每个表的数据条数select schema_name(t.schema_id) as [Schema], t.name as TableName,i.rows as [RowCount] from sys.tables as t, sysindexes as i where t.object_id &#x3D; i.id and i.indid &lt;&#x3D;1\n按rownumber删除; with cte(rownum)as(    select row_number () over(partition by [Col1], [Col2] order by Col3) from [table])delete from cte where rownum &gt; 1\n按Col1 Col2分组删除 保留组唯一\nlogin fail Error 18456CSDN Blog:SQL Server Error 18456\nother issues: Microsoft Docs: Troubleshooting Connect to SQL Server\n查看版本select @@version\n作业和代理某需求欲使用SQL Server的计划进行自动备份，启动SQL Server Agent时账户密码不正确 且该账号登录SSMS没有计划、代理等菜单\nSQL Server Express没有这部分功能\nsqlcmd","categories":["数据库"],"tags":["SQL_Server"]},{"title":"ssh","url":"/qqsnote/2019/10/30/ssh/","content":"ubuntu安装后无法ssh远程登录检查是否安装ssh-serverdpkg -l | grep ssh默认只有ssh-client,如下\n安装命令：sudo apt-get install openssh-server通过进程确认服务已启动ps -e | grep ssh启动与停止sudo &#x2F;etc&#x2F;init.d&#x2F;ssh stopsudo &#x2F;etc&#x2F;init.d&#x2F;ssh start\nssh key&#x2F;&#x2F; 查看ssh key目录 ls -al ~&#x2F;.ssh &#x2F;&#x2F; 生成 ssh-keygen -t rsa -C &quot;&quot; &#x2F;&#x2F; 添加密钥到ssh-agent 注 见下文异常 ssh-add ~&#x2F;.ssh&#x2F;id_rsa.pub\n\n异常：Could not open a connection to your authentication agentssh-agent bash异常：Permissions 0777 for ‘~/.ssh/id_rsa’ are too open.It is recommended that your private key files are NOT accessible by others.This private key will be ignored.\n\nkeys need to be only readable to you&#x2F;&#x2F; 改为只读chmod 400 ~&#x2F;.ssh&#x2F;id_rsa ssh-add ~&#x2F;.ssh&#x2F;id_rsa.pub返回“identity added blablabla…”\n使用ssh key连接GitHub\n复制public key\n测试ssh -T git@github.com&#x2F;qqstone&#x2F;xxx.git\n\n异常：Could not resolve hostname github.com:qqstone/xxx.git： Name or service not known;\n\n\n\n尝试ping github.com 发现超时，说明dns给的地址连接超时，然而由于网页上是http协议，是可以有反向代理以及负载均衡配置的(具体原因存疑)，所以网页打开Github反而很流畅。另一种情况，主机无法连接正确的dns，解析超时，可以在连接正常的环境中(如无线网络或4g网络)用nslookup查看域名解析，找到实际的公网ip，然后在超时的环境中尝试用ip连接\n懒得去服务器上授权密钥，可以将已授权的 id_rsa + xxx.pub(公钥)拷贝覆盖到其他主机\n\n异常：The authenticity of host 192.168.xxx.xxx can’t be established.ECDSA key fingerprint is blablablassh  -o StrictHostKeyChecking&#x3D;no  192.168.xxx.xxx异常：ssh key在终端有效，在脚本中无效在终端执行git 命令，ssh key认证可自动通过，将命令写入shell执行，git命令会要求当前用户访问Repository的密码。\n\n原因可能是ssh key隶属当前用户，而未配置到root用户，root用户默认是禁用的，尝试添加/home/root/.ssh/*无效，未尝试添加/root/.ssh/*。git config core.sshCommand &quot;ssh -i &#x2F;home&#x2F;csd&#x2F;.ssh&#x2F;id_rsa -o StrictHostKeyChecking&#x3D;no git@hostname&quot;\n\n异常：kex_exchange_identification: read: Software caused connection abort. banner exchange: Connection to 20.205.243.166 port 22: Software caused connection abortfatal: Could not read from remote repository.\n\nuse https than ssh\nlinux系统之间的ssh授权访问一、概述\n1、就是为了让两个linux机器之间使用ssh不需要用户名和密码。采用了数字签名RSA或者DSA来完成这个操作\n2、模型分析\n假设 A （192.168.20.59）为客户机器，B（192.168.20.60）为目标机；\n要达到的目的：A机器ssh登录B机器无需输入密码；加密方式选 rsa|dsa均可以，默认dsa\n二、具体操作流程\n单向登陆的操作过程（能满足上边的目的）：1、登录A机器2、ssh-keygen -t [rsa|dsa]，将会生成密钥文件和私钥文件 id_rsa,id_rsa.pub或id_dsa,id_dsa.pub3、将 .pub 文件复制到B机器的 .ssh 目录， 并 cat id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys4、大功告成，从A机器登录B机器的目标账户，不再需要密码了；（直接运行 #ssh 192.168.20.60 ）\n双向登陆的操作过程：\n1、ssh-keygen做密码验证可以使在向对方机器上ssh ,scp不用使用密码.具体方法如下:2、两个节点都执行操作：#ssh-keygen -t rsa  然后全部回车,采用默认值.\n3、这样生成了一对密钥，存放在用户目录的~/.ssh下。将公钥考到对方机器的用户目录下，并将其复制到~/.ssh/authorized_keys中（操作命令：#cat id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys）。\n退出exit","categories":["工具"],"tags":["Linux","ssh"]},{"title":"Virtualbox","url":"/qqsnote/2021/05/31/vbox/","content":"VBoxManageubuntu可ssh远程用此命令行工具管理虚拟机\n\nVBoxManage list vms/runningvms\nVBoxManage startvm MyUbuntuvboxmanage startvm MyUbuntu --type headless #在宿主机端隐藏图形界面 \nVBoxManage controlvm MyUbuntu poweroff\n\n","tags":["Virtualbox"]},{"title":"svg","url":"/qqsnote/2021/03/10/svg/","content":"svg 可缩放矢量图形(Scalable Vector Graphics), 使用xml格式定义图形，大概长这样子&lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;  &lt;circle cx&#x3D;&quot;100&quot; cy&#x3D;&quot;50&quot; r&#x3D;&quot;40&quot; stroke&#x3D;&quot;black&quot; stroke-width&#x3D;&quot;2&quot; fill&#x3D;&quot;red&quot; &#x2F;&gt;&lt;&#x2F;svg&gt;嵌入html中可以作为dom操作，在数据可视化入门中曾提到D3数据可视化库即使用svg进行动态渲染的\n对于简单的icon响应可以有&lt;style&gt;    .toggle-btn &#123;        display: inline-block;        width: 40px;        height: 40px;        cursor: pointer;        color: #000;        background: #ccc;    &#125;    .toggle-btn&gt;input &#123;        width: 0;        height: 0;        opacity: 0;    &#125;    .toggle-btn&gt;svg &#123;        width: 100%;        height: 100%;    &#125;    input:checked+svg circle &#123;        fill: blue    &#125;&lt;&#x2F;style&gt;&lt;label class&#x3D;&quot;toggle-btn&quot;&gt;    &lt;input type&#x3D;&quot;checkbox&quot;&gt;    &lt;svg xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; version&#x3D;&quot;1.1&quot;&gt;        &lt;circle cx&#x3D;&quot;20&quot; cy&#x3D;&quot;20&quot; r&#x3D;&quot;20&quot; stroke&#x3D;&quot;black&quot; stroke-width&#x3D;&quot;2&quot; fill&#x3D;&quot;none&quot; &#x2F;&gt;    &lt;&#x2F;svg&gt;&lt;&#x2F;label&gt;\nsvg-react-loader将.svg文件资源作为组件载入import MyIcon from &#39;-!svg-react-loader!..&#x2F;..&#x2F;assets&#x2F;image&#x2F;icon.svg&#39;...return (&lt;&gt; &lt;MyIcon&gt; &lt;&gt;)作为资源路径import MyIcon from &#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;icon.svg&#39;...return (&lt;img src&#x3D;&#123;MyIcon&#125; &#x2F;&gt;)作为inline element(原生React特性)import &#123;ReactComponent as MyIcon&#125; from &#39;..&#x2F;..&#x2F;assets&#x2F;image&#x2F;icon.svg&#39;...return (&lt;div style&#x3D;&#123;&#123;color:&#39;red&#39;, cursor: &#39;pointer&#39;&#125;&#125;&gt;    &lt;MyIcon &#x2F;&gt;&lt;&#x2F;div&gt;)\nng-inline-svgshared.module.tsimport &#123; InlineSVGModule &#125; from &#39;ng-inline-svg&#39;@NgModule(&#123;    imports: [...LibModules,        InlineSVGModule.forRoot()],    exports: [...MuiModules],    declarations:  [],    providers: [],&#125;)export class SharedModule &#123; &#125;mycomponent.html&lt;div [inlineSVG]&#x3D;&quot;&#39;assets&#x2F;image&#x2F;icon.svg&#39;&quot;&gt;&lt;&#x2F;div&gt;\n鼠标响应Web MDN: svg pointer-events\n","tags":["svg"]},{"title":"terms","url":"/qqsnote/2024/03/20/terms/","content":"ENOENT“error no entry” 通常是 “No such file or directory”\n"},{"title":"video和视频流","url":"/qqsnote/2019/04/19/video-streaming/","content":"直播原理协议H5 video标签直播流的制作Nginx+ffmpeg安装下载RTMP模块并重编译nginx官方源代码https://github.com/arut/nginx-rtmp-module.git\n配置.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --add-module&#x3D;~&#x2F;nginx-rtmp-module --with-http_ssl_module\n编译并安装make &amp;&amp; make install\nnginx reload后报“open() “/usr/local/nginx/logs/nginx.pid” failed”,执行下面的命令，指定nginx的configure路径.&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf\n编译通过nginx可访问，还没完，配置nginx.conf，在末尾添加rtmp模块配置：rtmp&#123;    server &#123;        listen 1935;        chunk_size 4000;        # RTMP 直播流配置        application rtmplive &#123;            live on;            max_connections 1024;        &#125;        # hls 直播流配置        application hls&#123;            live on;            hls on;            hls_path &#x2F;usr&#x2F;local&#x2F;userdata&#x2F;live;            hls_fragment 5s;        &#125;    &#125;&#125;\nhls_path是分割文件存储路径\n在http模块中添加服务路径http &#123;    server &#123;        location &#x2F;hls&#123;            types&#123;                application&#x2F;vnd.apple.mpegurl m3u8;                video&#x2F;mp2t ts;            &#125;            root &#x2F;usr&#x2F;local&#x2F;userdata&#x2F;live;            add_header Cache-Control no-cache        &#125;    &#125;&#125;\n安装流媒体文件转换工具ffmpeg官方release：http://www.ffmpeg.org/download.html#releases解压tar jxvf ffmpeg-4.1.3.tar.bz2执行configure报“yasm/nasm not found or too old. Use —disable-x86asm for a crippled build”,ffmpeg默认的编译器未安装，需使用—disable-x86asm\n将本地视频文件通过nginx推流\n本地视频文件kon.mp4\n推送RTMP流ffmpeg -re -i test.mp4 -vcodec libx264 -acodec acc -f flv rtmp:&#x2F;&#x2F;127.0.0.1:1935&#x2F;rtmplive&#x2F;rtmp\n推送HLS流ffmpeg -re -i test.mp4 -vcodec libx264 -acodec acc -f flv rtmp:&#x2F;&#x2F;127.0.0.1:1935&#x2F;hls&#x2F;stream\n这里有一个关于编码器的坑\nvcodec acodec 分别指明了视频、音频的编码器，其实这里可以用copy也就是不需要转码，从官方GitHub下载安装的ffmpeg是没有libx264的编码器的，故而在执行上述推流命令时报unkown encoder libx264\n而通用的h.264视频编码器是叫x264：https://www.videolan.org/developers/x264.html\n\n安装x264需要将类库提供给外部应用程序(如ffmpeg).&#x2F;configure –enable-shared make &amp;&amp; make install配置编译的时候最好有—prefix指明安装路径，否则一般默认到/usr/local/lib路径下需要将/usr/local/lib路径加入共享库配置文件/etc/ld.so.conf中echo &quot;&#x2F;usr&#x2F;local&#x2F;lib&quot; &gt;&gt; &#x2F;etc&#x2F;ld.so.confldconfig编译安装含外部解码器的FFmpeg.&#x2F;configure --enable-static --enable-gpl --enable-libx264 --extra-cflags&#x3D;-I&#x2F;usr&#x2F;local&#x2F;include --extra-ldflags&#x3D;-L&#x2F;usr&#x2F;local&#x2F;libmake &amp;&amp; make install\n","categories":["前端技术"],"tags":["Linux","视频流"]},{"title":"vsftp","url":"/qqsnote/2020/06/09/vsftp/","content":"据说vsftp是very safe FTP, vsftp服务以ssl保护数据传输，使用22端口而不是21端口。sudo apt-get install vsftpd参数配置：/etc/vsftpd.conf,用cp命令备份下先参数定义—&gt;here\n修改配置后重启service vsftpd restartFileZilla\n","tags":["ftp"]},{"title":"vtk-codesnippet","url":"/qqsnote/2021/11/04/vtk-codesnippet/","content":"图形跟随cameraconst orientation &#x3D; renderObject.renderer.getActiveCamera().getViewPlaneNormal(); &#x2F;&#x2F; camera法向量brushPipeline?.circle.setDirection(orientation[0], orientation[1], orientation[2]);\n曾尝试actor.setOrientation失败 请使用source.setDirection\n‘线’转为‘管道’很多主流浏览器(包括Chrome)对webgl的实现中，设置线宽为1，在现阶段需要将line转为tube以实现‘线宽’const updateTubeActor &#x3D; (actor, polydata, lineWidth) &#x3D;&gt; &#123;    const filter &#x3D; vtkTubeFilter.newInstance();    const mapper &#x3D; actor.getMapper();    filter.setCapping(false);    filter.setNumberOfSides(10);    filter.setRadius(lineWidth);    filter.setInputData(polydata);    mapper.setInputConnection(filter.getOutputPort());&#125;;\n\nsetCapping\nsetNumberOfSides\nsetRadius\n\nget slice","categories":["图形学"],"tags":["WebGL","vtk"]},{"title":"vtk-interactor","url":"/qqsnote/2021/10/25/vtk-interactor/","content":"RenderWindowInteractor\n关于坐标RenderWindowInteractor事件中使用屏幕像素坐标而3D视图中是世界坐标\n\n模型坐标系 model coordinate system\n\n　　模型坐标系固定在模型上，该坐标系在建模时由建模者指定。\n\n世界坐标系 world coordinate system\n\n　　模型所处的位置，采用世界坐标系来描述。通常每个模型都有自己的坐标系，但是只有一个世界坐标系。在对模型进行旋转、平移、缩放时，世界坐标是不变的，但模型坐标系相对于世界坐标系的空间位置关系发生了变化。通常相机与光源也在世界坐标系中定义。\n\n视点坐标系 view coordinate system\n\n　　视点坐标系能够表达对相机可见的场景，其x和y坐标的范围在（-1，1）之间，z代表深度值。世界坐标系到视点坐标系之间的转换用4*4的相机矩阵来表达。\n\n屏幕坐标系 display coordinate system\n　　屏幕坐标系即图像坐标系，其坐标轴方向与视点坐标系一致，但是其x,y坐标值为像素坐标值。窗口尺寸决定了视点坐标与像素坐标的投影关系。不同的viewports（范围：0~1）能将同一个视点坐标系下的物体投影到不同的屏幕坐标系下。\n\n\n物体最初在模型坐标系下建立，并展示在世界坐标系中。通过相机空间变换矩阵投影到视点坐标系下，并经viewport展示在屏幕上。\nconst computerDisplayToWorld &#x3D; (x, y, z) &#x3D;&gt; &#123;    const view &#x3D; renderObject.renderer.getRenderWindow().getViews()[0];    return view.displayToWorld(x, y, z, renderObject.renderer);&#125;;","categories":["图形学"],"tags":["WebGL","vtk"]},{"title":"vtk","url":"/qqsnote/2020/08/04/vtk/","content":"The Rendering Enginemapper\nvtk.js —&gt; @kitware/vtk.js歪果仁不像码农期待的那样勤奋，官方的模板（如react-vtk-js）以及范例框架（ParaviewWeb）还是使用的vtk.js旧版本对于旧版本，提供了craco-vtk包进行移植npm install --save @craco&#x2F;craco craco-vtk vtk.js shader-loader worker-loader css-loader style-loader postcss-loadercraco-vtk在GitHub上的Repo已被移除(不过可以找到fork)，内容可参考craco-itk\nitk(Insight Segmentation and Registration Toolkit) 基于vtk的医学图像配准和分割工具包\npipeline\n\nreader\nfiltervtkActor派生自vtkProp类，渲染场景中数据的可视化表达是通过vtkProp的子类负责的。比如，本例要渲染一个柱体，柱体的数据类型是vtkPolyData，数据要在场景中渲染时，不是直接把数据加入渲染场景就可以，待渲染的数据是以vtkProp对象存在于渲染场景中。\n\n而vtkActor(表达场景中的几何数据)和vtkVolume(表达场景中的体数据)是三维空间中渲染对象最常用的vtkProp子类；二维空间中的数据则是用vtkActor2D表达。\nvtkProp子类负责确定渲染场景中对象的位置、大小和方向信息。Prop依赖于两个对象(Prop一词来源于戏剧里的“道具”，在VTK里表示的是渲染场景中可以看得到的对象。)，一个是Mapper(vtkMapper)对象，负责存放数据和渲染信息，另一个是属性(vtkProperty)对象，负责控制颜色、不透明度等参数。\nVTK中定义了大量(超过50个)的Prop类，如vtkImageActor(负责图像显示)和vtkPieChartActor(用于创建数组数据的饼图可视化表达)。其中的一些Prop内部直接包括了控制显示的参数和待渲染数据的索引，因此并不需要额外的Property和Mapper对象。vtkActor的子类vtkFollower可以自动的更新方向信息以保持始终面向一个特定的相机。这样无论怎样旋转，三维场景中的广告板(Billboards)或者文本都是可见的。vtkActor的子类vtkLODActor可以自动改变自身的几何表达来实现需要达到的交互帧率。vtkProp3D的子类vtkLODProp3D则是通过从许多Mapper(可以是体数据的Mapper和几何数据的Mapper集合)中进行选择来实现交互。vtkAssembly建立Actor的等级结构以便在整个结构平移、旋转或者缩放时能够更合理的控制变换。\nvtkActor::SetMapper()——设置生成几何图元的Mapper。即连接一个Actor到可视化pipeline的末端(可视化pipeline的末端就是Mapper)。\nvtkMapper将输入的数据转换为几何图元(graphics primitives：点、线、多边形)进行渲染。\nvtkRenderer负责管理场景scenes和角色actors的渲染过程。组成场景的所有对象包括Prop，照相机(Camera)和光照(Light)都被集中在一个vtkRenderer对象中。父类vtkViewport。一个vtkRenderWindow中可以有多个vtkRenderer对象，而这些vtkRenderer可以渲染在窗口中不同的矩形区域中(即视口)，或者覆盖整个窗口区域。\n\nvtkRenderer::AddActor()\nvtkRenderer::SetBackground()\nvtkRenderer::updateLightsGeometryToFollowCamera() light跟随cameracameracam &#x3D; renderer.getActiveCamera();cam.setParallelProjection(true); &#x2F;&#x2F;透视，false为平行 Parallel Projection\n获取平行放大比率 getParallelScaleMouseWheel的滚动事件并非移动camera的距离，而是将视野中心的区域放大，相当于视场角缩小，投影比例增大vtkRenderWindow连接操作系统与VTK渲染引擎\n\nInteractor提供平台独立的响应鼠标、键盘和时钟事件的交互机制，通过VTK的Command/Observer设计模式将监听到的特定平台的鼠标、键盘和时钟事件交由vtkInteractorObserver或其子类，如vtkInteractorStyle进行处理。vtkInteractorStyle等监听这些消息并进行处理以完成旋转、拉伸和放缩等运动控制。vtkRenderWindowInteractor自动建立一个默认的3D场景交互器样式(Interactor Style)：vtkInteractorStyleSwitch，当然你也可以选择其他的交互器样式，或者是创建自己的交互器样式。在本例中，我们就是选择了其他的交互器样式来替代默认的：vtkInteractorStyleTrackballCamera\n\nvtkRenderWindowInteractor::SetRenderWindow()——设置渲染窗口，消息是通过渲染窗口捕获到的，所以必须要给交互器对象设置渲染窗口。\n\nvtkRenderWindowInteractor::SetInteractorStyle()——定义交互器样式，默认的交互样式为vtkInteractorStyleSwitch。\n\nvtkRenderWindowInteractor::Initialize() ——为处理窗口事件做准备，交互器工作之前必须先调用这个方法进行初始化。\n\nvtkRenderWindowInteractor::Start() ——开始进入事件响应循环，交互器处于等待状态，等待用户交互事件的发生。进入事件响应循环之前必须先调用Initialize()方法。\n\n\ninteractor\nvtkInteractorStyleTrackballCamera交互器样式的一种，该样式下，用户是通过控制相机对物体作旋转、放大、缩小等操作。\n\n官方 paraviewparaview\nexample\nsourcecube &#x3D; vtk.vtkCubeSource(0)\nmappercuber_mapper &#x3D; vtk.vtkPolyDataMapper()cuber_mapper.SetInputConnection(    cube.GetOutPort())\nactorcube_actor &#x3D; vtk.vtkActor()cube_actor.SetMapper(cube_mapper)cube_actor.GetProperty.SetColor(1.0, 1.0, 1.0)\nrendererrenderer &#x3D; vtk.vtkRenderer()renderer.SetBackground(0.0, 0.0, 0.0)renderer.AddActor(cube_actor)\nrenderwindowrender_window &#x3D; vtk.vtkRenderWindow()render_window.SetWindowName(&quot;Simple VTK scene&quot;)render_window.SetSize(400, 400)render_window.AddRenderer(renderer)\ninteractor# Create an interactorinteractor &#x3D; vtk.vtkRenderWindowInteractor()interactor.SetRenderWindow(render_window)# Initialize the interactor and start the# rendering loopinteractor.Initialize()render_window.Render()\n\n","categories":["图形学"],"tags":["WebGL","vtk"]},{"title":"WebAssembly核心原理","url":"/qqsnote/2020/09/09/wasm-coreprinciples/","content":"关于sectionEMSCRIPTEN_KEEPALIVE宏enscripten embindC++暴露接口的一种方式\n#include &lt;emscripten&#x2F;bind.h&gt;using namespace emscripten;#include &quot;..&#x2F;wrapper&#x2F;DoSomething.cpp&quot;&#x2F;&#x2F; binding codeEMSCRIPTEN_BINDINGS(DoSomething)&#123;   class_&lt;DoSomething&gt;(&quot;DoSomething&quot;)       .constructor()       .function(&quot;SetInputData&quot;, &amp;DoSomething::SetInputData)       .function(&quot;DoAction&quot;, &amp;DoSomething::DoAction)       .function(&quot;GetOutput&quot;, &amp;DoSomething::GetOutput);&#125;\n上述代码将C++类DoSomething中的方法SetInputData，DoAction，GetOutput暴露在wasm模块中\n"},{"title":"vtk Widget","url":"/qqsnote/2022/01/26/vtkWidgets/","content":"vtk.js widgets\nvtk Widget是官方提供的常用小工具，如LineWidget、AngleWidget、PaitWidget等\nvtk Widget架构遵循MVC，分为三个组件\n\nvtkWidgetState (model)\nvtkWidgetRepresentation (view)\nvtkAbstractWidget (control)\n\n下图示意调用widget的不同组件的通信关系\nWidget 工厂Widget 工厂用于组装Widget及其state、representations\n构建vtkWidgetState调用getWidgetForView 工厂new一个widget对象 将state赋给该对象 创建并设置representations即SetRepresentation\n开发者应继承vtkAbstractWidgetFactory开发widget\n与InteractorStyle相比\nVTK的交互器样式（vtkInteractorStyle）通常只是控制相机以及提供一些简单的键盘和鼠标事件的交互技术。交互器样式在渲染场景中并没有一种表达形式，也就是说，在交互时我们看不见交互器样式到底是什么样子的，用户在使用这些交互器样式时，必须事先知道哪些键盘和鼠标事件是控制哪些操作的。FromCSDN: Widgets简介\n\nvtkWidget同为vtkInteractorObserver子类，监听并响应交互器事件，又添加可视化的representation\n开发WidgetsDeveloping WidgetsvtkWidgetManager 是管理widgets创建、抑制(suppression)及聚焦(focus)的对象，每个render中唯一widget &#x3D; vtkWidget.newInstance()handle &#x3D; widgetManager.addWidget(widget, viewType)widgetManager.setRenderer(renderer)widgetManager.grabFocus(widget)widgetManager.enablePicking()widgetManager.removeWidget(widget)widget.delete()focus至多一个widget 激活并使能其响应事件（其实behaviour也可以在unfocus的状态下响应）\n使用widget的newInstance方法创建widget对象 这时widget state被创建 用于在不同组件间同步状态 比如工具栏和canvas的相互交互\nviewType用于指示widget manager该使用的representation。\n创建子状态vtkStateBuilder.createBuilder().addStateFromMixin(&#123;    labels: [&#39;&#123;LABEL0&#125;&#39;],    mixins: [&#39;origin&#39;, &#39;color&#39;, &#39;scale1&#39;, &#39;visible&#39;],    name: &#39;&#123;NAME&#125;&#39;,    initialValues: &#123;      scale1: 0.1,      origin: [1, 2, 3],      visible: false,    &#125;&#125;)\n\nname是子状态唯一标识 调用state.get{NAME}()从widget state中读取子状态\nlabels决定哪些representation可以用来渲染该子状态\nmixins存放子状态有效数据 representation会使用到这些数据 因而是有限且标准的 get/set方法：subState.get{NAME}(), subState.set{NAME}() 修改子状态触发场景渲染\ninitialValues子状态初始值 非必须的\n\n动态子状态Mixins\n调用widgetManager.getRepresentationsForViewType(viewType)返回含representation的集合 参数viewType是addWidget时指定的参数返回各项 {builder, labels} 前者是Representation类 后者是representation对象要用到的子状态switch (viewType) &#123;  case ViewTypes.DEFAULT:  case ViewTypes.GEOMETRY:  case ViewTypes.SLICE:    return [      &#123;        builder: vtkCircleContextRepresentation,        labels: [&#39;handle&#39;, &#39;trail&#39;],      &#125;,      &#123;        builder: vtkPolyLineRepresentation,        labels: [&#39;trail&#39;],      &#125;,    ];  case ViewTypes.VOLUME:    return [        &#123;            builder: vtkSphereHandleRepresentation,            labels: [&#39;handles&#39;],            initialValues: &#123;              scaleInPixels: true,            &#125;,          &#125;,          &#123;            builder: vtkSphereHandleRepresentation,            labels: [&#39;moveHandle&#39;],            initialValues: &#123;              scaleInPixels: true,            &#125;,          &#125;,          &#123;            builder: vtkSVGCircleHandleRepresentation,            labels: [&#39;handles&#39;, &#39;moveHandle&#39;],          &#125;    ];  default:    return [&#123; builder: vtkSphereHandleRepresentation, labels: [&#39;handle&#39;] &#125;];&#125;Representation托管自身actors和mappers, actor在Representation创建时创建，推入model.actors中进而渲染Representation应继承vtkHandleRepresentation 或 vtkContextRepresentation\nWidget behaviorwidgetManager.addWidget返回的handle就是widget behavior对象 它控制这widget的行为：接收并响应鼠标、键盘事件 见其定义的方法形如 PublicAPI.handle{XXX}(callData)widget behavior也可以访问renderer rendererWindow 和 interactor\n","categories":["图形学"],"tags":["WebGL","vtk"]},{"title":"WebAssembly基础","url":"/qqsnote/2020/09/09/wasm-fundation/","content":"Javascriptwindow.requestAnimationFrame顾名思义用于动画帧的绘制, 类似于setInterval,传入回调函数,该回调函数将会在下一次浏览器尝试重新绘制当前帧动画时被调用&#x2F;&#x2F;迭代调用以使dom持续更新&lt;html&gt;  &lt;head&gt;    &lt;style&gt;      div &#123;        width: 100px;        height: 100px;        background-color: red;        position: absolute;      &#125;    &lt;&#x2F;style&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;div&gt;&lt;&#x2F;div&gt;  &lt;&#x2F;body&gt;  &lt;script&gt;    let start &#x3D; null;    let element &#x3D; document.querySelector(&#39;div&#39;);    const step &#x3D; (timestamp) &#x3D;&gt; &#123;      if (!start) start &#x3D; timestamp;      let progress &#x3D; timestamp - start;      element.style.left &#x3D; Math.min(progress &#x2F; 10, 200) + &#39;px&#39;;      if (progress &lt; 2000) &#123;        window.requestAnimationFrame(step);      &#125;    &#125;    window.requestAnimationFrame(step);  &lt;&#x2F;script&gt;&lt;&#x2F;html&gt;\nPerformance APIperformance.timingperformance.now()返回当前时刻距离 “time origin” 所经过的毫秒数，以此可以计算代码执行所花时间，精度大于Date.now()\nrequestIdleCallback传入一个回调函数，在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。\nTypedArray类型化数组，其实例描述底层的二进制数据缓冲区的类数组视图。实际上并没有TypedArray这个全局属性或者构造方法，可以认为是Int8Array，Uint32Array等对象的实例化数组的统称const DEFAULT_INDEX &#x3D; 0;&#x2F;&#x2F; Way one:const int8Arr &#x3D; new Int8Array(10);int8Arr[DEFAULT_INDEX] &#x3D; 16;console.log(int8Arr);  &#x2F;&#x2F; Int8Array [16, 0, 0, 0, 0, 0, 0, 0, 0, 0]int8Arr[0]&#x3D;256, int8Arr[1]&#x3D;257;console.log(int8Arr);  &#x2F;&#x2F; Int8Array(10) [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]&#x2F;&#x2F; Way two:const buffer &#x3D; new ArrayBuffer(16);uintArray &#x3D; new Uint8Array(buffer); &#x2F;&#x2F; Uint8Array(16) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]uintArray.set([255,255,255],4)console.log(uintArray);  &#x2F;&#x2F; Uint8Array(16) [0, 0, 0, 0, 255, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0]Way two中，ArrayBuffer 的构造函数其参数指定了该 ArrayBuffer 所能够存放的单字节数量，因此在“转换到”对应的 TypedArray 时，一定要确保 ArrayBuffer 的大小是 TypedArray 元素类型所对应字节大小的整数倍。TypedArray.prototype.set, 方法接受两个参数，第一个参数为将要进行数据读取的 JavaScript 普通数组；第二个参数为将要存放在类型数组中的元素偏移位置。\n可以作为类型化数组的内置对象：\n\nInt8Array\nUint8Array\nUint8ClampedArray\nInt16Array\nUint16Array\nInt32Array\nUint32Array\nFloat32Array\nFloat64ArrayC/C++对于C++的函数重载，C++编译器通常使用名为 “Name Mangling” 的机制，在编译的可执行文件中区分同名函数使用extern “C” {}用以避免“Name Mangling”处理：由于在这个特殊的结构中，C++ 编译器会强制以 C 语言的语法规则，来编译放置在这个作用域内的所有 C++ 源代码。而在 C 语言的规范中，没有“函数重载”这类特性，因此也不会对函数名进行 “Name Mangling” 的处理。编译优化DCE(Dead Code Elimination)在诸如 Clang / GCC 等编译器中，我们通常可以为编译器指定一些有关编译优化的标记，以让编译器可以通过使用不同等级的优化策略来优化目标代码的生成。而诸如 -O0 / -O1 / -O2 一直到 -Os 与 -O4 等选项，便是这些优化标记中的一部分。原码 反码 补码原码符号位不变 逐位取反—&gt; 反码 反码+1 —&gt; 补码访问控制列表ACL（Access Control List）堆栈机、寄存器机和累加器机\n\n","tags":["webassembly"]},{"title":"Wasm OpenGL项目","url":"/qqsnote/2025/08/06/wasm-opengl-project/","content":"(windows)git clone https:&#x2F;&#x2F;github.com&#x2F;emscripten-core&#x2F;emsdk.gitcd emsdkgit pull# need google access.&#x2F;emsdk.bat install latest.&#x2F;emsdk.bat activate latestcd ..git clone https:&#x2F;&#x2F;github.com&#x2F;microsoft&#x2F;vcpkg.gitcd vcpkg.\\bootstrap-vcpkg.bat# add vcpkg directory into env variable pathcd ..&#x2F;Workspace&#x2F;WasmOpenGLProjectvcpkg install boost:wasm32-emscripten vcpkg install glm:wasm32-emscriptenvcpkg install glad:wasm32-emscripten\n\nissues error: building openssl:wasm32-emscripten failed with: BUILD_FAILED\n\n查看了\\vcpkg\\buildtrees\\openssl\\install-wasm32-emscripten-dbg-err.log 内容是Trying to rename Makefile-333 -&gt; Makefile: Permission deniedmake[1]: *** [Makefile:2395: depend] Error 13make: *** [Makefile:2293: build_modules] Error 2make: *** Waiting for unfinished jobs....怀疑其他线程访问导致写入失败set VCPKG_MAX_CONCURRENCY&#x3D;1vcpkg install openssl:wasm32-emscripten --clean-after-build\n\nThe FindBoost module is removed.\n\ncmake 3.30 起移除了FindBoost模块 导致找不到BOOST_DIR Boost_FILESYSTEM_LIBRARY_DEBUG Boost_INCLUDE_DIR等， 实际上面的步骤中相关包已成功安装在D:\\Workspace\\Github\\vcpkg\\installed\\wasm32-emscripten\\include\nmake Ninja projectmkdir buildcd buildemcmake cmake -G &quot;Ninja&quot; ^    -DCMAKE_SYSTEM_NAME&#x3D;Emscripten ^    -DCMAKE_SYSTEM_PROCESSOR&#x3D;x86 ^    -DCMAKE_TOOLCHAIN_FILE&#x3D;&quot;%VCPKG_HUGE%&#x2F;scripts&#x2F;buildsystems&#x2F;vcpkg.cmake&quot; ^    -DVCPKG_CHAINLOAD_TOOLCHAIN_FILE&#x3D;&quot;%EMSDK%&#x2F;upstream&#x2F;emscripten&#x2F;cmake&#x2F;Modules&#x2F;Platform&#x2F;Emscripten.cmake&quot; ^    -DVCPKG_TARGET_TRIPLET&#x3D;wasm32-emscripten ^    -DCMAKE_C_COMPILER&#x3D;&quot;%EMCC_PATH%&quot; ^    -DCMAKE_CXX_COMPILER&#x3D;&quot;%EMXX_PATH%&quot; ^    -DCMAKE_BUILD_TYPE&#x3D;Release ^    -DCMAKE_FIND_ROOT_PATH_MODE_PACKAGE&#x3D;BOTH ^    -DCMAKE_PREFIX_PATH&#x3D;&quot;%VCPKG_HUGE%&#x2F;installed&#x2F;wasm32-emscripten&quot; ^    ..cd ..build wasmcd buildemmake ninja\n\n","tags":["OpenGL","webassembly","性能优化"]},{"title":"webassembly","url":"/qqsnote/2020/08/18/webassembly/","content":"应该首先从官方网站获取知识\nwebassembly知识储备或许会涵盖“编译原理”，Rust，v8开发，\n\nWebAssembly或称wasm是一个实验性的低端编程语言，应用于浏览器内的客户端。WebAssembly是便携式的抽象语法树，被设计来提供比JavaScript更快速的编译及运行。WebAssembly将让开发者能运用自己熟悉的编程语言编译，再藉虚拟机引擎在浏览器内运行。 —-维基百科\n\n背景参考《一个白学家眼里的 WebAssembly》\n曾几何时，有“一切可以由js实现的，终将用js实现”，而webassembly技术为编译型语言（c/c++,jave,c#等）抢夺浏览器战场打开了传送门。优势：\n\n运行效率高 如应用于文件上传中的扫描注1\n保密性好 见Google reCAPTCHA 另航妹博客：浅谈前端代码加密\n\n为什么wasm效率比js高？因为wasm是二进制指令格式，比执行js代码天然地节省解释和JIT的开销，但效率提高多少要看计算的复杂程度，简单场景或不相上下\n课外：为了提高浏览器性能，曾出现过从 NaCl、PNaCl 到 ASM.js，这些技术作为wasm的前辈，有以下特点————(于航《WebAssembly入门》)\n\n源码中都使用了类型明确的变量；\n应用都拥有独立的运行时环境，并且与原有的 JavaScript 运行时环境分离；\n支持将原有的 C/C++ 应用通过某种方式转换到基于这些技术的实现，并可以直接运行在 Web 浏览器中。\n\n现状是，四大厂（Mozilla，Google，Microsoft，Apple）共同倾力开发, WebAssembly 技术已成为 W3C 的标准, 其MVP版本(Minimum Viable Product)被主流浏览器支持\nWebassembly MDN\n工具链Emscripten,Rust, AssemblyScript\n\nIn case of conflict, consider users over authors over implementors over specifiers over theoretical purity.\nhelloworld.wasm\n准备一个新的开发环境：启动一个ubuntu的docker\ndocker pull ubuntusudo docker run -it -u root --name labdocker -v labdocker_home:/var/labdocker_home ubuntu bash\n上面的语句映射的是docker中的/var/labdocker_home和宿主的/var/lib/docker/volumes/labdocker_home/_data wtf???给‘空’的ubuntu安装必要工具\napt-get updateapt-get install -y nodejs npm git\n编译工具链依赖\napt-get install -y cmake python3.8\n安装emsdk\ngit clone https://github.com/emscripten-core/emsdk.gitcd emsdkgit pull./emsdk install latest // 这一步依赖python./emsdk activate latest source ./emsdk_env.sh // 定义环境变量\n\nYou always have to source ./emsdk_env.sh first in a new terminal session\n输入emcc -v查看信息看起来比较正常，说明工具安装成功\n\n\n另，其实安装emsdk不是必须的，docker hub中有现成的\ndocker pull emscripten/emsdkdocker run --rm -v $(pwd):/src -u $(id -u):$(id -g) \\  emscripten/emsdk emcc helloworld.cpp -o helloworld.js\n创建一个c项目\nmkdir /home/Workspace/hellocd /home/Workspace/helloecho &#x27;&#x27; &gt; hello.c\n回忆起c的hello world\n#include&lt;stdio.h&gt;int main(int argc, char** argv)&#123;  printf(&quot;hello hello~/n&quot;);&#125;\n走你\nemcc hello.c -s WASM=1 -o hello.html\n\n参数-s WASM=1 要求生成.wasm否则编译成asm.js\n-o hello.html Emscripten 生成一个我们所写程序的HTML页面，并带有 wasm 和 JavaScript 文件编译生成hello.wasm hello.js hello.html 可以用emrun运行这个html(直接用浏览器打开会认为读取file://文件违反policy) 因为docker没有映射端口，拷出来用http-server运行，是这样婶的：\n\nFFmpeg.js 的实现原文：Build FFmpeg WebAssembly version (= ffmpeg.wasm) 此链接国内网络或无法访问，可参考国内博客的类似文章，keyword:”webassemby” + “ffmpeg”\n关于ffmpeg,video和视频流那篇曾用其进行视频的转码和输出流。\n\nFFmpeg 是一个开放源代码的自由软件，可以运行音频和视频多种格式的录影、转换、流功能，包含了libavcodec(用于多个项目中音频和视频的解码器库)，以及libavformat(音频与视频格式转换库)。————维基百科clone FFmpeg 源码\n\ngit clone https://github.com/FFmpeg/FFmpeg\n源码根路径INSTALL.md为构建/安装说明\n./configuremake &amp; make install\n在windows上开发使用cygwin集成linux开发环境（本不应绕此远路），运行cygwin.setup安装程序安装以下库\ngcc-coremingw-gcc-corebinutilsgdb\n执行configure加以下参数\nbash ./configure --enable-cross-compile --disable-x86asm\nconfigure大约需要执行十几分钟（或更久，取决于cpu加网速）\n\nmake issue: ./libavutil/mem.h:342:1: warning: ‘alloc_size’ attribute ignored on a function returning ‘int’ [-Wattributes]  342 | av_alloc_size(2, 3) int av_reallocp_array(void ptr, size_t nmemb, size_t size);      | ^~~~~make: ** [ffbuild/common.mak:60: libavformat/mov_esds.o] Interrupt\n\n旧版本函数参数不一致导致的问题，已被修复，见[FFmpeg-devel] avutil/mem: Fix invalid use of av_alloc_size\n——————two weeks later————————\ngit clone https://github.com/FFmpeg/FFmpegcd FFmpeg.configure - --disable-x86asm // 这一步是根据configure生成MakeFilemake // 编译make install // 将编译产出复制到(安装)到linux的相应位置\n测试FFmpeg可以尝试在终端使用媒体编辑功能\nffmpeg --helpffmpeg -i test.mov -strict -2 -vf crop=720:405:0:451 out.mp4// 从test.mov中裁剪720*405大小区域，裁剪偏移（0，451）输出为out.mp4 \n我们目的是要生成.wasm放到浏览器中,这里用到Emscripten\n\nEmscripten compiles C and C++ to WebAssembly using LLVM and Binaryen. Emscripten output can run on the Web, in Node.js, and in wasm runtimes. ——— 《Emscripten ReadMe》\n\n回到make这步的输出项中：这个泛着绿光的ffmpeg就是Binaryen（二进制文件）LLVM(low level virtual machine)不限于字面意思的编译环境关于emcc\n\nEmcc 使用 Clang 和 LLVM 编译生成 Wasm或者asm.js\nEmscripten SDK (emsdk) 配置 .emscriten, 用于管理多份SDK和工具，指定当前正在使用的编译代码(Active Tool/SDK)。\n\n工具链依赖\napt-get install -y cmake python3.8\n安装emsdk\ngit clone https://github.com/emscripten-core/emsdk.gitcd emsdkgit pull./emsdk install latest // 这一步依赖python./emsdk activate latest source ./emsdk_env.sh // 定义环境变量\n\nYou always have to source ./emsdk_env.sh first in a new terminal session\n输入emcc -v查看信息看起来比较正常，说明工具安装成功\n\n\n另，其实安装emsdk不是必须的，docker hub中有现成的\ndocker pull emscripten/emsdkdocker run --rm -v $(pwd):/src -u $(id -u):$(id -g) \\  emscripten/emsdk emcc helloworld.cpp -o helloworld.js\n将FFmpeg源码编译成LLVM二进制码, 相比之前的configure &amp;&amp; make这里不仅要使用emconfigure 命令，而且要设置下述的若干参数，于是做一个build .sh:\n#!/bin/bash -x# verify Emscripten versionemcc -v# configure FFMpeg with EmscriptenCFLAGS=&quot;-s USE_PTHREADS&quot;LDFLAGS=&quot;$CFLAGS -s INITIAL_MEMORY=33554432&quot; # 33554432 bytes = 32 MBCONFIG_ARGS=(  --target-os=none        # use none to prevent any os specific configurations  --arch=x86_32           # use x86_32 to achieve minimal architectural optimization  --enable-cross-compile  # enable cross compile  --disable-x86asm        # disable x86 asm  --disable-inline-asm    # disable inline asm  --disable-stripping     # disable stripping  --disable-programs      # disable programs build (incl. ffplay, ffprobe &amp; ffmpeg)  --disable-doc           # disable doc  --extra-cflags=&quot;$CFLAGS&quot;  --extra-cxxflags=&quot;$CFLAGS&quot;  --extra-ldflags=&quot;$LDFLAGS&quot;  --nm=&quot;llvm-nm -g&quot;  --ar=emar  --as=llvm-as  --ranlib=llvm-ranlib  --cc=emcc  --cxx=em++  --objcc=emcc  --dep-cc=emcc)emconfigure ./configure &quot;$&#123;CONFIG_ARGS[@]&#125;&quot;# build dependenciesemmake make -j4# build ffmpeg.wasmmkdir -p wasm/distARGS=(  -I. -I./fftools  -Llibavcodec -Llibavdevice -Llibavfilter -Llibavformat -Llibavresample -Llibavutil -Llibpostproc -Llibswscale -Llibswresample  -Qunused-arguments  -o wasm/dist/ffmpeg.js fftools/ffmpeg_opt.c fftools/ffmpeg_filter.c fftools/ffmpeg_hw.c fftools/cmdutils.c fftools/ffmpeg.c  -lavdevice -lavfilter -lavformat -lavcodec -lswresample -lswscale -lavutil -lm  -s USE_SDL=2                    # use SDL2  -s USE_PTHREADS=1               # enable pthreads support  -s INITIAL_MEMORY=33554432      # 33554432 bytes = 32 MB)emcc &quot;$&#123;ARGS[@]&#125;&quot;\nEMCC_DEBUG设置EMCC_DEBUG变量使用调试模式编译wasm\nEMCC_DEBUG=1 emcc dip.cc   -s WASM=1   -O3   --no-entry   -o dip.wasm\nissues expected magic word 00 61 73 6d, found获取的wasm模块的MIME type不是application/wasm\n关于wasm的调用WebAssembly还没有和 \\ 或ES6的import语句集成，也就是说，当前还没有内置的方式让浏览器直接获取模块。ensdk生成的wasm js为js逻辑和wasm模块充当‘接口’实际上，在wasm js中，用fetch获取wasm文件的二进制代码，存入ArrayBuffer对象，并使用现代WebApi提供的WebAssembly对象，调用WebAssembly.instantiate()将带类型数组(ArrayBuffer)编译和实例化为wasm module的对象大致形如\nfetch(&#x27;module.wasm&#x27;).then(response =&gt;  response.arrayBuffer()).then(bytes =&gt;  WebAssembly.instantiate(bytes, importObject)).then(results =&gt; &#123;  // Do something with the compiled results!&#125;);\nemcmake 和 emmakeemcmake是CMake enscripten的交叉编译环境 emmake是enscripten环境的make工具\n@echo OFF@set ROOTDIR=%~dp0@set WORKDIR=%ROOTDOR%build@rd /s /q %WORKDIR%@md %WORKDIR%@cd %WORKDIR%@call emcmake cmake -G &quot;Ninja&quot; .. -DBUILD_HERE_IS_BIZ_VARIABLES=VALUE @call cmake --build .@cd %ROOTDIR%@echo ON\n上述命令先在build目录下构建build.ninja等脚本文件 然后调用cmake —build .自动在当前目录检测上一步的“中间产出” 例子中的这种情况则是调用ninja执行构建\n\nissue: 无法找到或配置所需的资源编译器\n\n-DCMAKE_FIND_ROOT_PATH=&quot;%VCPKG%\\installed\\wasm32-emscripten&quot;\n\nissue: Boost_DIR cannot found\n\n\n工具链文件路径 (GPT说顺序有影响 暂未验证)\n\n-DCMAKE_TOOLCHAIN_FILE=&lt;vcpkg路径&gt;/scripts/buildsystems/vcpkg.cmake-DVCPKG_CHAINLOAD_TOOLCHAIN_FILE=&lt;emscripten路径&gt;/cmake/Modules/Platform/Emscripten.cmake\n\n目标三元组\n\n三元组指操作系统、架构和运行时\n-DVCPKG_TARGET_TRIPLET=wasm32-emscripten\n\n查找模式和路径\n\n-DCMAKE_FIND_ROOT_PATH_MODE_PACKAGE=BOTH-DCMAKE_PREFIX_PATH=&quot;%VCPKG%/installed/wasm32-emscripten&quot;\n\nissue: CMake Error: CMAKE_RC_COMPILER not set, after EnableLanguage\n\n-DCMAKE_RC_COMPILER_INIT=FALSE\n\nissue: find_program considered the following locations:…llvm…the item was not found\n\n安装LLVM(Low Level Virtual Machine) x64不影响32位构建目标 安装后命令行clang —version查看当前c语言版本(新版本不影响旧工程构建)\n\nSystem is unknown to cmake, create: Platform/Emscripten to use this system, please post your config file on discourse.cmake.org so it can be added to cmake\n\n这条是提示和建议 收集平台信息用于社区共建 不需处理\n","tags":["webassembly","性能优化"]},{"title":"WebGL教程","url":"/qqsnote/2019/09/12/webgllessons/","content":"RoadMapwebgl学习路线\n@startmindmap*[#409EFF] 《webgl编程指南》    **[#79bbff] 渲染管线        ***_ 理解着色器 图元 光栅化 片元等        ***_ webglcontext绘制流程    **[#79bbff] 矩阵变换        ***_ 平移 旋转 缩放        ***_ 视图矩阵    **[#79bbff] 渲染特效        ***_ 颜色 纹理贴图    **[#79bbff] GLSL        ***_ 基本类型        ***_ 矢量和矩阵        ***_ 结构体        ***_ 函数        ***_ 限定字        ***_ 预处理    **[#79bbff] 三维世界        ***_ 投影        ***_ 可视范围 可视空间        ***_ 遮挡    **[#79bbff] 光照    **[#79bbff] 高级技术        ***_ 帧缓冲区和投影        ***_ 等距圆柱贴图        ***_ 等宽度线@endmindmap\n线性代数\n计算机图形学\n目标导向keyWords: 渲染引擎开发 shader设计优化\n三维模型的平面投影————矩阵运算图解webgl\n渲染管线其中所谓光栅化 我理解是屏幕光栅 将矢量图形映射到有限分辨率的屏幕像素上 每个像素通过片元着色器绘制\nWebGLRenderingContext获取webgl并调用webgl接口设置渲染背景色const canvas &#x3D; document.getElementById(&#39;webgl&#39;);&#x2F;&#x2F; if webgl context isnot exist, init it const webgl &#x3D; canvas.getContext(&#39;webgl&#39;);&#x2F;&#x2F; Set clear color to black, fully opaquewebgl.clearColor(0.0, 0.0, 0.0, 1.0);&#x2F;&#x2F; Clear the color buffer with specified clear colorwebgl.clear(webgl.COLOR_BUFFER_BIT);color 是float 0.0~1.0 映射 0~255颜色缓冲区（COLOR_BUFFER_BIT），其他还有深度缓冲区（DEPTH_BUFFER_BIT）模板参数缓冲区（STENCIL_BUFFER_BIT）参考 官方标准\n着色器着色器是使用 GLSL(OpenGL ES Shading Language)编写的程序，它携带着绘制形状的顶点信息以及构造绘制在屏幕上像素的所需数据，换句话说，它负责记录着像素点的位置和颜色。顶点着色器（Programmable Vertex Processor）和 片元着色器（Programmable Fragment Processor）\nWebAPI: WebGLRenderingContext.shaderSource设置着色器源码，参数分别是着色器变量，和源码字符串const vertexShaderSource &#x3D; &#96;    void main()&#123;        gl_Position&#x3D;vec4(0.0,0.0,0.0,1.0);        gl_PointSize&#x3D;100.0; &#x2F;&#x2F;这里写100就会报错！    &#125;&#96;;const fragmentShaderSource &#x3D; &#96;    void main()&#123;        gl_FragColor&#x3D;vec4(1.0,1.0,0.0,1.0);    &#125;&#96; GLSL非常严格，函数分号的缺失、甚至浮点数写成整型都可能在后面调用WebGLProgram时报错 变量名也是GLSL定义死的不可更改\n\nWebGL: INVALID_OPERATION: useProgram: program not valid\n着色器函数const initShader &#x3D; (gl: WebGLRenderingContext )&#x3D;&gt;&#123;    &#x2F;&#x2F; 创建程序对象    const program &#x3D; gl.createProgram();    if(program)&#123;        &#x2F;&#x2F; 创建着色器对象        const vertexShader &#x3D; loadShader(gl, gl.VERTEX_SHADER, vertexShaderSource)        const fragmentShader &#x3D; loadShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource)        &#x2F;&#x2F; 附加着色器到程序        gl.attachShader(program, vertexShader!)        gl.attachShader(program, fragmentShader!)        &#x2F;&#x2F; 链接webgl上下文对象和程序对象        gl.linkProgram(program)        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) &#123;            alert(              &quot;无法初始化着色器程序: &quot; +              gl.getProgramInfoLog(program),            );            return null;          &#125;        &#x2F;&#x2F; 启动程序对象        gl.useProgram(program)    &#125;    &#125;const loadShader &#x3D; (gl: WebGLRenderingContext, type:number, source: string)&#x3D;&gt;&#123;    const shader &#x3D; gl.createShader(type)    if(!shader) return null    gl.shaderSource(shader, source)    gl.compileShader(shader)    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) &#123;        alert(        &quot;编译着色器时出错：&quot; + gl.getShaderInfoLog(shader),        );        gl.deleteShader(shader);        return null;      &#125;    return shader&#125;\n使用上述着色器绘制点initShader(webgl)webgl.drawArrays(webgl.POINTS, 0, 1)\n\nvertex shader attribute声明attribute变量const vertexShaderSource &#x3D; &#96;    attribute vec4 a_Position;    void main()&#123;        gl_Position&#x3D;a_Position;        gl_PointSize&#x3D;100.0;    &#125;&#96;;获取attribute变量指针, 这里的a_Position是个number类型的常量，通过webgl接口可以访问到它‘指向’的shader中的attributeconst a_Position &#x3D; webgl!.getAttribLocation(webglProgram, &#39;a_Position&#39;)webgl!.vertexAttrib3f(a_Position, 0.0, 0.5, 0.0);webgl提供了一系列修改顶点着色器attribute同族方法 用于设置不同数量的分量 [vertexAttrib[1234]f[v]] 其中f指浮点数(https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/vertexAttrib)v是vector值 类型为Float32Array 如vertexAttrib3fv(index, value)\nfragment shader uniform相应的片元着色器中是uniform变量 对于片元着色器有特殊要求指明浮点数精度const fragmentShaderSource &#x3D; &#96;    precision mediump float; &#x2F;&#x2F;中等精度浮点数    uniform vec4 u__FragColor;     void main()&#123;        gl_FragColor&#x3D;u__FragColor;    &#125;&#96; const u__FragColor &#x3D; webgl.getUniformLocation(webgl.program,&#39;u__FragColor&#39;);webgl.uniform4f(u__FragColor, 1.0,1.0,0.0,1.0)\n\nattribute 变量用于在顶点着色器中从应用程序（如OpenGL程序）传递逐顶点数据。每个顶点可以有不同的值，因此 attribute 变量通常用于传递顶点的位置、法线、纹理坐标、颜色等数据。\n\n使用场景：\n\n当你需要为每个顶点提供特定的数据时。\n当数据需要随着每个顶点变化时。\nuniform 变量用于在顶点着色器和片段着色器之间传递数据，或者从应用程序传递到着色器程序。uniform 变量的值在整个绘制调用中是恒定的，不会随着顶点的变化而变化。\n\n\n\n使用场景：\n\n当你需要传递一些在整个绘制调用中保持不变的数据时。\n当数据需要在顶点着色器和片段着色器之间共享时。\n\n补间动画补间动画在两关键帧之间插值而得。\n多点数据标量 向量 张量\n标量 scalar\n向量 vendor\n张量 tensor 与矢量相类似，定义由若干坐标系改变时满足一定坐标转化关系的有序数组成的集合为张量。\n\n\n在二维空间里，二维二阶张量（平面应力张量）的每个方向都可以用二维空间两个方向表示。（区分2阶张量的2个方向，和二维空间的两个方向x，y）所以共有2^2=4个方向。在三维空间里，三维二阶张量（空间应力张量）的每个方向都可以用三维空间三个方向表示。（区分2阶张量的2个方向，和三维空间的三个方向x，y、z）所以共有3^2=9个方向。通俗理解张量tensor\n\n三维空间内的向量根据笛卡尔坐标系的x,y,z三个基向量分解为三个分量 故\nv=\\left[\n \\begin{matrix}\n   v_x \\\\\n   v_y \\\\\n   v_z \n  \\end{matrix}\n  \\right]而三维二阶张量，其物理含义是某点分解为三个两两正交的平面以及每个平面上的力（力是向量 其自有三个分量）3×3共9个分量如视频截图 方块表示每个分量上的值(模值，标量)\nt=\\left[\n \\begin{matrix}\n   v_{xx} & v_{xy} & v_{xz} \\\\\n   v_{yx} & v_{yy} & v_{xz} \\\\\n   v_{zx} & v_{xy} & v_{zz} \n  \\end{matrix}\n  \\right]应力张量通俗地理解张量\nmesh polygon nurbsmesh是曲面 在计算机三维处理中常以polygon(多边形)来实现NURBS （Non-uniform rational basis spline非均匀有理基本样条）基于数学公式表达的曲面，但在计算机三维处理中实现 还是需要差值以及polygon\n浏览器支持访问https://get.webgl.org测试当前浏览器是否支持webgl\ninterview面试题\n","categories":["图形学"],"tags":["WebGL"]},{"title":"webpack","url":"/qqsnote/2020/05/07/webpack/","content":"关于Webpack的学了又忘再看这一部分，是因为配置 craco过程中碰壁，Webpack是常用的工程化工具，前端开发需要Webpack地方，大多是需要配置Webpack configure向工程中嵌入一些插件\n\n「面试当中有时候会问到 Webpack 相关的配置」是我首先要强烈批判的点，也是 Webpack 学习雷区，「熟背 Webpack」并不是健康的学习导向。———— 《前端有必要学Webpack吗》\n\n\nCode Splitting 代码分割\nHashing 指资源的版本信息映射\nImporting Modules 引入模块\nNon-JavaScript Resources 支持非JavaScript 类型资源\nOutput Module Formats 输出模块格式\nTransformations 转译\n\n我是如何用 Webpack 虐待代码尺寸的\n安装配置webpacknpm i webpack webpack-cli\nwebpack.config.jsconst path &#x3D; require(&#39;path&#39;)module.exports &#x3D; &#123;    mode:&#39;development&#39;,    entry:&#39;.&#x2F;src&#x2F;index.js&#39;,    output:&#123;        filename:&#39;bundle.js&#39;,        path:path.resolve(__dirname, &#39;dist&#39;)    &#125;&#125;npx webpack --config webpack.config.js\n模块\n模块化编程中，开发者将程序分解为功能离散的chunk，并称之为模块\n\nNode.js是从一开始就支持模块化编程的环境，其将一段js逻辑export为一个module，随着web发展，模块化逐渐得到支持，webpack工具设计为可将模块化应用到任何文件中除了js的module外，还有css/less/sass的module，以及wasm的module等\n不同‘文件和语言的’模块使用对应的loader引入appdemo project:webpack-demo  |- package.json  |- webpack.config.js  |- &#x2F;dist    |- bundle.js    |- index.html  |- &#x2F;src    |- data.xml    |- my-font.woff    |- my-font.woff2    |- icon.png    |- style.css    |- index.js  |- &#x2F;node_moduleswebpack.config.jsconst path &#x3D; require(&#39;path&#39;);module.exports &#x3D; &#123;  entry: &#39;.&#x2F;src&#x2F;index.js&#39;,  output: &#123;    filename: &#39;bundle.js&#39;,    path: path.resolve(__dirname, &#39;dist&#39;)  &#125;,  module: &#123;    rules: [      &#123;        test: &#x2F;\\.css$&#x2F;,        use: [          &#39;style-loader&#39;,          &#39;css-loader&#39;        ]      &#125;,      &#123;        test: &#x2F;\\.(png|svg|jpg|gif)$&#x2F;,        use: [          &#39;file-loader&#39;        ]      &#125;,      &#123;        test: &#x2F;\\.(woff|woff2|eot|ttf|otf)$&#x2F;,        use: [          &#39;file-loader&#39;        ]      &#125;,     &#123;       test: &#x2F;\\.(csv|tsv)$&#x2F;,       use: [         &#39;csv-loader&#39;       ]     &#125;,     &#123;       test: &#x2F;\\.xml$&#x2F;,       use: [         &#39;xml-loader&#39;       ]     &#125;    ]  &#125;&#125;;index.jsimport _ from &#39;lodash&#39;;import &#39;.&#x2F;style.css&#39;;import Icon from &#39;.&#x2F;icon.png&#39;;import Data from &#39;.&#x2F;data.xml&#39;;function component() &#123;  var element &#x3D; document.createElement(&#39;div&#39;);  &#x2F;&#x2F; Lodash, now imported by this script  element.innerHTML &#x3D; _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;);  element.classList.add(&#39;hello&#39;);  &#x2F;&#x2F; Add the image to our existing div.  var myIcon &#x3D; new Image();  myIcon.src &#x3D; Icon;  element.appendChild(myIcon);  console.log(Data);  return element;&#125;document.body.appendChild(component());\n管理输出webpack 将打包好的各模块的bundle.js文件引用到app入口index.js中，若对入口文件修改可如下配置，使bundle.js引用到新的入口var HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)const path &#x3D; require(&#39;path&#39;);  module.exports &#x3D; &#123;    entry: &#123;      app: &#39;.&#x2F;src&#x2F;index.js&#39;,      print: &#39;.&#x2F;src&#x2F;print.js&#39;    &#125;,    output: &#123;      filename: &#39;[name].bundle.js&#39;,      path: path.resolve(__dirname, &#39;dist&#39;),      plugins: [new HtmlWebpackPlugin()]    &#125;  &#125;;\nsource map devtool plugin源码映射以便随浏览器运行进行调试，参考 SourceMapDevToolPlugin\nwebpack-bundle-analyzer模块打包结构分析插件,参考webpack官方—webpack-bundle-analyzer\n\n安装npm intall --save-dev webpack-bundle-analyzer在Angular项目中使用ng build --prod --stats-jsonnpx webpack-bundle-analyzer dist&#x2F;stats.json在自定义项目中, 添加plugin&#x2F;&#x2F; webpack.config.js 文件const BundleAnalyzerPlugin &#x3D; require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPluginmodule.exports&#x3D;&#123;  plugins: [    new BundleAnalyzerPlugin()  &#x2F;&#x2F; 使用默认配置    &#x2F;&#x2F; 默认配置的具体配置项    &#x2F;&#x2F; new BundleAnalyzerPlugin(&#123;    &#x2F;&#x2F;   analyzerMode: &#39;server&#39;,    &#x2F;&#x2F;   analyzerHost: &#39;127.0.0.1&#39;,    &#x2F;&#x2F;   analyzerPort: &#39;8888&#39;,    &#x2F;&#x2F;   reportFilename: &#39;report.html&#39;,    &#x2F;&#x2F;   defaultSizes: &#39;parsed&#39;,    &#x2F;&#x2F;   openAnalyzer: true,    &#x2F;&#x2F;   generateStatsFile: false,    &#x2F;&#x2F;   statsFilename: &#39;stats.json&#39;,    &#x2F;&#x2F;   statsOptions: null,    &#x2F;&#x2F;   excludeAssets: null,    &#x2F;&#x2F;   logLevel: info    &#x2F;&#x2F; &#125;)  ]&#125;scan-link, react+vtk.js+materialUI的项目\nloaderloader是webpack可调用的一些对文件预处理的模块内联调用loaderimport MyIcon from &#39;-!svg-react-loader!..&#x2F;..&#x2F;assets&#x2F;image&#x2F;icon.svg&#39;\ntypescriptwebpack 集成 typescript：npm install --save-dev typescript ts-loader添加tsconfig.json&#123;  &quot;compilerOptions&quot;: &#123;    &quot;outDir&quot;: &quot;.&#x2F;dist&#x2F;&quot;,    &quot;noImplicitAny&quot;: true,    &quot;module&quot;: &quot;es6&quot;,    &quot;target&quot;: &quot;es5&quot;,    &quot;jsx&quot;: &quot;react&quot;,    &quot;allowJs&quot;: true  &#125;&#125;\n环境变量\nThere is also a built-in environment variable called NODE_ENV. You can read it from process.env.NODE_ENV. When you run npm start, it is always equal to ‘development’, when you run npm test it is always equal to ‘test’, and when you run npm run build to make a production bundle, it is always equal to ‘production’. You cannot override NODE_ENV manually. This prevents developers from accidentally deploying a slow development build to production. ————《create-react-app自定义环境变量》\n\n禁止生成SourceMap, 注意不要在&amp;&amp;之前添加多余空格set GENERATE_SOURCEMAP&#x3D;false&amp;&amp; yarn build\n代码访问静态资源\nvue中绑定静态资源路径需要如url: require(‘@/assets/images/threelogo.png’) 为什么url用字符串不行\n\n通过webpack的工程化，静态资源以require模块的形式导入上下文， @ 是 Webpack 中配置的路径别名，通常指向 src 目录。使用 require(‘@/assets/images/threelogo.png’) 可以确保路径正确解析。\npublic目录的资源一般不需要经过webpack解析\n","categories":["前端技术"],"tags":["webpack"]},{"title":"Tips in windows","url":"/qqsnote/2019/09/10/windowstips/","content":"环境变量添加变量,set为临时，永久设置换setx\nset JAVA_HOME=&quot;C:\\jre\\bin&quot;\n调用\n%JAVA_HOME%\n常用环境变量\n\n%COMPUTERNAME% 当前计算机的名称\n%USERNAME% 当前登录用户的用户名\n%USERPROFILE% 用户目录\n%PATH% 路径列表 用于定义可执行文件的搜索路径\n%TEMP% 临时文件路径\n\n输出到剪切板echo %JAVA_HOME% | clip\n输出文本文件内容type nul &gt; 文件名.txt# 输出 覆盖echo 内容 &gt; 文件名.txt# 输出 追加echo 内容 &gt;&gt; 文件名.txt \n事实上windows cmd中创建文件的确是用定向输出的方式实现的\n显示文件树# 显示目录tree# 递归全部目录及文件tree/F\n调用和输出\n\n\n\ncommand\ncomments\n\n\n\n\ncommand &gt; filename\nRedirect command output to a file\n\n\ncommand &gt;&gt; filename\nAPPEND into a file\n\n\ncommand &lt; filename\nType a text file and pass the text to command\n\n\ncommandA  \\\ncommandB\nPipe the output from commandA into commandB\n\n\ncommandA &amp;  commandB\nRun commandA and then run commandB\n\n\ncommandA &amp;&amp; commandB\nRun commandA, if it succeeds then run commandB\n\n\ncommandA \\\n\\\ncommandB\nRun commandA, if it fails then run commandB\n\n\ncommandA &amp;&amp; commandB \\\n\\\ncommandC\nIf commandA succeeds run commandB, if it fails commandC\n\n\n\n\n\nIn most cases the Exit Code is the same as the ErrorLevel\n\n刷新应用图标桌面图标显示为未知文件，调用以下应用可以解决run ie4uinit -show\nFix The Parameter is Incorrect Exception某年月日因磁盘松动，重新连接后报如图异常\n\n命令行执行\nchkdsk /f\n检索到了网络上的解决方法chkdsk /f /x /r，后面的参数会极大增加修复错误花的时间，而且/x /r 都包含了/f (fixes errors on the disk. The disk must be locked. If chkdsk cannot lock the drive, a message appears that asks you if you want to check the drive the next time you restart the computer.)\n查找进程及其杀灭tasklist|grep cscportaltaskkill /IM &quot;cscportal.exe&quot; /F\n查找端口占用netstat -ano | findstr &quot;8081&quot;taskkill /PID &lt;pid&gt; /F\n琐碎文件的删除win10 系统中删除文件夹，会进行文件统计，对于文件目录和源代码目录琐碎的情形，它敢给你统计几个小时，正确的删除姿势有两种a. 安全模式\nb. 命令行(分两步：删除文件；删除目录)\ndel /s/f/q node_modulesrmdir /s/q node_modules\npowershell应该用\nRemove-Item -Path node_modules -Force -Recurse\n信任来自开发机的SSL证书(https)将计算机配置为信任 IIS Express 证书\n远程连接时关闭指定进程gpedit.msc -&gt; 计算机配置 -&gt; 管理模板 -&gt; Windows组件服务 -&gt; 远程桌面服务 -&gt; 远程桌面会话主机 -&gt; 远程会话环境 -&gt; 连接时启动程序程序路径和文件名：%systemroot%\\system32\\cmd.exe /c D:\\Environment\\killMouseWithoutBorders.bat Caution! 无法执行指定脚本\n关闭进程\n@echo offcd /d &quot;%~dp0&quot;cacls.exe &quot;%SystemDrive%\\System Volume Information&quot; &gt;nul 2&gt;nulif %errorlevel%==0 goto Adminif exist &quot;%temp%\\getadmin.vbs&quot; del /f /q &quot;%temp%\\getadmin.vbs&quot;echo Set RequestUAC = CreateObject^(&quot;Shell.Application&quot;^)&gt;&quot;%temp%\\getadmin.vbs&quot;echo RequestUAC.ShellExecute &quot;%~s0&quot;,&quot;&quot;,&quot;&quot;,&quot;runas&quot;,1 &gt;&gt;&quot;%temp%\\getadmin.vbs&quot;echo WScript.Quit &gt;&gt;&quot;%temp%\\getadmin.vbs&quot;&quot;%temp%\\getadmin.vbs&quot; /fif exist &quot;%temp%\\getadmin.vbs&quot; del /f /q &quot;%temp%\\getadmin.vbs&quot;exit:Admintaskkill /f /im MouseWithoutBorders.exe\n关于 cmd 接受参数 输入cmd /?\n关于bat脚本获取administrator权限知乎：怎样自动以管理员身份运行bat文件?\n获取ipfor /f &quot;tokens=2 delims=:&quot; %%i in (&#x27;ipconfig ^| findstr IPv4&#x27;) do (    set ipAddr=%%i)\ntokens第x项 delims以xx为分隔\nVS Codelaunch.json设置相对路径\n&quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;, //相对当前文件位置&quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, //相对工作目录\n开机启动启动regedit路径 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run新建【字符串值】并输入路径\n工具截图 Win + Shift + S窗口移动 Win + ← | →窗口最大化最小化 Win + ↑ | ↓\nideF5  Start Debug/Continue, Shift + F5 Stop DebuggingF11 Step In, Shift + F11 Step OutF10 Step Over\nC语言编译环境Nginx Build：\n\nMicrosoft Visual C compiler. 装有Microsoft Visual Studio即可\nMSYS or MSYS2. Mini GUN 环境， 与Cygwin大致相当\nPerl, Perl 是 Practical Extraction and Report Language 的缩写，可翻译为 “实用报表提取语言”。if you want to build OpenSSL® and nginx with SSL support. For example ActivePerl or Strawberry Perl.\nMercurial client.\nPCRE, zlib and OpenSSL libraries sources.\n\n我用Cygwin！Cygwin最小系统\n已安装Cygwin的，再次启动安装程序Setup.exe可以安装依赖的Libraries, 如上PCRE、zlib、OpenSSL导航到d盘的源码目录\n```cmd#### bat相对路径```cmdcd /d %~dp0.\\tool\\signtool.exe sign /f &quot;.\\cert\\xxx.pfx&quot; /p pswxxx /fd SHA256 /t &quot;http：//timestamp.digicert.com&quot; %1\n默认情况下，脚本执行的目录在cmd调用脚本的位置，比如以管理员权限打开cmd，其工作目录在C:\\User\\CurrentUser而脚本往往放在项目目录下 用相对路径描述所需资源位置，执行时可以cd到脚本目录下，更好的做法是在每个bat开头加入“cd /d %~dp0” 表示移动到该脚本目录位置\n查找最新的文件并输出创建时间@echo offsetlocalset folderPath=&quot;.\\&quot;set latestFile=for /f &quot;delims=&quot; %%f in (&#x27;dir %folderPath% /b /o-d /tc&#x27;) do (    if not defined latestFile (        set latestFile=%%f    ))for /f &quot;skip=5 tokens=1,2,4,5* delims= &quot; %%a in (&#x27;dir %folderPath%\\%latestFile% /a:-d /o:d /t:c&#x27;) do (    if &quot;%%~c&quot; NEQ &quot;bytes&quot; (        echo(            @echo file name:        %%~d            @echo creation date:    %%~d            @echo creation time:    %%~d        )    ))\nothers\nInstallShield is used for the creation of installers on Windows Platforms.\nCygwin is used for creation of ISO files.\n\n进程返回值your_program.exe  echo %ERRORLEVEL%\nwin11按住shift右键显示 缺省的右键菜单\nmklink使用mklink将系统盘资源转移到其他盘\nmklink /J C:\\Users\\qqs\\.nuget D:\\Environment\\.nuget \n源路径要删除 因为/J 相当于创建C:\\Users\\qqs.nuget为快捷方式指向新的路径\nwin + v从历史剪切板选择粘贴\n多行编辑在vscode 和 notepad++ 中按住 alt + shift 选中文本纵向编辑在vscode中按ctrl + shift + P 搜索cursor 能找到一个Toggle Multi-Cursor Modifier 具体待QQs研究\nwmic查看内存型号\nwmic memorychip get manufacturer, capacity, speed, memorytype, partnumber\n","categories":["工具"],"tags":["环境变量","windows"]},{"title":"yarn","url":"/qqsnote/2021/01/22/yarn/","content":"install packages:yarnexecuate projectyarn [YourScriptInPackageJSON]\nyarn 和 npm\nyarn 速度更快（并行和离线缓存）\nlock 版本 （与package-lock.json）\n\nyarn.lock\n如package-lock.json 开发过程中不应删除重建 应当及时提交\nyarn 过程根据yarn.lock的依赖树安装及拷贝package 且对与package.json不一致的依赖进行更新\n使用 yarn upgrade 根据package.json对依赖进行升级 并更新yarn.lock\n\nyarn 和 yarn install\nyarn install is used to install all dependencies for a project. This is most commonly used when you have just checked out code for a project, or when another developer on the project has added a new dependency that you need to pick up.If you are used to using npm you might be expecting to use —save or —save-dev. These have been replaced by yarn add and yarn add —dev. For more information, see the yarn add documentation.\nRunning yarn with no command will run yarn install, passing through any provided flags.\n\n查看包版本 yarn info xxpkgyarn list xxpkg —depth=0\n从私有Repository安装配置.yarnrc.yml 即yarn resouce configurenpmRegistries:  &#x2F;&#x2F;qqstone.jfrog.io&#x2F;artifactory&#x2F;api&#x2F;npm&#x2F;Viewer&#x2F;:    npmAlwaysAuth: true    npmAuthIdent: c2hpLnFpdUAlbnZpc3RhY28uY236QUtDcDhuSER6YWo3NDNIekNDOVRxOW1Kb0tGVHVaKU5yZ2N4aU5jaWVRQ0hEb2tNR0ROTE43TGkybV5aRkVzSkxkUzdMYkDudA&#x3D;&#x3D;npmScopes:  qqsjfrog:    npmRegistryServer: &quot;https:&#x2F;&#x2F;qqstone.jfrog.io&#x2F;artifactory&#x2F;api&#x2F;npm&#x2F;Viewer&#x2F;&quot;\nTroubleShooting\n\ncannot be loaded because running scripts is disabled on this system.\n\n\n\n\n\nError: This tool requires a Node version compatible with &gt;=18.12.0\n\n Yarn v4要求nodejs &gt;=18.12.0\n 切换Yarn version的命令是 yarn set version 3.0.2 但是在v4且node imcompatible的情况下任何yarn命令均失效\n 只有npm i -g yarn 并没有npm i -g yarn@3 因此使用nvm切到node18再复原是较好的办法\n\n\nYN0028: The lockfile would have been modified by this install, which is explicitly forbidden.\n\nyarn install --frozen-lockfile false\nsee Github issue\n\nError: Your application tried to access XXX but it isn’t declared in your dependencies; this makes the require call ambiguous and unsound 疑因使用nvm导致存在冲突的yarn cache路径,导致程序并没有按yarn.lock确定所需的依赖包，该问题在卸载nvm，删除%USERPROFILE%\\AppData\\Local\\Yarn\\Berry文件并重装nodejs后解决\n\n\n","categories":["工具"],"tags":["yarn"]},{"title":"websocket","url":"/qqsnote/2020/04/09/websocket/","content":"ws: a Node.js WebSocket library\nws is a simple to use, blazing fast, and thoroughly tested WebSocket client andserver implementation.\nPasses the quite extensive Autobahn test suite: server,client.\nNote: This module does not work in the browser. The client in the docs is areference to a back end with the role of a client in the WebSocketcommunication. Browser clients must use the nativeWebSocketobject(QQs: browser client should call the Websocket constructor provided by browser, see the example at bottom of this article). To make the same code work seamlessly on Node.js and the browser, youcan use one of the many wrappers available on npm, likeisomorphic-ws.\nTable of Contents\nws: a Node.js WebSocket library\nTable of Contents\nProtocol support\nInstalling\nOpt-in for performance and spec compliance\n\n\nAPI docs\nWebSocket compression\nUsage examples\nSending and receiving text data\nSending binary data\nSimple server\nExternal HTTP/S server\nMultiple servers sharing a single HTTP/S server\nClient authentication\nServer broadcast\necho.websocket.org demo\nUse the Node.js streams API\nOther examples\n\n\nFAQ\nHow to get the IP address of the client?\nHow to detect and close broken connections?\nHow to connect via a proxy?\n\n\nChangelog\nLicense\nBrowser Client\n\n\n\n\n\nProtocol support\nHyBi drafts 07-12 (Use the option protocolVersion: 8)\nHyBi drafts 13-17 (Current default, alternatively optionprotocolVersion: 13)\n\nInstallingnpm install ws\nOpt-in for performance and spec complianceThere are 2 optional modules that can be installed along side with the wsmodule. These modules are binary addons which improve certain operations.Prebuilt binaries are available for the most popular platforms so you don’tnecessarily need to have a C++ compiler installed on your machine.\n\nnpm install --save-optional bufferutil: Allows to efficiently performoperations such as masking and unmasking the data payload of the WebSocketframes.\nnpm install --save-optional utf-8-validate: Allows to efficiently check if amessage contains valid UTF-8 as required by the spec.\n\nAPI docsSee /doc/ws.md for Node.js-like documentation of ws classes andutility functions.\nWebSocket compressionws supports the permessage-deflate extension which enablesthe client and server to negotiate a compression algorithm and its parameters,and then selectively apply it to the data payloads of each WebSocket message.\nThe extension is disabled by default on the server and enabled by default on theclient. It adds a significant overhead in terms of performance and memoryconsumption so we suggest to enable it only if it is really needed.\nNote that Node.js has a variety of issues with high-performance compression,where increased concurrency, especially on Linux, can lead to catastrophicmemory fragmentation and slow performance. If you intend to usepermessage-deflate in production, it is worthwhile to set up a testrepresentative of your workload and ensure Node.js/zlib will handle it withacceptable performance and memory usage.\nTuning of permessage-deflate can be done via the options defined below. You canalso use zlibDeflateOptions and zlibInflateOptions, which is passed directlyinto the creation of [raw deflate/inflate streams][node-zlib-deflaterawdocs].\nSee [the docs][ws-server-options] for more options.\nconst WebSocket = require(&#x27;ws&#x27;);const wss = new WebSocket.Server(&#123;  port: 8080,  perMessageDeflate: &#123;    zlibDeflateOptions: &#123;      // See zlib defaults.      chunkSize: 1024,      memLevel: 7,      level: 3    &#125;,    zlibInflateOptions: &#123;      chunkSize: 10 * 1024    &#125;,    // Other options settable:    clientNoContextTakeover: true, // Defaults to negotiated value.    serverNoContextTakeover: true, // Defaults to negotiated value.    serverMaxWindowBits: 10, // Defaults to negotiated value.    // Below options specified as default values.    concurrencyLimit: 10, // Limits zlib concurrency for perf.    threshold: 1024 // Size (in bytes) below which messages    // should not be compressed.  &#125;&#125;);\nThe client will only use the extension if it is supported and enabled on theserver. To always disable the extension on the client set theperMessageDeflate option to false.\nconst WebSocket = require(&#x27;ws&#x27;);const ws = new WebSocket(&#x27;ws://www.host.com/path&#x27;, &#123;  perMessageDeflate: false&#125;);\nUsage examplesSending and receiving text dataconst WebSocket = require(&#x27;ws&#x27;);const ws = new WebSocket(&#x27;ws://www.host.com/path&#x27;);ws.on(&#x27;open&#x27;, function open() &#123;  ws.send(&#x27;something&#x27;);&#125;);ws.on(&#x27;message&#x27;, function incoming(data) &#123;  console.log(data);&#125;);\nSending binary dataconst WebSocket = require(&#x27;ws&#x27;);const ws = new WebSocket(&#x27;ws://www.host.com/path&#x27;);ws.on(&#x27;open&#x27;, function open() &#123;  const array = new Float32Array(5);  for (var i = 0; i &lt; array.length; ++i) &#123;    array[i] = i / 2;  &#125;  ws.send(array);&#125;);\nSimple serverconst WebSocket = require(&#x27;ws&#x27;);const wss = new WebSocket.Server(&#123; port: 8080 &#125;);wss.on(&#x27;connection&#x27;, function connection(ws) &#123;  ws.on(&#x27;message&#x27;, function incoming(message) &#123;    console.log(&#x27;received: %s&#x27;, message);  &#125;);  ws.send(&#x27;something&#x27;);&#125;);\nExternal HTTP/S serverconst fs = require(&#x27;fs&#x27;);const https = require(&#x27;https&#x27;);const WebSocket = require(&#x27;ws&#x27;);const server = https.createServer(&#123;  cert: fs.readFileSync(&#x27;/path/to/cert.pem&#x27;),  key: fs.readFileSync(&#x27;/path/to/key.pem&#x27;)&#125;);const wss = new WebSocket.Server(&#123; server &#125;);wss.on(&#x27;connection&#x27;, function connection(ws) &#123;  ws.on(&#x27;message&#x27;, function incoming(message) &#123;    console.log(&#x27;received: %s&#x27;, message);  &#125;);  ws.send(&#x27;something&#x27;);&#125;);server.listen(8080);\nMultiple servers sharing a single HTTP/S serverconst http = require(&#x27;http&#x27;);const WebSocket = require(&#x27;ws&#x27;);const url = require(&#x27;url&#x27;);const server = http.createServer();const wss1 = new WebSocket.Server(&#123; noServer: true &#125;);const wss2 = new WebSocket.Server(&#123; noServer: true &#125;);wss1.on(&#x27;connection&#x27;, function connection(ws) &#123;  // ...&#125;);wss2.on(&#x27;connection&#x27;, function connection(ws) &#123;  // ...&#125;);server.on(&#x27;upgrade&#x27;, function upgrade(request, socket, head) &#123;  const pathname = url.parse(request.url).pathname;  if (pathname === &#x27;/foo&#x27;) &#123;    wss1.handleUpgrade(request, socket, head, function done(ws) &#123;      wss1.emit(&#x27;connection&#x27;, ws, request);    &#125;);  &#125; else if (pathname === &#x27;/bar&#x27;) &#123;    wss2.handleUpgrade(request, socket, head, function done(ws) &#123;      wss2.emit(&#x27;connection&#x27;, ws, request);    &#125;);  &#125; else &#123;    socket.destroy();  &#125;&#125;);server.listen(8080);\nClient authenticationconst http = require(&#x27;http&#x27;);const WebSocket = require(&#x27;ws&#x27;);const server = http.createServer();const wss = new WebSocket.Server(&#123; noServer: true &#125;);wss.on(&#x27;connection&#x27;, function connection(ws, request, client) &#123;  ws.on(&#x27;message&#x27;, function message(msg) &#123;    console.log(`Received message $&#123;msg&#125; from user $&#123;client&#125;`);  &#125;);&#125;);server.on(&#x27;upgrade&#x27;, function upgrade(request, socket, head) &#123;  authenticate(request, (err, client) =&gt; &#123;    if (err || !client) &#123;      socket.destroy();      return;    &#125;    wss.handleUpgrade(request, socket, head, function done(ws) &#123;      wss.emit(&#x27;connection&#x27;, ws, request, client);    &#125;);  &#125;);&#125;);server.listen(8080);\nAlso see the provided example using express-session.\nServer broadcastA client WebSocket broadcasting to all connected WebSocket clients, includingitself.\nconst WebSocket = require(&#x27;ws&#x27;);const wss = new WebSocket.Server(&#123; port: 8080 &#125;);wss.on(&#x27;connection&#x27;, function connection(ws) &#123;  ws.on(&#x27;message&#x27;, function incoming(data) &#123;    wss.clients.forEach(function each(client) &#123;      if (client.readyState === WebSocket.OPEN) &#123;        client.send(data);      &#125;    &#125;);  &#125;);&#125;);\nA client WebSocket broadcasting to every other connected WebSocket clients,excluding itself.\nconst WebSocket = require(&#x27;ws&#x27;);const wss = new WebSocket.Server(&#123; port: 8080 &#125;);wss.on(&#x27;connection&#x27;, function connection(ws) &#123;  ws.on(&#x27;message&#x27;, function incoming(data) &#123;    wss.clients.forEach(function each(client) &#123;      if (client !== ws &amp;&amp; client.readyState === WebSocket.OPEN) &#123;        client.send(data);      &#125;    &#125;);  &#125;);&#125;);\necho.websocket.org democonst WebSocket = require(&#x27;ws&#x27;);const ws = new WebSocket(&#x27;wss://echo.websocket.org/&#x27;, &#123;  origin: &#x27;https://websocket.org&#x27;&#125;);ws.on(&#x27;open&#x27;, function open() &#123;  console.log(&#x27;connected&#x27;);  ws.send(Date.now());&#125;);ws.on(&#x27;close&#x27;, function close() &#123;  console.log(&#x27;disconnected&#x27;);&#125;);ws.on(&#x27;message&#x27;, function incoming(data) &#123;  console.log(`Roundtrip time: $&#123;Date.now() - data&#125; ms`);  setTimeout(function timeout() &#123;    ws.send(Date.now());  &#125;, 500);&#125;);\nUse the Node.js streams APIconst WebSocket = require(&#x27;ws&#x27;);const ws = new WebSocket(&#x27;wss://echo.websocket.org/&#x27;, &#123;  origin: &#x27;https://websocket.org&#x27;&#125;);const duplex = WebSocket.createWebSocketStream(ws, &#123; encoding: &#x27;utf8&#x27; &#125;);duplex.pipe(process.stdout);process.stdin.pipe(duplex);\nOther examplesFor a full example with a browser client communicating with a ws server, see theexamples folder.\nOtherwise, see the test cases.\nFAQHow to get the IP address of the client?The remote IP address can be obtained from the raw socket.\nconst WebSocket = require(&#x27;ws&#x27;);const wss = new WebSocket.Server(&#123; port: 8080 &#125;);wss.on(&#x27;connection&#x27;, function connection(ws, req) &#123;  const ip = req.connection.remoteAddress;&#125;);\nWhen the server runs behind a proxy like NGINX, the de-facto standard is to usethe X-Forwarded-For header.\nwss.on(&#x27;connection&#x27;, function connection(ws, req) &#123;  const ip = req.headers[&#x27;x-forwarded-for&#x27;].split(/\\s*,\\s*/)[0];&#125;);\nHow to detect and close broken connections?Sometimes the link between the server and the client can be interrupted in a waythat keeps both the server and the client unaware of the broken state of theconnection (e.g. when pulling the cord).\nIn these cases ping messages can be used as a means to verify that the remoteendpoint is still responsive.\nconst WebSocket = require(&#x27;ws&#x27;);function noop() &#123;&#125;function heartbeat() &#123;  this.isAlive = true;&#125;const wss = new WebSocket.Server(&#123; port: 8080 &#125;);wss.on(&#x27;connection&#x27;, function connection(ws) &#123;  ws.isAlive = true;  ws.on(&#x27;pong&#x27;, heartbeat);&#125;);const interval = setInterval(function ping() &#123;  wss.clients.forEach(function each(ws) &#123;    if (ws.isAlive === false) return ws.terminate();    ws.isAlive = false;    ws.ping(noop);  &#125;);&#125;, 30000);wss.on(&#x27;close&#x27;, function close() &#123;  clearInterval(interval);&#125;);\nPong messages are automatically sent in response to ping messages as required bythe spec.\nJust like the server example above your clients might as well lose connectionwithout knowing it. You might want to add a ping listener on your clients toprevent that. A simple implementation would be:\nconst WebSocket = require(&#x27;ws&#x27;);function heartbeat() &#123;  clearTimeout(this.pingTimeout);  // Use `WebSocket#terminate()`, which immediately destroys the connection,  // instead of `WebSocket#close()`, which waits for the close timer.  // Delay should be equal to the interval at which your server  // sends out pings plus a conservative assumption of the latency.  this.pingTimeout = setTimeout(() =&gt; &#123;    this.terminate();  &#125;, 30000 + 1000);&#125;const client = new WebSocket(&#x27;wss://echo.websocket.org/&#x27;);client.on(&#x27;open&#x27;, heartbeat);client.on(&#x27;ping&#x27;, heartbeat);client.on(&#x27;close&#x27;, function clear() &#123;  clearTimeout(this.pingTimeout);&#125;);\nHow to connect via a proxy?Use a custom http.Agent implementation like https-proxy-agent orsocks-proxy-agent.\nChangelogWe’re using the GitHub releases for changelog entries.\nLicenseMIT\n[node-zlib-deflaterawdocs]:  https://nodejs.org/api/zlib.html#zlib_zlib_createdeflateraw_options\n[ws-server-options]:  https://github.com/websockets/ws/blob/master/doc/ws.md#new-websocketserveroptions-callback\nBrowser Client&#x2F;&#x2F; Create WebSocket connection.const socket &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:8080&#39;);&#x2F;&#x2F; Connection openedsocket.addEventListener(&#39;open&#39;, function (event) &#123;    socket.send(&#39;Hello Server!&#39;);&#125;);&#x2F;&#x2F; Listen for messagessocket.addEventListener(&#39;message&#39;, function (event) &#123;    console.log(&#39;Message from server &#39;, event.data);&#125;);","tags":["websocket"]}]